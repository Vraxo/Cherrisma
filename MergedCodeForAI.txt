<file path="MainScene.cs">
using Cherris;

namespace Cherrisma;

public class MainScene : Node
{
    public override void Process()
    {
        base.Process();

        // The HSlider's position will now be determined by its AnchorPreset and Margin
        // properties, as defined in the Res/Main.yaml file.
        // The line below is removed to prevent overriding the declarative layout.
        // GetNode<HSlider>("Slider").Position = GetWindowSizeV2() / 2;
    }
}
</file>

<file path="Program.cs">
using Cherris;

namespace Cherrisma;

public sealed class EntryPoint
{
    public static void Main()
    {
        ApplicationServer.Instance.Run();
    }
}
</file>

<file path="Res\Main.yaml">
Node: MainScene::MainScene
children:
    - Node: HSlider::Slider
      AnchorPreset: BottomCenter
      Size: [300, 8]
      RelativeWidth: 0.5
      MarginBottom: 32
      GrabberSize: [24, 24]
      Style:
        Foreground:
          Roundness: 1
        Background:
          Roundness: 1
        Grabber:
          FillColor: [0, 0, 0, 0]
          BorderColor: [0, 0, 0, 0]
          Roundness: 1
</file>

<file path="Res\Cherris\Config.yaml">
Width: 950
Height: 750
MinWidth: 1280
MinHeight: 720
MaxWidth: -1
MaxHeight: -1
Title: Cheris
ResizableWindow: true
AntiAliasing: true
MainScenePath: Res/Main.yaml
Backend: Raylib
BackdropType: MicaAlt
VSync: false
</file>

<file path="Res\Main.yaml">

</file>

<file path="Source\BoxStyle.cs">
using Vortice.Mathematics;

namespace Cherris;

public class BoxStyle
{
    public float Roundness { get; set; } = 0.2f;
    public Color4 FillColor { get; set; } = DefaultTheme.NormalFill;
    public Color4 BorderColor { get; set; } = DefaultTheme.NormalBorder;

    public float BorderLengthTop { get; set; } = 1.0f;
    public float BorderLengthRight { get; set; } = 1.0f;
    public float BorderLengthBottom { get; set; } = 1.0f;
    public float BorderLengthLeft { get; set; } = 1.0f;

    public float BorderLength
    {
        set
        {
            BorderLengthTop = value;
            BorderLengthRight = value;
            BorderLengthBottom = value;
            BorderLengthLeft = value;
        }
    }
}
</file>

<file path="Source\ButtonStyle.cs">
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace Cherris;

public class ButtonStyle : BoxStyle
{
    public Font? Font { get; set; } = null;
    public Color4 FontColor { get; set; } = DefaultTheme.Text;

    public string FontName { get; set; } = "Segoe UI";
    public float FontSize { get; set; } = 16.0f;
    public FontWeight FontWeight { get; set; } = FontWeight.Normal;
    public FontStyle FontStyle { get; set; } = FontStyle.Normal;
    public FontStretch FontStretch { get; set; } = FontStretch.Normal;
    public WordWrapping WordWrapping { get; set; } = WordWrapping.WholeWord;
}
</file>

<file path="Source\ButtonStylePack.cs">
using System;
using System.Collections.Generic;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace Cherris;

public sealed class ButtonStylePack
{
    public ButtonStyle Current { get; set; } = new();
    public ButtonStyle Normal { get; set; } = new();
    public ButtonStyle Hover { get; set; } = new();
    public ButtonStyle Pressed { get; set; } = new();
    public ButtonStyle Disabled { get; set; } = new();
    public ButtonStyle Focused { get; set; } = new();

    private IEnumerable<ButtonStyle> AllStyles => [Current, Normal, Hover, Pressed, Disabled, Focused];

    public ButtonStylePack()
    {
        Hover.FillColor = DefaultTheme.HoverFill;

        Pressed.FillColor = DefaultTheme.Accent;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;

        Focused.BorderColor = DefaultTheme.FocusBorder;
        Focused.BorderLength = 1;
    }

    public float FontSize
    {
        get;
        set
        {
            field = value;
            SetAll(s => s.FontSize = value);
        }
    } = 0;

    public Font Font
    {
        set => SetAll(s => s.Font = value);
    }

    public Color FontColor
    {
        set => SetAll(s => s.FontColor = value);
    }

    public float Roundness
    {
        set => SetAll(s => s.Roundness = value);
    }

    public float BorderLength
    {
        set => SetAll(s => s.BorderLength = value);
    }

    public Color FillColor
    {
        set => SetAll(s => s.FillColor = value);
    }

    public Color BorderColor
    {
        set => SetAll(s => s.BorderColor = value);
    }

    public float BorderLengthTop
    {
        set => SetAll(s => s.BorderLengthTop = value);
    }

    public float BorderLengthBottom
    {
        set => SetAll(s => s.BorderLengthBottom = value);
    }

    public WordWrapping WordWrapping
    {
        set => SetAll(s => s.WordWrapping = value);
    }

    private void SetAll(Action<ButtonStyle> setter)
    {
        foreach (ButtonStyle style in AllStyles)
        {
            setter(style);
        }
    }
}
</file>

<file path="Source\ClickServer.cs">
namespace Cherris;

public sealed class ClickServer
{
    public static ClickServer Instance { get; } = new();

    public int MinLayer = -1;

    private readonly List<Clickable> clickables = [];
    private const bool Debug = false;

    private ClickServer() { }

    public void Register(Clickable clickable)
    {
        clickables.Add(clickable);
    }

    public void Unregister(Clickable clickable)
    {
        clickables.Remove(clickable);
    }

    public void Process()
    {
        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            SignalClick(MouseButtonCode.Left);
        }

        if (Input.IsMouseButtonPressed(MouseButtonCode.Right))
        {
            SignalClick(MouseButtonCode.Right);
        }
    }

    public int GetHighestLayer()
    {
        int highestLayer = MinLayer;

        foreach (Clickable clickable in clickables)
        {
            if (clickable.Layer <= highestLayer)
            {
                continue;
            }

            highestLayer = clickable.Layer;
        }

        return highestLayer;
    }

    private void SignalClick(MouseButtonCode mouseButton)
    {
        List<Clickable> viableClickables = GetViableClickables();

        if (viableClickables.Count <= 0)
        {
            return;
        }

        Clickable? topClickable = GetTopClickable(viableClickables);

        if (topClickable is null)
        {
            return;
        }

        if (mouseButton == MouseButtonCode.Left)
        {
            topClickable.OnTopLeft = true;
            Log.Info($"'{topClickable.Name}' has been left clicked.", Debug);
        }
        else
        {
            topClickable.OnTopRight = true;
            Log.Info($"'{topClickable.Name}' has been right clicked.", Debug);
        }
    }

    private List<Clickable> GetViableClickables()
    {
        List<Clickable> viableClickables = [];

        foreach (Clickable clickable in clickables)
        {
            if (!IsMouseOverNode2D(clickable))
            {
                continue;
            }

            viableClickables.Add(clickable);
        }

        Log.Info($"{viableClickables.Count} viable clickables.", Debug);

        return viableClickables;
    }

    private Clickable? GetTopClickable(List<Clickable> viableClickables)
    {
        Clickable? topClickable = null;
        int highestLayer = MinLayer;

        foreach (Clickable clickable in viableClickables)
        {
            if (clickable.Layer < highestLayer)
            {
                continue;
            }

            highestLayer = clickable.Layer;
            topClickable = clickable;
        }

        Log.Info($"The highest layer is {viableClickables.Count}.", Debug);

        return topClickable;
    }

    private static bool IsMouseOverNode2D(Node2D node)
    {
        Vector2 mousePosition = Input.WorldMousePosition;

        bool isMouseOver =
            mousePosition.X > node.GlobalPosition.X - node.Origin.X &&
            mousePosition.X < node.GlobalPosition.X + node.ScaledSize.X - node.Origin.X &&
            mousePosition.Y > node.GlobalPosition.Y - node.Origin.Y &&
            mousePosition.Y < node.GlobalPosition.Y + node.ScaledSize.Y - node.Origin.Y;

        return isMouseOver;
    }
}
</file>

<file path="Source\Configuration.cs">
namespace Cherris;

public class Configuration
{
    public int Width { get; set; } = 0;
    public int Height { get; set; } = 0;
    public int MinWidth { get; set; } = 0;
    public int MinHeight { get; set; } = 0;
    public int MaxWidth { get; set; } = 0;
    public int MaxHeight { get; set; } = 0;
    public string Title { get; set; } = "Cherris";
    public bool ResizableWindow { get; set; } = true;
    public bool AntiAliasing { get; set; } = true;
    public string MainScenePath { get; set; } = "";
    public string Backend { get; set; } = "Raylib";
    public SystemBackdropType BackdropType { get; set; } = SystemBackdropType.MicaAlt;
    public bool VSync { get; set; } = true;
}
</file>

<file path="Source\DefaultTheme.cs">
// DefaultTheme.cs
using Vortice.Mathematics;

namespace Cherris;

// Defines default colors for the UI theme
public static class DefaultTheme
{
    // Basic Palette
    public static readonly Color4 White = Colors.White;
    public static readonly Color4 Black = Colors.Black;
    public static readonly Color4 Transparent = Colors.Transparent;

    // UI Element Colors (Examples, adjust as needed)
    public static readonly Color4 NormalFill = new Color4(0.25f, 0.25f, 0.3f, 1.0f);
    public static readonly Color4 NormalBorder = new Color4(0.4f, 0.4f, 0.45f, 1.0f);

    public static readonly Color4 HoverFill = new Color4(0.35f, 0.35f, 0.4f, 1.0f);
    public static readonly Color4 HoverBorder = new Color4(0.5f, 0.5f, 0.55f, 1.0f);

    public static readonly Color4 Accent = new Color4(0.2f, 0.4f, 0.8f, 1.0f); // Used for Pressed Fill
    public static readonly Color4 AccentBorder = new Color4(0.3f, 0.5f, 0.9f, 1.0f); // Used for Pressed Border

    public static readonly Color4 DisabledFill = new Color4(0.2f, 0.2f, 0.2f, 0.8f);
    public static readonly Color4 DisabledBorder = new Color4(0.3f, 0.3f, 0.3f, 0.8f);
    public static readonly Color4 DisabledText = new Color4(0.5f, 0.5f, 0.5f, 1.0f);

    public static readonly Color4 FocusBorder = Colors.LightSkyBlue; // Example focus color

    public static readonly Color4 Text = Colors.WhiteSmoke;
}
</file>

<file path="Source\Direct2DAppWindow.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using SharpGen.Runtime;
using Vortice.DCommon;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.DXGI;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;
using D2DFactoryType = Vortice.Direct2D1.FactoryType;
using DW = Vortice.DirectWrite;
using Rect = Vortice.Mathematics.Rect;
using SizeI = Vortice.Mathematics.SizeI;

namespace Cherris;

public abstract class Direct2DAppWindow : Win32Window
{
    protected ID2D1Factory1? d2dFactory;
    protected IDWriteFactory? dwriteFactory;
    protected ID2D1HwndRenderTarget? renderTarget;

    protected Color4 backgroundColor = Colors.Black;
    protected bool graphicsInitialized = false;

    private Stopwatch fpsTimer = new();
    private long lastFpsUpdateTimeTicks = 0;
    private int frameCountSinceUpdate = 0;
    private const long FpsUpdateIntervalTicks = TimeSpan.TicksPerSecond / 2;
    private ID2D1SolidColorBrush? fpsTextBrush;
    private IDWriteTextFormat? fpsTextFormat;
    private readonly Color4 fpsTextColor = DefaultTheme.Text;
    private readonly string fpsFontName = "Consolas";
    private readonly float fpsFontSize = 14.0f;

    private Dictionary<Color4, ID2D1SolidColorBrush> brushCache = new();
    private Dictionary<string, IDWriteTextFormat> textFormatCache = new();

    public float CurrentFps { get; private set; } = 0.0f;

    public Direct2DAppWindow(string title = "Vortice DirectUI Base Window", int width = 800, int height = 600)
        : base(title, width, height)
    { }

    protected override bool Initialize()
    {
        Log.Info($"Direct2DAppWindow '{Title}' initializing Vortice Graphics...");
        return InitializeGraphics();
    }

    protected override void Cleanup()
    {
        Log.Info($"Direct2DAppWindow '{Title}' cleaning up its resources...");
        CleanupGraphics();
    }

    public override void RenderFrame()
    {
        if (!fpsTimer.IsRunning)
        {
            fpsTimer.Start();
            lastFpsUpdateTimeTicks = fpsTimer.ElapsedTicks;
            frameCountSinceUpdate = 0;
        }

        frameCountSinceUpdate++;
        long elapsedTicks = fpsTimer.ElapsedTicks;
        long timeSinceLastUpdate = elapsedTicks - lastFpsUpdateTimeTicks;

        if (timeSinceLastUpdate >= FpsUpdateIntervalTicks)
        {
            float secondsElapsed = (float)timeSinceLastUpdate / TimeSpan.TicksPerSecond;
            CurrentFps = (secondsElapsed > 0.001f) ? (frameCountSinceUpdate / secondsElapsed) : 0.0f;
            frameCountSinceUpdate = 0;
            lastFpsUpdateTimeTicks = elapsedTicks;
        }

        if (!graphicsInitialized || renderTarget is null || dwriteFactory is null)
        {
            if (!graphicsInitialized && Handle != nint.Zero && IsOpen)
            {
                Log.Warning($"Graphics not initialized in RenderFrame for '{Title}', attempting reinitialization.");
                InitializeGraphics();
                if (!graphicsInitialized || renderTarget is null || dwriteFactory is null)
                {
                    Log.Error($"Reinitialization failed in RenderFrame for '{Title}'.");
                    return;
                }
            }
            else
            {
                Log.Warning($"RenderFrame skipped for '{Title}': Graphics not ready or window closed.");
                return;
            }
        }

        try
        {
            renderTarget.BeginDraw();
            renderTarget.Clear(backgroundColor);

            var drawingContext = new DrawingContext(renderTarget, dwriteFactory, this);

            DrawUIContent(drawingContext);

            if (fpsTextBrush is not null && fpsTextFormat is not null)
            {
                string fpsText = $"FPS: {CurrentFps:F1}";
                Rect fpsLayoutRect = new Rect(5f, 5f, 150f, 30f);
                renderTarget.DrawText(fpsText, fpsTextFormat, fpsLayoutRect, fpsTextBrush);
            }

            Result endDrawResult = renderTarget.EndDraw();

            if (endDrawResult.Failure)
            {
                Log.Error($"EndDraw failed for '{Title}': {endDrawResult.Description}");
                if (endDrawResult.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Log.Warning($"Render target needs recreation for '{Title}' (Detected in EndDraw).");
                    graphicsInitialized = false;
                    CleanupGraphics();
                    InitializeGraphics();
                }
            }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Error($"Render target needs recreation for '{Title}' (Caught SharpGenException in RenderFrame): {ex.Message}");
            graphicsInitialized = false;
            CleanupGraphics();
            InitializeGraphics();
        }
        catch (Exception ex)
        {
            Log.Error($"Rendering Error in RenderFrame for '{Title}': {ex}");
            graphicsInitialized = false;
            CleanupGraphics();
            InitializeGraphics();
        }
    }

    protected abstract void DrawUIContent(DrawingContext context);

    protected override void OnSize(int width, int height)
    {
        if (graphicsInitialized && renderTarget is not null && width > 0 && height > 0)
        {
            Log.Info($"Window '{Title}' resized to {width}x{height}. Resizing render target...");
            try
            {
                var newPixelSize = new SizeI(width, height);

                CleanupDeviceSpecificResources();

                renderTarget.Resize(newPixelSize);

                RecreateDeviceSpecificResources();

                Log.Info($"Successfully resized render target for '{Title}'.");
                Invalidate();
            }
            catch (SharpGenException ex)
            {
                Log.Error($"Failed to resize Render Target for '{Title}' (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
                if (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Log.Warning($"Render target needs recreation for '{Title}' (Detected in Resize Exception).");
                    graphicsInitialized = false;
                    CleanupGraphics();
                    InitializeGraphics();
                }
            }
            catch (Exception ex)
            {
                Log.Error($"Failed to resize Render Target for '{Title}' (General Exception): {ex}");
                graphicsInitialized = false;
                CleanupGraphics();
                InitializeGraphics();
            }
        }
        else if (!graphicsInitialized && Handle != nint.Zero && IsOpen && width > 0 && height > 0)
        {
            Log.Warning($"OnSize called for '{Title}' but graphics not initialized. Attempting initialization.");
            InitializeGraphics();
        }
        else if (width <= 0 || height <= 0)
        {
            Log.Warning($"Ignoring OnSize call for '{Title}' with invalid dimensions: {width}x{height}");
        }
    }

    protected override void OnMouseMove(int x, int y) { }
    protected override void OnMouseDown(MouseButton button, int x, int y) { }
    protected override void OnMouseUp(MouseButton button, int x, int y) { }
    protected override void OnKeyDown(int keyCode) { }
    protected override void OnKeyUp(int keyCode) { }
    protected override void OnMouseWheel(short delta) { }

    protected virtual bool InitializeGraphics()
    {
        if (graphicsInitialized) return true;
        if (Handle == nint.Zero || !IsOpen)
        {
            Log.Warning($"InitializeGraphics skipped for '{Title}': Invalid handle or window not open.");
            return false;
        }

        Log.Info($"Attempting Graphics Initialization for '{Title}' HWND {Handle}...");

        try
        {
            CleanupGraphics();

            Result factoryResult = D2D1.D2D1CreateFactory(D2DFactoryType.SingleThreaded, out d2dFactory);
            factoryResult.CheckError();
            if (d2dFactory is null) throw new InvalidOperationException($"D2D Factory creation failed silently for '{Title}'.");

            Result dwriteResult = DWrite.DWriteCreateFactory(DW.FactoryType.Shared, out dwriteFactory);
            dwriteResult.CheckError();
            if (dwriteFactory is null) throw new InvalidOperationException($"DWrite Factory creation failed silently for '{Title}'.");

            var clientRectSize = GetClientRectSize();
            if (clientRectSize.Width <= 0 || clientRectSize.Height <= 0)
            {
                Log.Warning($"Invalid client rect size ({clientRectSize.Width}x{clientRectSize.Height}) for '{Title}'. Aborting graphics initialization.");
                CleanupGraphics();
                return false;
            }

            var dxgiPixelFormat = new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied);
            var renderTargetProperties = new RenderTargetProperties(dxgiPixelFormat);
            var hwndRenderTargetProperties = new HwndRenderTargetProperties
            {
                Hwnd = Handle,
                PixelSize = new SizeI(clientRectSize.Width, clientRectSize.Height),
                PresentOptions = VSyncEnabled ? PresentOptions.None : PresentOptions.Immediately
            };

            renderTarget = d2dFactory.CreateHwndRenderTarget(renderTargetProperties, hwndRenderTargetProperties);
            if (renderTarget is null) throw new InvalidOperationException($"Render target creation returned null unexpectedly for '{Title}'.");

            renderTarget.TextAntialiasMode = D2D.TextAntialiasMode.Cleartype;

            brushCache = new Dictionary<Color4, ID2D1SolidColorBrush>();
            textFormatCache = new Dictionary<string, IDWriteTextFormat>();

            RecreateDeviceSpecificResources();

            frameCountSinceUpdate = 0;
            CurrentFps = 0;
            lastFpsUpdateTimeTicks = 0;
            fpsTimer.Restart();

            Log.Info($"Vortice Graphics initialized successfully for '{Title}' HWND {Handle}.");
            graphicsInitialized = true;
            return true;
        }
        catch (SharpGenException ex)
        {
            Log.Error($"Graphics Initialization failed for '{Title}' (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
            CleanupGraphics(); graphicsInitialized = false; return false;
        }
        catch (Exception ex)
        {
            Log.Error($"Graphics Initialization failed for '{Title}' (General Exception): {ex}");
            CleanupGraphics(); graphicsInitialized = false; return false;
        }
    }

    private void RecreateDeviceSpecificResources()
    {
        if (renderTarget is null || dwriteFactory is null) return;

        try
        {
            fpsTextFormat?.Dispose();
            fpsTextFormat = dwriteFactory.CreateTextFormat(fpsFontName, null, FontWeight.Normal, FontStyle.Normal, FontStretch.Normal, fpsFontSize, "en-us");
            fpsTextFormat.TextAlignment = DW.TextAlignment.Leading;
            fpsTextFormat.ParagraphAlignment = ParagraphAlignment.Near;

            fpsTextBrush?.Dispose();
            fpsTextBrush = renderTarget.CreateSolidColorBrush(fpsTextColor);

            Log.Info($"Recreated FPS drawing resources for '{Title}'.");
        }
        catch (Exception ex)
        {
            Log.Error($"Warning: Failed to recreate device-specific resources for '{Title}': {ex.Message}");
            CleanupDeviceSpecificResources();
        }
    }

    private void CleanupDeviceSpecificResources()
    {
        fpsTextBrush?.Dispose(); fpsTextBrush = null;
        fpsTextFormat?.Dispose(); fpsTextFormat = null;

        foreach (var brush in brushCache.Values) brush?.Dispose();
        brushCache.Clear();
        foreach (var format in textFormatCache.Values) format?.Dispose();
        textFormatCache.Clear();
        Log.Info($"Cleaned device-specific resources (brushes, formats) for '{Title}'.");
    }

    protected virtual void CleanupGraphics()
    {
        bool resourcesExisted = d2dFactory is not null || renderTarget is not null || dwriteFactory is not null;
        if (resourcesExisted) Log.Info($"Cleaning up Vortice Graphics resources for '{Title}'...");

        fpsTimer.Stop();

        CleanupDeviceSpecificResources();

        renderTarget?.Dispose(); renderTarget = null;
        dwriteFactory?.Dispose(); dwriteFactory = null;
        d2dFactory?.Dispose(); d2dFactory = null;
        graphicsInitialized = false;

        if (resourcesExisted) Log.Info($"Finished cleaning graphics resources for '{Title}'.");
    }

    protected SizeI GetClientRectSize()
    {
        if (Handle != nint.Zero && NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            int width = Math.Max(1, r.right - r.left);
            int height = Math.Max(1, r.bottom - r.top);
            return new SizeI(width, height);
        }

        int baseWidth = Math.Max(1, Width);
        int baseHeight = Math.Max(1, Height);
        if (Handle != nint.Zero)
        {
            Log.Warning($"GetClientRect failed for '{Title}'. Falling back to stored size: {baseWidth}x{baseHeight}");
        }
        return new SizeI(baseWidth, baseHeight);
    }

    public ID2D1SolidColorBrush? GetOrCreateBrush(Color4 color)
    {
        if (renderTarget is null)
        {
            Log.Warning($"GetOrCreateBrush called on '{Title}' with null RenderTarget.");
            return null;
        }

        if (brushCache.TryGetValue(color, out ID2D1SolidColorBrush? brush) && brush is not null)
        {
            return brush;
        }
        else if (brushCache.ContainsKey(color))
        {
            brushCache.Remove(color);
        }

        try
        {
            brush = renderTarget.CreateSolidColorBrush(color);
            if (brush is not null)
            {
                brushCache[color] = brush;
            }
            return brush;
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Warning($"Recreate target detected in GetOrCreateBrush for color {color} on '{Title}'.");
            CleanupDeviceSpecificResources();
            return null;
        }
        catch (Exception ex)
        {
            Log.Error($"Error creating brush for color {color} on '{Title}': {ex.Message}");
            return null;
        }
    }

    public IDWriteTextFormat? GetOrCreateTextFormat(ButtonStyle style)
    {
        if (dwriteFactory is null || style is null)
        {
            Log.Warning($"GetOrCreateTextFormat called on '{Title}' with null DWriteFactory or null style.");
            return null;
        }

        string cacheKey = $"{style.FontName}_{style.FontSize}_{style.FontWeight}_{style.FontStyle}_{style.FontStretch}_{style.WordWrapping}";

        if (textFormatCache.TryGetValue(cacheKey, out IDWriteTextFormat? format) && format is not null)
        {
            return format;
        }
        else if (textFormatCache.ContainsKey(cacheKey))
        {
            textFormatCache.Remove(cacheKey);
        }

        try
        {
            format = dwriteFactory.CreateTextFormat(
                style.FontName,
                null,
                style.FontWeight,
                style.FontStyle,
                style.FontStretch,
                style.FontSize,
                "en-us"
            );

            if (format is not null)
            {
                format.WordWrapping = style.WordWrapping;
                textFormatCache[cacheKey] = format;
            }
            return format;
        }
        catch (Exception ex)
        {
            Log.Error($"Error creating text format for key {cacheKey} on '{Title}': {ex.Message}");
            return null;
        }
    }
}
</file>

<file path="Source\DisplayServer.cs">
namespace Cherris;

public sealed class DisplayServer
{
    private static DisplayServer? _instance;
    public static DisplayServer Instance => _instance ??= new();

    // Public

    public DisplayServer()
    {
        // Constructor remains if any future non-Raylib global display settings are needed.
    }

    // All Raylib-specific methods and properties have been removed.
    // Window size and mouse position are now handled by individual window instances (Win32Window derived classes)
    // and can be queried via Node.GetOwningWindow() and then window.Width/Height or window.GetLocalMousePosition().
}
</file>

<file path="Source\DrawingContext.cs">
using Vortice.Direct2D1;
using Vortice.DirectWrite;

namespace Cherris;


public readonly struct DrawingContext
{
    public readonly ID2D1HwndRenderTarget RenderTarget;
    public readonly IDWriteFactory DWriteFactory;
    public readonly Direct2DAppWindow OwnerWindow;


    public DrawingContext(ID2D1HwndRenderTarget renderTarget, IDWriteFactory dwriteFactory, Direct2DAppWindow ownerWindow)
    {
        RenderTarget = renderTarget;
        DWriteFactory = dwriteFactory;
        OwnerWindow = ownerWindow;
    }
}
</file>

<file path="Source\FileLoader.cs">
using Cherris;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

public static class FileLoader
{
    private static readonly IDeserializer _deserializer = new DeserializerBuilder()
        .WithNamingConvention(PascalCaseNamingConvention.Instance)
        .Build();

    public static T Load<T>(string filePath) where T : new()
    {
        string yamlContent = File.ReadAllText(filePath);
        object data = _deserializer.Deserialize<object>(yamlContent);

        T instance = new();
        ProcessYamlData(instance, data, "");
        return instance;
    }

    private static void ProcessYamlData(object target, object yamlData, string currentPath)
    {
        switch (yamlData)
        {
            case Dictionary<object, object> dict:
                foreach (KeyValuePair<object, object> entry in dict)
                {
                    string key = entry.Key.ToString()!;
                    string newPath = string.IsNullOrEmpty(currentPath)
                        ? key
                        : $"{currentPath}/{key}";

                    ProcessYamlData(target, entry.Value, newPath);
                }
                break;

            case List<object> list:
                NodePropertySetter.SetNestedMember(target, currentPath, list);
                break;

            default:
                NodePropertySetter.SetNestedMember(target, currentPath, yamlData);
                break;
        }
    }
}
</file>

<file path="Source\GlobalSuppressions.cs">
// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.

using System.Diagnostics.CodeAnalysis;

[assembly: SuppressMessage("Style", "IDE0130:Namespace does not match folder structure", Justification = "<Pending>", Scope = "namespace", Target = "~N:Cherris")]
</file>

<file path="Source\GlobalUsings.cs">
// Types
//global using Color = Raylib_cs.Color;
//global using Image = Raylib_cs.Image;
//global using Rectangle = Raylib_cs.Rectangle;
global using Color = Vortice.Mathematics.Color4;
global using Vector2 = System.Numerics.Vector2;

// Resources

// Nodes
//global using Button = Cherris.Button;
//global using CheckBox = Cherris.CheckBox;
//global using ProgressBar = Cherris.ProgressBar;
//global using Timer = Cherris.Timer;
</file>

<file path="Source\HAlignment.cs">
namespace Cherris;

public enum OriginPreset
{
    None,
    Center,
    CenterLeft,
    CenterRight,
    TopLeft,
    TopCenter,
    TopRight,
    BottomCenter,
    BottomLeft,
    BottomRight,
}

public enum HAlignment
{
    Left,
    Center,
    Right,
    None
}
</file>

<file path="Source\Input.cs">
// file: Input.cs
namespace Cherris;

public static class Input
{
    private static Vector2 _currentMousePosition = Vector2.Zero;
    private static readonly HashSet<MouseButtonCode> _currentMouseButtonsDown = [];
    private static readonly HashSet<MouseButtonCode> _previousMouseButtonsDown = [];
    private static readonly HashSet<KeyCode> _currentKeysDown = [];
    private static readonly HashSet<KeyCode> _previousKeysDown = [];
    private static float _mouseWheelMovement = 0f;

    private static readonly Dictionary<string, KeyCode> _positiveXActions = [];
    private static readonly Dictionary<string, KeyCode> _negativeXActions = [];
    private static readonly Dictionary<string, KeyCode> _positiveYActions = [];
    private static readonly Dictionary<string, KeyCode> _negativeYActions = [];


    public static void Update()
    {
        _previousMouseButtonsDown.Clear();
        foreach (var button in _currentMouseButtonsDown)
        {
            _previousMouseButtonsDown.Add(button);
        }

        _previousKeysDown.Clear();
        foreach (var key in _currentKeysDown)
        {
            _previousKeysDown.Add(key);
        }

        _mouseWheelMovement = 0f;
    }

    internal static void UpdateMouseButton(MouseButtonCode button, bool isDown)
    {
        if (isDown)
        {
            _currentMouseButtonsDown.Add(button);
        }
        else
        {
            _currentMouseButtonsDown.Remove(button);
        }
    }

    internal static void UpdateKey(KeyCode key, bool isDown)
    {
        if (isDown)
        {
            _currentKeysDown.Add(key);
        }
        else
        {
            _currentKeysDown.Remove(key);
        }
    }

    internal static void UpdateMousePosition(Vector2 position)
    {
        _currentMousePosition = position;
    }

    internal static void UpdateMouseWheel(float delta)
    {
        _mouseWheelMovement = delta;
    }


    public static bool IsActionDown(string actionName)
    {
        if (_positiveXActions.TryGetValue(actionName, out var posXKey) && IsKeyDown(posXKey)) return true;
        if (_negativeXActions.TryGetValue(actionName, out var negXKey) && IsKeyDown(negXKey)) return true;
        if (_positiveYActions.TryGetValue(actionName, out var posYKey) && IsKeyDown(posYKey)) return true;
        if (_negativeYActions.TryGetValue(actionName, out var negYKey) && IsKeyDown(negYKey)) return true;

        return false;
    }

    public static bool IsActionPressed(string actionName)
    {
        if (_positiveXActions.TryGetValue(actionName, out var posXKey) && IsKeyPressed(posXKey)) return true;
        if (_negativeXActions.TryGetValue(actionName, out var negXKey) && IsKeyPressed(negXKey)) return true;
        if (_positiveYActions.TryGetValue(actionName, out var posYKey) && IsKeyPressed(posYKey)) return true;
        if (_negativeYActions.TryGetValue(actionName, out var negYKey) && IsKeyPressed(negYKey)) return true;
        return false;
    }


    public static bool IsKeyPressed(KeyCode keyboardKey)
    {
        return _currentKeysDown.Contains(keyboardKey) && !_previousKeysDown.Contains(keyboardKey);
    }

    public static bool IsKeyReleased(KeyCode keyboardKey)
    {
        return !_currentKeysDown.Contains(keyboardKey) && _previousKeysDown.Contains(keyboardKey);
    }

    public static bool IsKeyDown(KeyCode keyboardKey)
    {
        return _currentKeysDown.Contains(keyboardKey);
    }


    public static bool IsMouseButtonPressed(MouseButtonCode button)
    {
        return _currentMouseButtonsDown.Contains(button) && !_previousMouseButtonsDown.Contains(button);
    }

    public static bool IsMouseButtonReleased(MouseButtonCode button)
    {
        return !_currentMouseButtonsDown.Contains(button) && _previousMouseButtonsDown.Contains(button);
    }

    public static bool IsMouseButtonDown(MouseButtonCode button)
    {
        return _currentMouseButtonsDown.Contains(button);
    }

    public static float GetMouseWheelMovement()
    {
        return _mouseWheelMovement;
    }

    public static Vector2 MousePosition => _currentMousePosition;

    public static Vector2 WorldMousePosition => _currentMousePosition;

    //public static MouseCursorCode Cursor
    //{
    //
    //    set { }
    //}

    public static Vector2 GetVector(string negativeX, string positiveX, string negativeY, string positiveY, float deadzone = -1.0f)
    {
        float x = 0.0f;
        float y = 0.0f;

        if (_positiveXActions.TryGetValue(positiveX, out var posXKey) && IsKeyDown(posXKey)) x += 1.0f;
        if (_negativeXActions.TryGetValue(negativeX, out var negXKey) && IsKeyDown(negXKey)) x -= 1.0f;
        if (_positiveYActions.TryGetValue(positiveY, out var posYKey) && IsKeyDown(posYKey)) y += 1.0f;
        if (_negativeYActions.TryGetValue(negativeY, out var negYKey) && IsKeyDown(negYKey)) y -= 1.0f;

        var vector = new Vector2(x, y);

        if (deadzone < 0.0f)
        {
            return vector.LengthSquared() > 0 ? Vector2.Normalize(vector) : Vector2.Zero;
        }
        else
        {
            float length = vector.Length();
            if (length < deadzone)
            {
                return Vector2.Zero;
            }
            else
            {
                var normalized = vector / length;
                float mappedLength = (length - deadzone) / (1.0f - deadzone);
                return normalized * mappedLength;
            }
        }
    }

    public static void AddActionKey(string actionName, KeyCode key, bool isPositiveX = false, bool isNegativeX = false, bool isPositiveY = false, bool isNegativeY = false)
    {
        if (isPositiveX) _positiveXActions[actionName] = key;
        if (isNegativeX) _negativeXActions[actionName] = key;
        if (isPositiveY) _positiveYActions[actionName] = key;
        if (isNegativeY) _negativeYActions[actionName] = key;
    }

    public static void SetupDefaultActions()
    {
        AddActionKey("UiUp", KeyCode.UpArrow, isNegativeY: true);
        AddActionKey("UiUp", KeyCode.W, isNegativeY: true);
        AddActionKey("UiDown", KeyCode.DownArrow, isPositiveY: true);
        AddActionKey("UiDown", KeyCode.S, isPositiveY: true);
        AddActionKey("UiLeft", KeyCode.LeftArrow, isNegativeX: true);
        AddActionKey("UiLeft", KeyCode.A, isNegativeX: true);
        AddActionKey("UiRight", KeyCode.RightArrow, isPositiveX: true);
        AddActionKey("UiRight", KeyCode.D, isPositiveX: true);
        AddActionKey("UiAccept", KeyCode.Enter, isPositiveX: true);
        AddActionKey("UiAccept", KeyCode.Space, isPositiveX: true);
        AddActionKey("UiCancel", KeyCode.Escape, isPositiveX: true);
    }
}
</file>

<file path="Source\KeyCode.cs">
// file: KeyCode.cs
// Minimal KeyCode enum based on common Win32 VK codes needed
// Reference: https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
namespace Cherris;

public enum KeyCode
{
    Unknown = 0,

    Space = 0x20,
    Apostrophe = 222,
    Comma = 188,
    Minus = 189,
    Period = 190,
    Slash = 191,
    Alpha0 = 48,
    Alpha1 = 49,
    Alpha2 = 50,
    Alpha3 = 51,
    Alpha4 = 52,
    Alpha5 = 53,
    Alpha6 = 54,
    Alpha7 = 55,
    Alpha8 = 56,
    Alpha9 = 57,
    Semicolon = 186,
    Equal = 187,
    A = 65,
    B = 66,
    C = 67,
    D = 68,
    E = 69,
    F = 70,
    G = 71,
    H = 72,
    I = 73,
    J = 74,
    K = 75,
    L = 76,
    M = 77,
    N = 78,
    O = 79,
    P = 80,
    Q = 81,
    R = 82,
    S = 83,
    T = 84,
    U = 85,
    V = 86,
    W = 87,
    X = 88,
    Y = 89,
    Z = 90,
    LeftBracket = 219,
    Backslash = 220,
    RightBracket = 221,
    GraveAccent = 192,

    Escape = 0x1B,
    Enter = 0x0D,        // VK_RETURN
    Tab = 0x09,         // VK_TAB
    Backspace = 0x08,   // VK_BACK
    Insert = 0x2D,      // VK_INSERT
    Delete = 0x2E,      // VK_DELETE
    RightArrow = 0x27,    // VK_RIGHT
    LeftArrow = 0x25,     // VK_LEFT
    DownArrow = 0x28,     // VK_DOWN
    UpArrow = 0x26,       // VK_UP
    PageUp = 0x21,      // VK_PRIOR
    PageDown = 0x22,    // VK_NEXT
    Home = 0x24,        // VK_HOME
    End = 0x23,         // VK_END
    CapsLock = 0x14,    // VK_CAPITAL
    ScrollLock = 0x91,  // VK_SCROLL
    NumLock = 0x90,     // VK_NUMLOCK
    PrintScreen = 0x2C, // VK_SNAPSHOT
    Pause = 0x13,       // VK_PAUSE
    F1 = 0x70,          // VK_F1
    F2 = 0x71,
    F3 = 0x72,
    F4 = 0x73,
    F5 = 0x74,
    F6 = 0x75,
    F7 = 0x76,
    F8 = 0x77,
    F9 = 0x78,
    F10 = 0x79,
    F11 = 0x7A,
    F12 = 0x7B,
    Numpad0 = 0x60,     // VK_NUMPAD0
    Numpad1 = 0x61,
    Numpad2 = 0x62,
    Numpad3 = 0x63,
    Numpad4 = 0x64,
    Numpad5 = 0x65,
    Numpad6 = 0x66,
    Numpad7 = 0x67,
    Numpad8 = 0x68,
    Numpad9 = 0x69,
    NumpadDecimal = 0x6E,// VK_DECIMAL
    NumpadDivide = 0x6F, // VK_DIVIDE
    NumpadMultiply = 0x6A,// VK_MULTIPLY
    NumpadSubtract = 0x6D,// VK_SUBTRACT
    NumpadAdd = 0x6B,    // VK_ADD
    NumpadEnter = 0x6C,  // VK_SEPARATOR (Often Numpad Enter)
    LeftShift = 0xA0,   // VK_LSHIFT
    LeftControl = 0xA2, // VK_LCONTROL
    LeftAlt = 0xA4,     // VK_LMENU
    LeftSuper = 0x5B,   // VK_LWIN
    RightShift = 0xA1,  // VK_RSHIFT
    RightControl = 0xA3,// VK_RCONTROL
    RightAlt = 0xA5,    // VK_RMENU
    RightSuper = 0x5C,  // VK_RWIN
    Menu = 0x5D         // VK_APPS
}
</file>

<file path="Source\Log.cs">
namespace Cherris;

using System;
using System.IO;
using System.Runtime.CompilerServices;

public class Log
{
    private readonly static string LogFilePath = "Res/Log.txt";
    private readonly static ConsoleColor infoColor = ConsoleColor.DarkGray;
    private readonly static ConsoleColor warningColor = ConsoleColor.Yellow;
    private readonly static ConsoleColor errorColor = ConsoleColor.Red;

    public static void Info(string message, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        string fullMessage = $"[{DateTime.Now:HH:mm:ss}] [INFO] [{Path.GetFileName(filePath)}:{lineNumber}] {message}";
        Console.ForegroundColor = infoColor;
        Console.WriteLine(fullMessage);
        Console.ResetColor();
        File.AppendAllText(LogFilePath, Environment.NewLine + fullMessage);
    }

    public static void Info(string message, bool condition, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        if (!condition)
        {
            return;
        }

        Console.ForegroundColor = infoColor;
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] [INFO] [{Path.GetFileName(filePath)}:{lineNumber}] {message}");
        Console.ResetColor();
    }

    public static void Warning(string message, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        string fullMessage = $"[{DateTime.Now:HH:mm:ss}] [WARNING] [{Path.GetFileName(filePath)}:{lineNumber}] {message}";
        Console.ForegroundColor = warningColor;
        Console.WriteLine(fullMessage);
        Console.ResetColor();
        File.AppendAllText(LogFilePath, Environment.NewLine + fullMessage);
    }

    public static void Warning(string message, bool condition, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        if (!condition)
        {
            return;
        }

        Console.ForegroundColor = warningColor;
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] [WARNING] [{Path.GetFileName(filePath)}:{lineNumber}] {message}");
        Console.ResetColor();
    }

    public static void Error(string message, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        string fullMessage = $"[{DateTime.Now:HH:mm:ss}] [ERROR] - {Path.GetFileName(filePath)}:{lineNumber} - {message}";
        Console.ForegroundColor = errorColor;
        Console.WriteLine(fullMessage);
        Console.ResetColor();
        File.AppendAllText(LogFilePath, Environment.NewLine + fullMessage);
    }

    public static void Error(string message, bool condition, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        if (!condition)
        {
            return;
        }

        Console.ForegroundColor = errorColor;
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] [ERROR] - [{Path.GetFileName(filePath)}:{lineNumber}] - {message}");
        Console.ResetColor();
    }
}
</file>

<file path="Source\MainAppWindow.cs">
namespace Cherris;

public class MainAppWindow : Direct2DAppWindow
{
    public event Action? Closed;
    private bool _firstDrawLogged = false;
    private Vector2 _mainCurrentMousePosition = Vector2.Zero;

    public MainAppWindow(string title = "My DirectUI App", int width = 800, int height = 600)
        : base(title, width, height)
    {
        Input.SetupDefaultActions();
    }

    public Vector2 GetLocalMousePosition() => _mainCurrentMousePosition;

    protected override void DrawUIContent(DrawingContext context)
    {
        if (!_firstDrawLogged)
        {
            Log.Info($"MainAppWindow.DrawUIContent called for '{Title}'. Rendering SceneTree.");
            _firstDrawLogged = true;
        }

        SceneTree.Instance.RenderScene(context);
    }

    protected override bool OnClose()
    {
        Log.Info("MainAppWindow OnClose called.");
        Closed?.Invoke();
        return base.OnClose();
    }

    protected override void Cleanup()
    {
        Log.Info("MainAppWindow Cleanup starting.");
        base.Cleanup();
        Log.Info("MainAppWindow Cleanup finished.");
    }

    protected override IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        // Note: xPos, yPos, mousePos are now fetched inside specific message cases if needed,
        // or handled by the base class after _mainCurrentMousePosition is set.

        switch (msg)
        {
            case NativeMethods.WM_MOUSEMOVE:
                int x = NativeMethods.GET_X_LPARAM(lParam);
                int y = NativeMethods.GET_Y_LPARAM(lParam);
                _mainCurrentMousePosition = new Vector2(x, y);
                Input.UpdateMousePosition(_mainCurrentMousePosition); // Update global input state
                // Allow base.HandleMessage to call OnMouseMove and other logic
                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_LBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Left, true);
                return IntPtr.Zero; // Typically, framework handles focus; if specific behavior needed, adjust.
            case NativeMethods.WM_LBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Left, false);
                return IntPtr.Zero;

            case NativeMethods.WM_RBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Right, true);
                return IntPtr.Zero;
            case NativeMethods.WM_RBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Right, false);
                return IntPtr.Zero;

            case NativeMethods.WM_MBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Middle, true);
                return IntPtr.Zero;
            case NativeMethods.WM_MBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Middle, false);
                return IntPtr.Zero;

            case NativeMethods.WM_XBUTTONDOWN:
                int xButton1 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton1 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, true);
                if (xButton1 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, true);
                return IntPtr.Zero;
            case NativeMethods.WM_XBUTTONUP:
                int xButton2 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton2 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, false);
                if (xButton2 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, false);
                return IntPtr.Zero;

            case NativeMethods.WM_MOUSEWHEEL:
                short wheelDelta = NativeMethods.GET_WHEEL_DELTA_WPARAM(wParam);
                Input.UpdateMouseWheel((float)wheelDelta / NativeMethods.WHEEL_DELTA);
                return IntPtr.Zero;

            case NativeMethods.WM_KEYDOWN:
            case NativeMethods.WM_SYSKEYDOWN:
                int vkCodeDown = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeDown))
                {
                    Input.UpdateKey((KeyCode)vkCodeDown, true);
                }
                // Allow base.HandleMessage for default key processing (e.g., Escape key for close)
                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_KEYUP:
            case NativeMethods.WM_SYSKEYUP:
                int vkCodeUp = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeUp))
                {
                    Input.UpdateKey((KeyCode)vkCodeUp, false);
                }
                return IntPtr.Zero; // Often, KeyUp doesn't need further default processing if KeyDown handled it
        }

        return base.HandleMessage(hWnd, msg, wParam, lParam);
    }
}
</file>

<file path="Source\ModalSecondaryWindow.cs">
namespace Cherris;

public class ModalSecondaryWindow : SecondaryWindow
{
    private readonly IntPtr ownerHwnd;

    public ModalSecondaryWindow(string title, int width, int height, WindowNode ownerNode, IntPtr ownerHandle)
        : base(title, width, height, ownerNode)
    {
        ownerHwnd = ownerHandle;
    }


    public override bool TryCreateWindow(IntPtr ownerHwndOverride = default, uint? styleOverride = null)
    {

        uint defaultModalStyle = NativeMethods.WS_POPUP
                               | NativeMethods.WS_CAPTION
                               | NativeMethods.WS_SYSMENU
                               | NativeMethods.WS_VISIBLE
                               | NativeMethods.WS_THICKFRAME;


        return base.TryCreateWindow(ownerHwnd, styleOverride ?? defaultModalStyle);
    }

    public override void ShowWindow()
    {

        if (ownerHwnd != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(ownerHwnd, false);
        }
        base.ShowWindow();
    }

    protected override void OnDestroy()
    {

        if (ownerHwnd != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(ownerHwnd, true);
        }
        base.OnDestroy();
    }


    protected override bool OnClose()
    {
        Log.Info($"ModalSecondaryWindow '{Title}' OnClose called.");

        if (ownerHwnd != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(ownerHwnd, true);
        }


        return base.OnClose();
    }
}
</file>

<file path="Source\ModalWindowNode.cs">
namespace Cherris;

public class ModalWindowNode : WindowNode
{
    private ModalSecondaryWindow? modalWindow;

    public override void Make()
    {
        InitializeModalWindow();
    }

    private void InitializeModalWindow()
    {
        if (modalWindow is not null)
        {
            Log.Warning($"ModalWindowNode '{Name}' already has an associated window. Skipping creation.");
            return;
        }

        var ownerHandle = ApplicationServer.Instance.GetMainWindowHandle();
        if (ownerHandle == IntPtr.Zero)
        {
            Log.Error($"ModalWindowNode '{Name}' could not get the main window handle. Cannot create modal window.");
            return;
        }

        try
        {
            modalWindow = new ModalSecondaryWindow(Title, Width, Height, this, ownerHandle);
            this.secondaryWindow = modalWindow;

            if (!modalWindow.TryCreateWindow())
            {
                Log.Error($"ModalWindowNode '{Name}' failed to create its modal window.");
                modalWindow = null;
                this.secondaryWindow = null;
                return;
            }

            modalWindow.BackdropType = this.BackdropType;

            if (!modalWindow.InitializeWindowAndGraphics())
            {
                Log.Error($"ModalWindowNode '{Name}' failed to initialize modal window graphics.");
                modalWindow.Dispose();
                modalWindow = null;
                this.secondaryWindow = null;
                return;
            }

            modalWindow.ShowWindow();
            Log.Info($"ModalWindowNode '{Name}' successfully created and initialized its modal window.");
        }
        catch (Exception ex)
        {
            Log.Error($"Error during ModalWindowNode '{Name}' initialization: {ex.Message}");
            modalWindow?.Dispose();
            modalWindow = null;
            this.secondaryWindow = null;
        }
    }

    protected override void FreeInternal()
    {
        Log.Info($"Freeing ModalWindowNode '{Name}' and its associated modal window.");

        modalWindow?.Close();
        modalWindow = null;

        this.secondaryWindow = null;

        base.FreeInternal();
    }

    public override void Process()
    {
        if (this.isQueuedForFree)
        {
            this.FreeInternal();
        }
        else
        {
            base.Process();
        }
    }
}
</file>

<file path="Source\MouseButtonCode.cs">
namespace Cherris;

public enum MouseButtonCode
{
    Left = 0,
    Right = 1,
    Middle = 2, // Added Middle for completeness if needed
    Side = 3,   // Often corresponds to XButton1
    Extra = 4,  // Often corresponds to XButton2
    Forward = 5,
    Back = 6
}
</file>

<file path="Source\NativeMethods.cs">
using System.Runtime.InteropServices;

namespace Cherris;

public static class NativeMethods
{
    public const uint CS_HREDRAW = 0x0002;
    public const uint CS_VREDRAW = 0x0001;
    public const uint CS_OWNDC = 0x0020;

    public const uint WS_OVERLAPPED = 0x00000000;
    public const uint WS_CAPTION = 0x00C00000;
    public const uint WS_SYSMENU = 0x00080000;
    public const uint WS_THICKFRAME = 0x00040000;
    public const uint WS_MINIMIZEBOX = 0x00020000;
    public const uint WS_MAXIMIZEBOX = 0x00010000;
    public const uint WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    public const uint WS_VISIBLE = 0x10000000;
    public const uint WS_POPUP = 0x80000000;
    public const uint WS_BORDER = 0x00800000;
    public const uint WS_DLGFRAME = 0x00400000;

    public const int WM_NCCREATE = 0x0081;
    public const int WM_CREATE = 0x0001;
    public const int WM_NCDESTROY = 0x0082;
    public const int WM_PAINT = 0x000F;
    public const int WM_DESTROY = 0x0002;
    public const int WM_SIZE = 0x0005;
    public const int WM_CLOSE = 0x0010;
    public const int WM_KEYDOWN = 0x0100;
    public const int WM_KEYUP = 0x0101;
    public const int WM_SYSKEYDOWN = 0x0104;
    public const int WM_SYSKEYUP = 0x0105;
    public const int WM_LBUTTONDOWN = 0x0201;
    public const int WM_LBUTTONUP = 0x0202;
    public const int WM_RBUTTONDOWN = 0x0204;
    public const int WM_RBUTTONUP = 0x0205;
    public const int WM_MBUTTONDOWN = 0x0207;
    public const int WM_MBUTTONUP = 0x0208;
    public const int WM_XBUTTONDOWN = 0x020B;
    public const int WM_XBUTTONUP = 0x020C;
    public const int WM_MOUSEMOVE = 0x0200;
    public const int WM_MOUSEWHEEL = 0x020A;
    public const int WM_QUIT = 0x0012;
    public const int WM_PARENTNOTIFY = 0x0210;
    public const int WM_ENTERIDLE = 0x0121;
    public const int WM_DWMCOMPOSITIONCHANGED = 0x031E;

    public const int CW_USEDEFAULT = unchecked((int)0x80000000);
    public const int SW_SHOWNORMAL = 1;
    public const int VK_ESCAPE = 0x1B;
    public const int GWLP_USERDATA = -21;
    public const int GCLP_HBRBACKGROUND = -10;
    public const int GWL_STYLE = -16;

    public const int IDI_APPLICATION = 32512;
    public const int IDC_ARROW = 32512;

    public const int WHEEL_DELTA = 120;
    public const int XBUTTON1 = 0x0001;
    public const int XBUTTON2 = 0x0002;

    public const uint PM_REMOVE = 0x0001;

    public enum DWMWINDOWATTRIBUTE
    {
        DWMWA_USE_IMMERSIVE_DARK_MODE = 20,
        DWMWA_SYSTEMBACKDROP_TYPE = 38,
        DWMWA_MICA_EFFECT = 1029
    }

    public enum DWMSBT
    {
        DWMSBT_AUTO = 0,
        DWMSBT_NONE = 1,
        DWMSBT_MAINWINDOW = 2,
        DWMSBT_TRANSIENTWINDOW = 3,
        DWMSBT_TABBEDWINDOW = 4
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct WNDCLASSEX
    {
        public int cbSize;
        public uint style;
        public WndProc lpfnWndProc;
        public int cbClsExtra;
        public int cbWndExtra;
        public IntPtr hInstance;
        public IntPtr hIcon;
        public IntPtr hCursor;
        public IntPtr hbrBackground;
        [MarshalAs(UnmanagedType.LPTStr)]
        public string lpszMenuName;
        [MarshalAs(UnmanagedType.LPTStr)]
        public string lpszClassName;
        public IntPtr hIconSm;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    {
        public IntPtr hwnd;
        public uint message;
        public IntPtr wParam;
        public IntPtr lParam;
        public uint time;
        public POINT pt;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    {
        public int X;
        public int Y;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    {
        public int left;
        public int top;
        public int right;
        public int bottom;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct CREATESTRUCT
    {
        public IntPtr lpCreateParams;
        public IntPtr hInstance;
        public IntPtr hMenu;
        public IntPtr hwndParent;
        public int cy;
        public int cx;
        public int y;
        public int x;
        public int style;
        public string lpszName;
        public string lpszClass;
        public uint dwExStyle;
    }

    public delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern ushort RegisterClassEx([In] ref WNDCLASSEX lpwcx);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern IntPtr CreateWindowEx(
       uint dwExStyle,
       string lpClassName,
       string lpWindowName,
       uint dwStyle,
       int x,
       int y,
       int nWidth,
       int nHeight,
       IntPtr hWndParent,
       IntPtr hMenu,
       IntPtr hInstance,
       IntPtr lpParam);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool UpdateWindow(IntPtr hWnd);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool DestroyWindow(IntPtr hWnd);

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll")]
    public static extern void PostQuitMessage(int nExitCode);

    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool GetMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);

    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool PeekMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);

    [DllImport("user32.dll")]
    public static extern bool TranslateMessage([In] ref MSG lpMsg);

    [DllImport("user32.dll")]
    public static extern IntPtr DispatchMessage([In] ref MSG lpmsg);

    [DllImport("user32.dll")]
    public static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);

    [DllImport("user32.dll")]
    public static extern bool ValidateRect(IntPtr hWnd, IntPtr lpRect);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool InvalidateRect(IntPtr hWnd, IntPtr lpRect, bool bErase);

    [DllImport("user32.dll")]
    public static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);

    [DllImport("user32.dll")]
    public static extern IntPtr LoadIcon(IntPtr hInstance, IntPtr lpIconName);

    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool EnableWindow(IntPtr hWnd, bool bEnable);

    [DllImport("user32.dll")]
    public static extern IntPtr GetParent(IntPtr hWnd);

    // Corrected signature: Takes ref int for enum/bool attributes
    [DllImport("dwmapi.dll", SetLastError = true)]
    public static extern int DwmSetWindowAttribute(IntPtr hwnd, DWMWINDOWATTRIBUTE dwAttribute, ref int pvAttribute, int cbAttribute);

    // Removed the incorrect overload taking ref DWMSBT
    // [DllImport("dwmapi.dll", SetLastError = true)]
    // public static extern int DwmSetWindowAttribute(IntPtr hwnd, DWMWINDOWATTRIBUTE dwAttribute, ref DWMSBT pvAttribute, int cbAttribute);

    [DllImport("user32.dll", EntryPoint = "SetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr SetWindowLongPtr64(IntPtr hWnd, int nIndex, IntPtr dwNewLong);

    [DllImport("user32.dll", EntryPoint = "SetWindowLongW", SetLastError = true)]
    private static extern IntPtr SetWindowLong32(IntPtr hWnd, int nIndex, IntPtr dwNewLong);

    [DllImport("user32.dll", EntryPoint = "GetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr GetWindowLongPtr64(IntPtr hWnd, int nIndex);

    [DllImport("user32.dll", EntryPoint = "GetWindowLongW", SetLastError = true)]
    private static extern IntPtr GetWindowLong32(IntPtr hWnd, int nIndex);

    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong)
    {
        if (IntPtr.Size == 8)
            return SetWindowLongPtr64(hWnd, nIndex, dwNewLong);
        else
            return SetWindowLong32(hWnd, nIndex, dwNewLong);
    }

    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex)
    {
        if (IntPtr.Size == 8)
            return GetWindowLongPtr64(hWnd, nIndex);
        else
            return GetWindowLong32(hWnd, nIndex);
    }

    public static int GET_X_LPARAM(IntPtr lParam) => LOWORD(lParam);
    public static int GET_Y_LPARAM(IntPtr lParam) => HIWORD(lParam);
    public static short GET_WHEEL_DELTA_WPARAM(IntPtr wParam) => HIWORD(wParam);
    public static short GET_XBUTTON_WPARAM(IntPtr wParam) => HIWORD(wParam);

    public static int LOWORD(IntPtr ptr) => unchecked((short)(long)ptr);
    public static short HIWORD(IntPtr ptr) => unchecked((short)((long)ptr >> 16));
}
</file>

<file path="Source\Node.cs">
using Spectre.Console;

namespace Cherris;

public class Node
{
    public enum ProcessMode
    {
        Inherit,
        Pausable,
        WhenPaused,
        Disabled,
        Always
    }

    public static Node RootNode => SceneTree.Instance.RootNode!;
    public static SceneTree Tree => SceneTree.Instance;

    public string Name { get; set; } = "";
    public Node? Parent { get; set; } = null;
    public List<Node> Children { get; set; } = [];
    public ProcessMode ProcessingMode = ProcessMode.Inherit;

    private bool fieldActive = true;

    public bool Active
    {
        get => fieldActive;

        set
        {
            if (fieldActive == value)
            {
                return;
            }

            fieldActive = value;
            ActiveChanged?.Invoke(this, fieldActive);
        }
    }

    public string AbsolutePath
    {
        get
        {
            if (Parent is null)
            {

                return "/root/";
            }

            Stack<string> pathStack = new();
            Node? current = this;


            while (current is not null && current.Parent is not null)
            {

                pathStack.Push(current.Name);
                current = current.Parent;
            }


            return $"/root/{string.Join("/", pathStack)}";
        }
    }


    public delegate void ActiveEvent(Node sender, bool active);
    public delegate void ChildEvent(Node sender, Node child);
    public event ActiveEvent? ActiveChanged;
    public event ChildEvent? ChildAdded;


    public virtual void Make() { }

    public virtual void Start() { }

    public virtual void Ready() { }

    public virtual void Free()
    {
        List<Node> childrenToDestroy = new(Children);

        foreach (Node child in childrenToDestroy)
        {
            child.Free();
        }

        Parent?.Children.Remove(this);
    }


    public virtual void ProcessBegin() { }

    public virtual void Process() { }

    public virtual void ProcessEnd() { }


    public void PrintChildren()
    {
        Console.OutputEncoding = System.Text.Encoding.UTF8;

        string rootEmoji = NodeEmoji.GetEmojiForNodeType(this);
        Tree root = new($"{rootEmoji} [green]{Name}[/]");

        AddChildrenToTree(this, root);

        AnsiConsole.Write(root);
    }

    private static void AddChildrenToTree(Node node, IHasTreeNodes parentNode)
    {
        foreach (Node child in node.Children)
        {
            string childEmoji = NodeEmoji.GetEmojiForNodeType(child);
            TreeNode childNode = parentNode.AddNode($"{childEmoji} [blue]{child.Name}[/]");
            AddChildrenToTree(child, childNode);
        }
    }


    public virtual void Activate()
    {
        Active = true;

        foreach (Node child in Children)
        {
            child.Activate();
        }
    }

    public virtual void Deactivate()
    {
        Active = false;

        foreach (Node child in Children)
        {
            child.Deactivate();
        }
    }


    public T GetParent<T>() where T : Node
    {
        if (Parent is not null)
        {
            return (T)Parent;
        }

        return (T)this;
    }

    public T GetNode<T>(string path) where T : Node
    {
        if (string.IsNullOrEmpty(path))
        {
            throw new ArgumentException("Path cannot be null or empty.", nameof(path));
        }

        Node? currentNode;

        if (path.StartsWith("/root"))
        {
            path = path["/root".Length..];
            currentNode = SceneTree.Instance.RootNode;

            if (path.StartsWith('/'))
            {
                path = path.Substring(1);
            }

            if (!string.IsNullOrEmpty(path))
            {
                string[] nodeNames = path.Split('/');
                foreach (var name in nodeNames)
                {
                    if (name == "..")
                    {

                        currentNode = currentNode?.Parent;
                    }
                    else
                    {
                        currentNode = currentNode?.GetChild(name);
                    }

                    if (currentNode == null)
                    {
                        throw new InvalidOperationException($"Node '{name}' not found in the scene tree.");
                    }
                }
            }
        }
        else
        {
            currentNode = this;
            string[] nodeNames = path.Split('/');
            foreach (var name in nodeNames)
            {
                if (name == "..")
                {

                    currentNode = currentNode?.Parent;
                }
                else if (name != "")
                {
                    currentNode = currentNode?.GetChild(name);
                }

                if (currentNode == null)
                {
                    throw new InvalidOperationException($"Node '{name}' not found in the scene tree.");
                }
            }
        }

        return currentNode as T ?? throw new InvalidOperationException("Node is not of the expected type.");
    }

    public T? GetNodeOrNull<T>(string path) where T : Node
    {
        if (string.IsNullOrEmpty(path))
        {
            return null;
        }

        Node? currentNode;

        if (path.StartsWith("/root"))
        {
            path = path.Substring("/root".Length);
            currentNode = SceneTree.Instance.RootNode;

            if (path.StartsWith("/"))
            {
                path = path.Substring(1);
            }

            if (!string.IsNullOrEmpty(path))
            {
                string[] nodeNames = path.Split('/');
                foreach (var name in nodeNames)
                {
                    if (name == "..")
                    {

                        currentNode = currentNode?.Parent;
                    }
                    else
                    {
                        currentNode = currentNode?.GetChildOrNull(name);
                    }

                    if (currentNode == null)
                    {
                        return null;
                    }
                }
            }
        }
        else
        {
            currentNode = this;
            string[] nodeNames = path.Split('/');
            foreach (var name in nodeNames)
            {
                if (name == "..")
                {

                    currentNode = currentNode?.Parent;
                }
                else if (name != "")
                {
                    currentNode = currentNode?.GetChildOrNull(name);
                }

                if (currentNode == null)
                {
                    return null;
                }
            }
        }

        return currentNode as T;
    }


    public T? GetChild<T>(string name) where T : Node
    {
        foreach (Node child in Children)
        {
            if (child.Name == name)
            {
                return (T)child;
            }
        }

        return null;
    }

    public T? GetChild<T>() where T : Node
    {
        foreach (Node child in Children)
        {
            if (child.GetType() == typeof(T))
            {
                return (T)child;
            }
        }

        return null;
    }

    public Node GetChild(string name)
    {
        foreach (Node child in Children)
        {
            if (child.Name == name)
            {
                return child;
            }
        }

        SceneTree.Instance.RootNode?.PrintChildren();

        throw new InvalidOperationException($"Child node with name '{name}' not found.");
    }

    public Node? GetChildOrNull(string name)
    {
        foreach (Node child in Children)
        {
            if (child.Name == name)
            {
                return child;
            }
        }

        return null;
    }


    public Node AddChild(Node node)
    {
        node.Parent = this;

        node.Make();

        Children.Add(node);
        ChildAdded?.Invoke(this, node);

        return node;
    }

    public Node AddChild(Node node, string name)
    {
        node.Parent = this;
        node.Name = name;

        node.Make();

        Children.Add(node);
        ChildAdded?.Invoke(this, node);

        return node;
    }

    public WindowNode? GetOwningWindowNode()
    {
        Node? current = this;
        while (current != null)
        {
            if (current is WindowNode windowNode)
            {
                return windowNode;
            }
            current = current.Parent;
        }
        return null;
    }

    public Win32Window? GetOwningWindow()
    {
        Node? current = this;
        while (current != null)
        {
            if (current is WindowNode windowNode)
            {
                return windowNode.GetWindowHandle();
            }
            current = current.Parent;
        }
        return ApplicationServer.Instance.GetMainAppWindow();
    }

    public Vector2 GetWindowSizeV2()
    {
        var window = GetOwningWindow();
        if (window != null)
        {
            // Width and Height on Win32Window reflect the client area size updated by OnSize
            return new Vector2(window.Width, window.Height);
        }
        // Fallback default if no window context, e.g., during very early initialization
        return new Vector2(800, 600);
    }
}
</file>

<file path="Source\Node2D.cs">
namespace Cherris;

public enum AnchorPreset
{
    None,
    TopLeft, TopCenter, TopRight,
    CenterLeft, Center, CenterRight,
    BottomLeft, BottomCenter, BottomRight
}

public class Node2D : VisualItem
{
    public Vector2 Position { get; set; } = Vector2.Zero;
    public virtual float Rotation { get; set; } = 0;
    public OriginPreset OriginPreset { get; set; } = OriginPreset.Center;
    public bool InheritScale { get; set; } = true;
    public HAlignment HAlignment { get; set; } = HAlignment.Center;
    public VAlignment VAlignment { get; set; } = VAlignment.Center;
    public AnchorPreset AnchorPreset { get; set; } = AnchorPreset.None;

    public float MarginLeft { get; set; } = 0f;
    public float MarginTop { get; set; } = 0f;
    public float MarginRight { get; set; } = 0f;
    public float MarginBottom { get; set; } = 0f;

    public float RelativeWidth { get; set; } = 0f; // 0 to 1. If > 0, overrides explicit width.
    public float RelativeHeight { get; set; } = 0f; // 0 to 1. If > 0, overrides explicit height.

    public Vector2 ScaledSize => Size * Scale;

    // Backing field for explicit size, initialized with a default.
    // This value is set if "Size: [x, y]" is in YAML or node.Size = new Vec2(x,y) is called.
    private Vector2 _explicitSize = new(320, 320);

    public virtual Vector2 Size
    {
        get
        {
            Vector2 referenceSizeForRelative;

            if (Parent is Node2D parentNode2D)
            {
                referenceSizeForRelative = parentNode2D.Size; // Parent's calculated size
            }
            else
            {
                referenceSizeForRelative = GetWindowSizeV2(); // Window size if no Node2D parent
            }

            float finalWidth = _explicitSize.X;
            // If RelativeWidth is set (e.g. 0.5 for 50%), calculate width based on reference.
            if (RelativeWidth > 0f && RelativeWidth <= 1f)
            {
                finalWidth = referenceSizeForRelative.X * RelativeWidth;
            }

            float finalHeight = _explicitSize.Y;
            // If RelativeHeight is set, calculate height based on reference.
            if (RelativeHeight > 0f && RelativeHeight <= 1f)
            {
                finalHeight = referenceSizeForRelative.Y * RelativeHeight;
            }

            return new Vector2(finalWidth, finalHeight);
        }
        set // This setter updates the _explicitSize. Relative sizing remains active if configured.
        {
            if (_explicitSize != value)
            {
                _explicitSize = value;
                // Invoke SizeChanged with the new *calculated* size, as the explicit base has changed.
                SizeChanged?.Invoke(this, Size);
            }
        }
    }

    private Vector2 _scale = Vector2.One;
    public virtual Vector2 Scale
    {
        get
        {
            return InheritScale && Parent is Node2D node2DParent
                ? node2DParent.Scale
                : _scale;
        }
        set => _scale = value;
    }

    public virtual Vector2 GlobalPosition
    {
        get
        {
            Vector2 parentTopLeft;
            Vector2 parentSize;

            if (Parent is Node2D parentNode)
            {
                parentTopLeft = parentNode.GlobalPosition;
                parentSize = parentNode.Size;
            }
            else
            {
                parentTopLeft = Vector2.Zero;
                parentSize = GetWindowSizeV2();
            }

            float myCalculatedTopLeftX;
            float myCalculatedTopLeftY;

            if (AnchorPreset == AnchorPreset.None)
            {
                myCalculatedTopLeftX = parentTopLeft.X + Position.X;
                myCalculatedTopLeftY = parentTopLeft.Y + Position.Y;
            }
            else
            {
                switch (AnchorPreset)
                {
                    case AnchorPreset.TopLeft:
                    case AnchorPreset.CenterLeft:
                    case AnchorPreset.BottomLeft:
                        myCalculatedTopLeftX = parentTopLeft.X + MarginLeft;
                        break;
                    case AnchorPreset.TopCenter:
                    case AnchorPreset.Center:
                    case AnchorPreset.BottomCenter:
                        myCalculatedTopLeftX = parentTopLeft.X + (parentSize.X * 0.5f) - (Size.X * 0.5f) + MarginLeft;
                        break;
                    case AnchorPreset.TopRight:
                    case AnchorPreset.CenterRight:
                    case AnchorPreset.BottomRight:
                    default:
                        myCalculatedTopLeftX = parentTopLeft.X + parentSize.X - Size.X - MarginRight;
                        break;
                }

                switch (AnchorPreset)
                {
                    case AnchorPreset.TopLeft:
                    case AnchorPreset.TopCenter:
                    case AnchorPreset.TopRight:
                        myCalculatedTopLeftY = parentTopLeft.Y + MarginTop;
                        break;
                    case AnchorPreset.CenterLeft:
                    case AnchorPreset.Center:
                    case AnchorPreset.CenterRight:
                        myCalculatedTopLeftY = parentTopLeft.Y + (parentSize.Y * 0.5f) - (Size.Y * 0.5f) + MarginTop;
                        break;
                    case AnchorPreset.BottomLeft:
                    case AnchorPreset.BottomCenter:
                    case AnchorPreset.BottomRight:
                    default:
                        myCalculatedTopLeftY = parentTopLeft.Y + parentSize.Y - Size.Y - MarginBottom;
                        break;
                }
                myCalculatedTopLeftX += Position.X;
                myCalculatedTopLeftY += Position.Y;
            }

            return new Vector2(myCalculatedTopLeftX, myCalculatedTopLeftY);
        }
    }

    private Vector2 _offset = Vector2.Zero;
    public Vector2 Offset
    {
        get => _offset;
        set => _offset = value;
    }

    public Vector2 Origin
    {
        get
        {
            float x = HAlignment switch
            {
                HAlignment.Center => Size.X / 2f,
                HAlignment.Left => 0,
                HAlignment.Right => Size.X,
                _ => 0
            };

            float y = VAlignment switch
            {
                VAlignment.Top => 0,
                VAlignment.Center => Size.Y / 2f,
                VAlignment.Bottom => Size.Y,
                _ => 0
            };

            Vector2 alignmentOffset = new(x, y);
            return alignmentOffset + Offset;
        }
    }

    public event EventHandler<Vector2>? SizeChanged;

    public void LookAt(Vector2 targetPosition)
    {
        Vector2 originPoint = GlobalPosition + Origin;
        Vector2 direction = targetPosition - originPoint;
        var angle = float.Atan2(direction.Y, direction.X) * 57.29578f;
        Rotation = angle;
    }
}
</file>

<file path="Source\NodeEmoji.cs">
namespace Cherris;

public static class NodeEmoji
{
    public static string GetEmojiForNodeType(Node node)
    {
        return node switch
        {
            //ParticleEmitter => "✨",
            //Slider => "🎚️",
            //Label => "💬",
            //Camera => "🎥",
            //RayCast => "⚡",
            //Timer => "⏰",
            //NavigationRegion => "🗺",
            //NavigationAgent => "🧭",
            //AudioPlayer => "🔉",
            //Collider => "📦",
            //Sprite => "🖼",
            //Button => "🔘",
            //ColorRectangle => "🟥",
            //Node2D => "🟩",
            _ => "⭕",
        };
    }
}
</file>

<file path="Source\RenderServer.cs">
using Raylib_cs;

namespace Cherris;

public sealed class RenderServer
{
    private static RenderServer? _instance;
    public static RenderServer Instance => _instance ??= new();

    public Camera? Camera;
    public Shader? PostProcessingShader { get; set; }

    private readonly List<DrawCommand> drawCommands = [];
    private RenderTexture2D renderTexture;

    // Main

    private RenderServer()
    {
        var mainWin = ApplicationServer.Instance.GetMainAppWindow();
        Vector2 windowSize = mainWin != null ? new Vector2(mainWin.Width, mainWin.Height) : new Vector2(800, 600); // Default fallback
        renderTexture = Raylib.LoadRenderTexture((int)windowSize.X, (int)windowSize.Y);

        // DisplayServer.Instance.WindowSizeChanged -= WindowSizeChanged; // Event is removed from DisplayServer
        // The logic for resizing renderTexture needs a new mechanism if used with multiple/dynamic window sizes.
        // For now, it's initialized with main window size and won't resize automatically based on DisplayServer events.

        //PostProcessingShader = Shader.Load(null, "Res/Shaders/Bloom.fs");
    }

    // This method is no longer automatically called by DisplayServer event.
    // If renderTexture needs to resize, another mechanism is required.
    private void WindowSizeChanged(Vector2 newSize)
    {
        Raylib.UnloadRenderTexture(renderTexture); // Unload old texture
        renderTexture = Raylib.LoadRenderTexture(
            (int)newSize.X,
            (int)newSize.Y);
    }

    public void Process()
    {
        Raylib.BeginTextureMode(renderTexture);
        //Raylib.ClearBackground(Color.DarkGray);
        BeginCameraMode();
        ProcessDrawCommands();
        EndCameraMode();
        Raylib.EndTextureMode();

        BeginShaderMode(PostProcessingShader);
        //Rectangle source = new(0, 0, renderTexture.Texture.Width, -renderTexture.Texture.Height);
        //Raylib.DrawTextureRec(renderTexture.Texture, source, Vector2.Zero, Color.White);
        EndShaderMode();
    }

    public void Process2()
    {
        //Raylib.ClearBackground(Color.DarkGray);
        //BeginShaderMode(PostProcessingShader);
        //    BeginCameraMode();
        //        ProcessDrawCommands();
        //    EndCameraMode();
        //EndShaderMode();
    }

    public void Submit(Action drawAction, int layer)
    {
        drawCommands.Add(new(drawAction, layer));
    }

    public Vector2 GetScreenToWorld(Vector2 position)
    {
        return Camera is null
            ? position
            : Raylib.GetScreenToWorld2D(position, Camera);
    }

    public Vector2 GetWorldToScreen(Vector2 position)
    {
        return Camera is null
            ? position
            : Raylib.GetWorldToScreen2D(position, Camera);
    }

    // Scissor mode

    public static void BeginScissorMode(Vector2 position, Vector2 size)
    {
        Raylib.BeginScissorMode(
            (int)position.X,
            (int)position.Y,
            (int)size.X,
            (int)size.Y);
    }

    public static void EndScissorMode()
    {
        Raylib.EndScissorMode();
    }

    // Camera

    public void SetCamera(Camera camera)
    {
        Camera = camera;
    }

    private void BeginCameraMode()
    {
        if (Camera is null)
        {
            return;
        }

        // Use the Camera's owning window size for offset
        Vector2 windowSize = Camera.GetWindowSizeV2();

        Camera2D cam = new()
        {
            Target = Camera.GlobalPosition,
            Offset = windowSize / 2,
            Zoom = Camera.Zoom,
        };

        Raylib.BeginMode2D(cam);
    }

    private void EndCameraMode()
    {
        if (Camera is null)
        {
            return;
        }

        Raylib.EndMode2D();
    }

    // Shader mode

    public static void BeginShaderMode(Shader? shader)
    {
        if (shader is null)
        {
            return;
        }

        Raylib.BeginShaderMode(shader);
    }

    public static void EndShaderMode()
    {
        Raylib.EndShaderMode();
    }

    // Other

    private void ProcessDrawCommands()
    {
        foreach (DrawCommand command in drawCommands.OrderBy(c => c.Layer))
        {
            command.DrawAction.Invoke();
        }

        drawCommands.Clear();
    }

    private class DrawCommand(Action drawAction, int layer)
    {
        public Action DrawAction { get; } = drawAction;
        public int Layer { get; } = layer;
    }
}
</file>

<file path="Source\ResourceLoader.cs">
namespace Cherris;

public sealed class ResourceLoader
{
    public static T? Load<T>(string path)
    {
        return typeof(T) switch
        {
            var t when t == typeof(AudioStream) => (T)(object)AudioStreamCache.Instance.Get(path)!,
            var t when t == typeof(Texture) => (T)(object)TextureCache.Instance.Get(path),
            var t when t == typeof(Font) => (T)(object)FontCache.Instance.Get(path),
            var t when t == typeof(Sound) => (T)(object)SoundCache.Instance.Get(path),
            var t when t == typeof(Animation) => (T)(object)AnimationCache.Instance.Get(path),
            _ => throw new InvalidOperationException($"Unsupported resource type: {typeof(T)}")
        };
    }
}
</file>

<file path="Source\SecondaryWindow.cs">
namespace Cherris;

public class SecondaryWindow : Direct2DAppWindow
{
    private readonly WindowNode ownerNode;
    private Vector2 currentMousePosition = Vector2.Zero;

    public SecondaryWindow(string title, int width, int height, WindowNode owner)
        : base(title, width, height)
    {
        ownerNode = owner ?? throw new ArgumentNullException(nameof(owner));
        ApplicationServer.Instance.RegisterSecondaryWindow(this);
    }

    protected override void DrawUIContent(DrawingContext context)
    {
        ownerNode?.RenderChildren(context);
    }

    protected override bool OnClose()
    {
        Log.Info($"SecondaryWindow '{Title}' OnClose called.");
        ownerNode?.QueueFree();
        return base.OnClose();
    }

    protected override void Cleanup()
    {
        Log.Info($"SecondaryWindow '{Title}' Cleanup starting.");
        base.Cleanup();
        Log.Info($"SecondaryWindow '{Title}' Cleanup finished.");
    }

    protected override IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        int xPos = NativeMethods.GET_X_LPARAM(lParam);
        int yPos = NativeMethods.GET_Y_LPARAM(lParam);
        Vector2 mousePos = new Vector2(xPos, yPos);

        currentMousePosition = mousePos; // Update local mouse position for this window

        switch (msg)
        {
            case NativeMethods.WM_MOUSEMOVE:
                Input.UpdateMousePosition(currentMousePosition); // Update global Input state
                // Allow base.HandleMessage to call OnMouseMove and other logic
                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_LBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Left, true);
                break;
            case NativeMethods.WM_LBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Left, false);
                break;

            case NativeMethods.WM_RBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Right, true);
                break;
            case NativeMethods.WM_RBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Right, false);
                break;

            case NativeMethods.WM_MBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Middle, true);
                break;
            case NativeMethods.WM_MBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Middle, false);
                break;

            case NativeMethods.WM_XBUTTONDOWN:
                int xButton1 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton1 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, true);
                if (xButton1 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, true);
                break;
            case NativeMethods.WM_XBUTTONUP:
                int xButton2 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton2 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, false);
                if (xButton2 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, false);
                break;

            case NativeMethods.WM_MOUSEWHEEL:
                short wheelDelta = NativeMethods.GET_WHEEL_DELTA_WPARAM(wParam);
                Input.UpdateMouseWheel((float)wheelDelta / NativeMethods.WHEEL_DELTA);
                break;

            case NativeMethods.WM_KEYDOWN:
            case NativeMethods.WM_SYSKEYDOWN:
                int vkCodeDown = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeDown))
                {
                    Input.UpdateKey((KeyCode)vkCodeDown, true);
                }
                // Allow base.HandleMessage for default key processing
                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_KEYUP:
            case NativeMethods.WM_SYSKEYUP:
                int vkCodeUp = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeUp))
                {
                    Input.UpdateKey((KeyCode)vkCodeUp, false);
                }
                // KeyUp often doesn't need default processing if KeyDown handled it
                return IntPtr.Zero;
        }

        return base.HandleMessage(hWnd, msg, wParam, lParam);
    }

    public Vector2 GetLocalMousePosition() => currentMousePosition;
}
</file>

<file path="Source\SystemBackdropType.cs">
namespace Cherris;

public enum SystemBackdropType
{
    None,
    Mica,
    Acrylic,
    MicaAlt
}
</file>

<file path="Source\Time.cs">
namespace Cherris;

public class Time
{
    public static float Delta = 0.1f;
}
</file>

<file path="Source\Tween.cs">
using System.Reflection;

namespace Cherris;

public class Tween(Node creatorNode, Node.ProcessMode processMode = Node.ProcessMode.Inherit)
{
    public bool Active = true;

    private readonly List<TweenStep> steps = [];
    private readonly Node creatorNode = creatorNode;
    private readonly Node.ProcessMode processMode = processMode;

    private static readonly bool debug = false;

    public bool Stopped { get; private set; }

    public void Stop()
    {
        Stopped = true;
        Active = false;
    }

    public void TweenProperty(Node node, string propertyPath, float targetValue, float duration)
    {
        try
        {
            ArgumentNullException.ThrowIfNull(node);

            if (string.IsNullOrEmpty(propertyPath))
            {
                throw new ArgumentException("Property path cannot be null or empty.", nameof(propertyPath));
            }

            Log.Info($"[Tween] Starting tween on {node.Name} for {propertyPath}", debug);

            float startValue = GetFloatValue(node, propertyPath);

            Log.Info($"[Tween] Start value: {startValue} ➔ Target: {targetValue} ({duration}s)", debug);

            steps.Add(new TweenStep(node, propertyPath, startValue, targetValue, duration));
        }
        catch (Exception ex)
        {
            Log.Error($"[Tween] Error starting tween: {ex}");
            Active = false;
        }
    }

    public void Update(float delta)
    {
        if (!Active || Stopped)
        {
            return;
        }

        foreach (TweenStep step in steps.ToList())
        {
            step.Elapsed += delta;
            float t = Math.Clamp(step.Elapsed / step.Duration, 0, 1);
            float currentValue = step.StartValue + (step.EndValue - step.StartValue) * t;

            Log.Info($"[Tween] Updating {step.Node.Name}.{step.PropertyPath} {currentValue:0.00} ({t:P0})", debug);

            SetFloatValueDirect(step.Node, step.PropertyPath, currentValue);

            if (step.Elapsed >= step.Duration)
            {
                Log.Info($"[Tween] Completed {step.Node.Name}.{step.PropertyPath}", debug);
                steps.Remove(step);
            }
        }

        if (steps.Count == 0)
        {
            Log.Info("[Tween] All steps completed", debug);
            Active = false;
        }
    }

    public bool ShouldProcess(bool treePaused)
    {
        var effectiveMode = processMode == Node.ProcessMode.Inherit
            ? GetEffectiveProcessMode(creatorNode)
            : processMode;

        return effectiveMode switch
        {
            Node.ProcessMode.Disabled => false,
            Node.ProcessMode.Always => true,
            Node.ProcessMode.Pausable => !treePaused,
            Node.ProcessMode.WhenPaused => treePaused,
            _ => false
        };
    }

    private static Node.ProcessMode GetEffectiveProcessMode(Node node)
    {
        Node? current = node;

        while (current != null)
        {
            if (current.ProcessingMode != Node.ProcessMode.Inherit)
            {
                return current.ProcessingMode;
            }

            current = current.Parent;
        }

        return Node.ProcessMode.Pausable;
    }

    private static float GetFloatValue(Node node, string propertyPath)
    {
        object? current = node;

        foreach (string part in propertyPath.Split('/'))
        {
            if (current is null)
            {
                throw new InvalidOperationException(
                    $"Intermediate value is null in path '{propertyPath}' on node {node.Name}");
            }

            Type type = current.GetType();
            PropertyInfo? property = type.GetProperty(part);
            FieldInfo? field = type.GetField(part);

            MemberInfo? member = property ?? (MemberInfo?)field
                ?? throw new ArgumentException($"Property or field '{part}' not found in {type.Name}");

            current = member is PropertyInfo prop
                ? prop.GetValue(current)
                : ((FieldInfo)member).GetValue(current);
        }

        return current is not null
            ? (float)current
            : throw new InvalidOperationException($"Value for path '{propertyPath}' is null on node {node.Name}");
    }

    private static void SetFloatValueDirect(Node node, string propertyPath, float value)
    {
        string[] parts = propertyPath.Split('/');
        object? current = node;

        for (int i = 0; i < parts.Length - 1; i++)
        {
            if (current is null)
            {
                throw new InvalidOperationException(
                    $"Intermediate value is null in path '{propertyPath}' on node {node.Name}");
            }

            Type type = current.GetType();
            PropertyInfo? property = type.GetProperty(parts[i]);
            FieldInfo? field = type.GetField(parts[i]);

            MemberInfo? member = property ?? (MemberInfo?)field
                ?? throw new ArgumentException($"Property or field '{parts[i]}' not found in {type.Name}");

            current = member is PropertyInfo prop
                ? prop.GetValue(current)
                : ((FieldInfo)member).GetValue(current);
        }

        if (current is null)
        {
            throw new InvalidOperationException(
                $"Final target is null in path '{propertyPath}' on node {node.Name}");
        }

        Type finalType = current.GetType();
        string finalPart = parts[^1];
        PropertyInfo? finalProperty = finalType.GetProperty(finalPart);
        FieldInfo? finalField = finalType.GetField(finalPart);

        MemberInfo finalMember = finalProperty ?? (MemberInfo?)finalField
            ?? throw new ArgumentException($"Property or field '{finalPart}' not found in {finalType.Name}");

        if (finalMember is PropertyInfo targetProp)
        {
            targetProp.SetValue(current, value);
        }
        else if (finalMember is FieldInfo targetField)
        {
            targetField.SetValue(current, value);
        }
    }

    private record TweenStep(Node Node, string PropertyPath, float StartValue, float EndValue, float Duration)
    {
        public float Elapsed { get; set; }
    }
}
</file>

<file path="Source\VerticalAlignment.cs">
namespace Cherris;

public enum VAlignment
{
    Top,
    Center,
    Bottom,
    None
}
</file>

<file path="Source\VisualItem.cs">
using SharpGen.Runtime;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;

namespace Cherris;

public abstract class VisualItem : Node
{
    private bool fieldVisible = true;
    private int fieldLayer = 0;


    public bool Visible
    {
        get => fieldVisible;
        set
        {
            if (fieldVisible == value)
            {
                return;
            }

            fieldVisible = value;
            VisibleChanged?.Invoke(this, fieldVisible);
        }
    }

    public int Layer
    {
        get => fieldLayer;
        set
        {
            if (fieldLayer == value)
            {
                return;
            }

            fieldLayer = value;
            LayerChanged?.Invoke(this, fieldLayer);
        }
    }

    public delegate void VisibleEvent(VisualItem sender, bool visible);
    public delegate void LayerEvent(VisualItem sender, int layer);

    public event VisibleEvent? VisibleChanged;
    public event LayerEvent? LayerChanged;

    public virtual void Draw(DrawingContext context) { }


    protected void DrawStyledRectangle(DrawingContext context, Rect bounds, BoxStyle style)
    {
        if (context.OwnerWindow is null || context.RenderTarget is null || style is null || bounds.Width <= 0 || bounds.Height <= 0)
        {
            return;
        }

        try
        {
            DrawBoxStyleHelper(context, bounds, style);
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Warning("Recreate target detected in DrawStyledRectangle.");
        }
        catch (Exception ex)
        {
            Log.Error($"Error drawing styled rectangle: {ex.Message}");
        }
    }

    protected void DrawFormattedText(DrawingContext context, string text, Rect layoutRect, ButtonStyle style, HAlignment hAlignment, VAlignment vAlignment)
    {
        if (string.IsNullOrEmpty(text) || context.OwnerWindow is null || context.RenderTarget is null || style is null || layoutRect.Width <= 0 || layoutRect.Height <= 0)
        {
            return;
        }

        ID2D1SolidColorBrush? textBrush = context.OwnerWindow.GetOrCreateBrush(style.FontColor);
        IDWriteTextFormat? textFormat = context.OwnerWindow.GetOrCreateTextFormat(style);

        if (textBrush is null || textFormat is null)
        {

            return;
        }

        try
        {
            textFormat.TextAlignment = hAlignment switch
            {
                HAlignment.Left => DW.TextAlignment.Leading,
                HAlignment.Center => DW.TextAlignment.Center,
                HAlignment.Right => DW.TextAlignment.Trailing,
                _ => DW.TextAlignment.Leading
            };
            textFormat.ParagraphAlignment = vAlignment switch
            {
                VAlignment.Top => DW.ParagraphAlignment.Near,
                VAlignment.Center => DW.ParagraphAlignment.Center,
                VAlignment.Bottom => DW.ParagraphAlignment.Far,
                _ => DW.ParagraphAlignment.Near
            };

            context.RenderTarget.DrawText(
                text,
                textFormat,
                layoutRect,
                textBrush,
                D2D.DrawTextOptions.Clip
            );
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Warning("Recreate target detected in DrawFormattedText.");


        }
        catch (Exception ex)
        {
            Log.Error($"Error drawing formatted text '{text}': {ex.Message}");
        }
    }


    private static void DrawBoxStyleHelper(DrawingContext context, Rect bounds, BoxStyle style)
    {
        ID2D1HwndRenderTarget? renderTarget = context.RenderTarget;
        Direct2DAppWindow? ownerWindow = context.OwnerWindow;
        if (renderTarget is null || ownerWindow is null || style is null || bounds.Width <= 0 || bounds.Height <= 0)
        {
            return;
        }

        ID2D1SolidColorBrush? fillBrush = ownerWindow.GetOrCreateBrush(style.FillColor);
        ID2D1SolidColorBrush? borderBrush = ownerWindow.GetOrCreateBrush(style.BorderColor);

        float borderTop = Math.Max(0f, style.BorderLengthTop);
        float borderRight = Math.Max(0f, style.BorderLengthRight);
        float borderBottom = Math.Max(0f, style.BorderLengthBottom);
        float borderLeft = Math.Max(0f, style.BorderLengthLeft);

        bool hasVisibleFill = style.FillColor.A > 0 && fillBrush is not null;
        bool hasVisibleBorder = style.BorderColor.A > 0 && borderBrush is not null && (borderTop > 0 || borderRight > 0 || borderBottom > 0 || borderLeft > 0);

        if (!hasVisibleFill && !hasVisibleBorder) return;

        if (style.Roundness > 0.0f)
        {
            float maxRadius = Math.Min(bounds.Width * 0.5f, bounds.Height * 0.5f);
            float radius = Math.Max(0f, maxRadius * float.Clamp(style.Roundness, 0.0f, 1.0f));

            if (float.IsFinite(radius) && radius >= 0)
            {
                if (hasVisibleBorder && borderBrush is not null)
                {
                    System.Drawing.RectangleF outerRectF = new(bounds.X, bounds.Y, bounds.Width, bounds.Height);
                    RoundedRectangle outerRoundedRect = new(outerRectF, radius, radius);
                    renderTarget.FillRoundedRectangle(outerRoundedRect, borderBrush);
                }

                if (hasVisibleFill && fillBrush is not null)
                {
                    float fillX = bounds.X + borderLeft;
                    float fillY = bounds.Y + borderTop;
                    float fillWidth = Math.Max(0f, bounds.Width - borderLeft - borderRight);
                    float fillHeight = Math.Max(0f, bounds.Height - borderTop - borderBottom);

                    if (fillWidth > 0 && fillHeight > 0)
                    {
                        float avgBorderX = (borderLeft + borderRight) * 0.5f;
                        float avgBorderY = (borderTop + borderBottom) * 0.5f;
                        float innerRadiusX = Math.Max(0f, radius - avgBorderX);
                        float innerRadiusY = Math.Max(0f, radius - avgBorderY);

                        System.Drawing.RectangleF fillRectF = new(fillX, fillY, fillWidth, fillHeight);
                        RoundedRectangle fillRoundedRect = new(fillRectF, innerRadiusX, innerRadiusY);
                        renderTarget.FillRoundedRectangle(fillRoundedRect, fillBrush);
                    }
                    else if (!hasVisibleBorder)
                    {
                        System.Drawing.RectangleF outerRectF = new(bounds.X, bounds.Y, bounds.Width, bounds.Height);
                        RoundedRectangle outerRoundedRect = new(outerRectF, radius, radius);
                        renderTarget.FillRoundedRectangle(outerRoundedRect, fillBrush);
                    }
                }
                return;
            }
        }

        if (hasVisibleBorder && borderBrush is not null)
        {
            renderTarget.FillRectangle(bounds, borderBrush);
        }

        if (hasVisibleFill && fillBrush is not null)
        {
            float fillX = bounds.X + borderLeft;
            float fillY = bounds.Y + borderTop;
            float fillWidth = Math.Max(0f, bounds.Width - borderLeft - borderRight);
            float fillHeight = Math.Max(0f, bounds.Height - borderTop - borderBottom);

            if (fillWidth > 0 && fillHeight > 0)
            {
                renderTarget.FillRectangle(new Rect(fillX, fillY, fillWidth, fillHeight), fillBrush);
            }
            else if (!hasVisibleBorder)
            {

                renderTarget.FillRectangle(bounds, fillBrush);
            }
        }
    }
}
</file>

<file path="Source\Win32Window.cs">
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Cherris;

public abstract class Win32Window : IDisposable
{
    private readonly string _windowClassName;
    private readonly string _windowTitle;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private IntPtr _hwnd = IntPtr.Zero;
    private IntPtr _hInstance = IntPtr.Zero;
    private NativeMethods.WndProc _wndProcDelegate;
    private bool _isDisposed = false;
    private static readonly HashSet<string> RegisteredClassNames = new HashSet<string>();
    private GCHandle _gcHandle;

    public IntPtr Handle => _hwnd;
    public string Title => _windowTitle;
    public int Width { get; protected set; }
    public int Height { get; protected set; }
    public bool IsOpen { get; private set; } = false;
    public SystemBackdropType BackdropType { get; set; } = SystemBackdropType.None;
    public bool VSyncEnabled { get; set; } = true;

    protected Win32Window(string title, int width, int height, string className = null)
    {
        _windowTitle = title ?? "Win32 Window";
        _initialWidth = width > 0 ? width : 800;
        _initialHeight = height > 0 ? height : 600;
        Width = _initialWidth;
        Height = _initialHeight;
        _windowClassName = className ?? ("Win32Window_" + Guid.NewGuid().ToString("N"));
        _wndProcDelegate = WindowProcedure;
    }

    public virtual bool TryCreateWindow(IntPtr ownerHwnd = default, uint? styleOverride = null)
    {
        if (_hwnd != IntPtr.Zero)
        {
            Log.Warning("Window handle already exists. Creation skipped.");
            return true;
        }

        _hInstance = NativeMethods.GetModuleHandle(null);
        if (_hInstance == IntPtr.Zero)
        {
            _hInstance = Process.GetCurrentProcess().Handle;
        }

        lock (RegisteredClassNames)
        {
            if (!RegisteredClassNames.Contains(_windowClassName))
            {
                var wndClass = new NativeMethods.WNDCLASSEX
                {
                    cbSize = Marshal.SizeOf(typeof(NativeMethods.WNDCLASSEX)),
                    style = NativeMethods.CS_HREDRAW | NativeMethods.CS_VREDRAW | NativeMethods.CS_OWNDC,
                    lpfnWndProc = _wndProcDelegate,
                    cbClsExtra = 0,
                    cbWndExtra = 0,
                    hInstance = _hInstance,
                    hIcon = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)NativeMethods.IDI_APPLICATION),
                    hCursor = NativeMethods.LoadCursor(IntPtr.Zero, NativeMethods.IDC_ARROW),
                    hbrBackground = IntPtr.Zero,
                    lpszMenuName = null,
                    lpszClassName = _windowClassName,
                    hIconSm = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)NativeMethods.IDI_APPLICATION)
                };

                if (NativeMethods.RegisterClassEx(ref wndClass) == 0)
                {
                    Log.Error($"RegisterClassEx failed: {Marshal.GetLastWin32Error()}");
                    return false;
                }
                RegisteredClassNames.Add(_windowClassName);
                Log.Info($"Class '{_windowClassName}' registered.");
            }
        }

        _gcHandle = GCHandle.Alloc(this);

        uint windowStyle = styleOverride ?? NativeMethods.WS_OVERLAPPEDWINDOW;

        _hwnd = NativeMethods.CreateWindowEx(
            0,
            _windowClassName,
            _windowTitle,
            windowStyle,
            NativeMethods.CW_USEDEFAULT, NativeMethods.CW_USEDEFAULT,
            _initialWidth, _initialHeight,
            ownerHwnd,
            IntPtr.Zero,
            _hInstance,
            GCHandle.ToIntPtr(_gcHandle));

        if (_hwnd == IntPtr.Zero)
        {
            Log.Error($"CreateWindowEx failed: {Marshal.GetLastWin32Error()}");
            if (_gcHandle.IsAllocated) _gcHandle.Free();
            return false;
        }

        Log.Info($"Window '{_windowTitle}' created with HWND: {_hwnd}");
        IsOpen = true;

        return true;
    }

    protected virtual NativeMethods.DWMSBT GetSystemBackdropType()
    {
        return BackdropType switch
        {
            SystemBackdropType.Mica => NativeMethods.DWMSBT.DWMSBT_MAINWINDOW,
            SystemBackdropType.Acrylic => NativeMethods.DWMSBT.DWMSBT_TRANSIENTWINDOW,
            SystemBackdropType.MicaAlt => NativeMethods.DWMSBT.DWMSBT_TABBEDWINDOW,
            SystemBackdropType.None => NativeMethods.DWMSBT.DWMSBT_NONE,
            _ => NativeMethods.DWMSBT.DWMSBT_AUTO
        };
    }

    public void ApplySystemBackdrop()
    {
        if (_hwnd == IntPtr.Zero || !IsOpen) return;

        var backdropTypeEnum = GetSystemBackdropType();
        if (backdropTypeEnum == NativeMethods.DWMSBT.DWMSBT_NONE)
        {
            Log.Info($"Skipping backdrop application for '{Title}' (Type: None).");
            return;
        }

        var osVersion = Environment.OSVersion.Version;
        int requiredBuild = 22621;

        if (osVersion.Major < 10 || (osVersion.Major == 10 && osVersion.Build < requiredBuild))
        {
            Log.Warning($"System backdrop type {BackdropType} ({backdropTypeEnum}) requires Windows 11 Build {requiredBuild} or later. Current: {osVersion}");
            return;
        }

        try
        {
            int backdropTypeValue = (int)backdropTypeEnum;
            int result = NativeMethods.DwmSetWindowAttribute(
                _hwnd,
                NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_SYSTEMBACKDROP_TYPE,
                ref backdropTypeValue,
                sizeof(int));

            if (result != 0)
            {
                Log.Error($"DwmSetWindowAttribute failed for {NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_SYSTEMBACKDROP_TYPE} with HRESULT: 0x{result:X8} on HWND {_hwnd} ('{_windowTitle}').");
                return;
            }
            Log.Info($"Applied system backdrop type {BackdropType} ({backdropTypeEnum}) to HWND {_hwnd} ('{_windowTitle}').");

            int useDarkMode = 1;
            result = NativeMethods.DwmSetWindowAttribute(
                _hwnd,
                NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE,
                ref useDarkMode,
                sizeof(int));

            if (result != 0)
            {
                Log.Warning($"DwmSetWindowAttribute failed for {NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE} with HRESULT: 0x{result:X8} on HWND {_hwnd} ('{_windowTitle}'). This might be expected on some builds.");
            }
            else
            {
                Log.Info($"Applied {NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE}=TRUE to HWND {_hwnd} ('{_windowTitle}').");
            }
        }
        catch (Exception ex)
        {
            Log.Error($"Exception applying system backdrop/theme attributes to HWND {_hwnd} ('{_windowTitle}'): {ex.Message}");
        }
    }

    public virtual void ShowWindow()
    {
        if (_hwnd != IntPtr.Zero && IsOpen)
        {
            NativeMethods.ShowWindow(_hwnd, NativeMethods.SW_SHOWNORMAL);
            NativeMethods.UpdateWindow(_hwnd);
        }
        else
        {
            Log.Warning($"Cannot show window '{Title}': Handle is zero or window is not open.");
        }
    }

    public bool InitializeWindowAndGraphics()
    {
        if (_hwnd == IntPtr.Zero || !IsOpen)
        {
            Log.Error($"Cannot initialize '{Title}': Window handle is invalid or window is closed.");
            return false;
        }

        ApplySystemBackdrop();

        if (!Initialize())
        {
            Log.Error($"Custom initialization failed for '{Title}'.");
            return false;
        }

        return true;
    }

    private static IntPtr WindowProcedure(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        Win32Window? window = null;

        if (msg == NativeMethods.WM_NCCREATE)
        {
            try
            {
                var cs = Marshal.PtrToStructure<NativeMethods.CREATESTRUCT>(lParam);
                var handle = GCHandle.FromIntPtr(cs.lpCreateParams);
                window = handle.Target as Win32Window;
                if (window != null)
                {
                    NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, GCHandle.ToIntPtr(handle));
                }
                else
                {
                    Log.Warning($"WM_NCCREATE: Failed to get window instance from GCHandle for HWND {hWnd}");
                }
            }
            catch (Exception ex)
            {
                Log.Error($"Error during WM_NCCREATE: {ex}");
            }
        }
        else
        {
            IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);
            if (ptr != IntPtr.Zero)
            {
                try
                {
                    var handle = GCHandle.FromIntPtr(ptr);
                    if (handle.IsAllocated && handle.Target != null)
                    {
                        window = handle.Target as Win32Window;
                    }
                }
                catch (InvalidOperationException)
                {
                    NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero);
                }
                catch (Exception ex)
                {
                    Log.Error($"Error retrieving GCHandle: {ex}");
                }
            }
        }

        if (window != null)
        {
            try
            {
                return window.HandleMessage(hWnd, msg, wParam, lParam);
            }
            catch (Exception ex)
            {
                Log.Error($"Error handling message {msg} for HWND {hWnd} ('{window.Title}'): {ex}");
            }
        }

        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    protected virtual IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        int xPos = NativeMethods.GET_X_LPARAM(lParam);
        int yPos = NativeMethods.GET_Y_LPARAM(lParam);

        switch (msg)
        {
            case NativeMethods.WM_PAINT:
                RenderFrame();
                NativeMethods.ValidateRect(hWnd, IntPtr.Zero);
                return IntPtr.Zero;

            case NativeMethods.WM_SIZE:
                Width = NativeMethods.LOWORD(lParam);
                Height = NativeMethods.HIWORD(lParam);
                OnSize(Width, Height);
                return IntPtr.Zero;

            case NativeMethods.WM_MOUSEMOVE:
                OnMouseMove(xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_LBUTTONDOWN:
                OnMouseDown(MouseButton.Left, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_LBUTTONUP:
                OnMouseUp(MouseButton.Left, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_RBUTTONDOWN:
                OnMouseDown(MouseButton.Right, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_RBUTTONUP:
                OnMouseUp(MouseButton.Right, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_MBUTTONDOWN:
                OnMouseDown(MouseButton.Middle, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_MBUTTONUP:
                OnMouseUp(MouseButton.Middle, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_XBUTTONDOWN:
                int xButton1 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                OnMouseDown(xButton1 == NativeMethods.XBUTTON1 ? MouseButton.XButton1 : MouseButton.XButton2, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_XBUTTONUP:
                int xButton2 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                OnMouseUp(xButton2 == NativeMethods.XBUTTON1 ? MouseButton.XButton1 : MouseButton.XButton2, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_MOUSEWHEEL:
                short wheelDelta = NativeMethods.GET_WHEEL_DELTA_WPARAM(wParam);
                OnMouseWheel(wheelDelta);
                return IntPtr.Zero;

            case NativeMethods.WM_KEYDOWN:
            case NativeMethods.WM_SYSKEYDOWN:
                int vkCodeDown = (int)wParam;
                OnKeyDown(vkCodeDown);

                if (vkCodeDown == NativeMethods.VK_ESCAPE && !IsKeyDownHandled(vkCodeDown))
                {
                    Close();
                }
                return IntPtr.Zero;

            case NativeMethods.WM_KEYUP:
            case NativeMethods.WM_SYSKEYUP:
                int vkCodeUp = (int)wParam;
                OnKeyUp(vkCodeUp);
                return IntPtr.Zero;

            case NativeMethods.WM_DWMCOMPOSITIONCHANGED:
                Log.Info($"WM_DWMCOMPOSITIONCHANGED received for {hWnd} ('{Title}'). Reapplying backdrop.");
                ApplySystemBackdrop();
                break;

            case NativeMethods.WM_CLOSE:
                if (OnClose())
                {
                    NativeMethods.DestroyWindow(hWnd);
                }
                return IntPtr.Zero;

            case NativeMethods.WM_DESTROY:
                Log.Info($"WM_DESTROY for {hWnd} ('{Title}').");
                OnDestroy();

                if (this is MainAppWindow)
                {
                    Log.Info("Main window destroyed, posting quit message.");
                    NativeMethods.PostQuitMessage(0);
                }
                else if (this is SecondaryWindow secWin)
                {
                    ApplicationServer.Instance.UnregisterSecondaryWindow(secWin);
                }
                return IntPtr.Zero;

            case NativeMethods.WM_NCDESTROY:
                Log.Info($"WM_NCDESTROY: Releasing GCHandle for {hWnd} ('{Title}').");
                IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);
                if (ptr != IntPtr.Zero)
                {
                    try
                    {
                        var handle = GCHandle.FromIntPtr(ptr);
                        if (handle.IsAllocated)
                        {
                            handle.Free();
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Error($"Error freeing GCHandle on NCDESTROY: {ex.Message}");
                    }
                    NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero);
                }

                if (_gcHandle.IsAllocated && GCHandle.ToIntPtr(_gcHandle) == ptr)
                {
                    _gcHandle = default;
                }
                _hwnd = IntPtr.Zero;
                IsOpen = false;
                break;
        }

        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    public void Close()
    {
        if (_hwnd != IntPtr.Zero && IsOpen)
        {
            Log.Info($"Programmatically closing window {_hwnd} ('{Title}').");
            NativeMethods.PostMessage(_hwnd, NativeMethods.WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
        }
    }

    public void Invalidate()
    {
        if (_hwnd != IntPtr.Zero && IsOpen)
        {
            NativeMethods.InvalidateRect(_hwnd, IntPtr.Zero, false);
        }
    }

    protected abstract bool Initialize();
    public abstract void RenderFrame();
    protected virtual void OnSize(int width, int height) { }
    protected virtual void OnMouseDown(MouseButton button, int x, int y) { }
    protected virtual void OnMouseUp(MouseButton button, int x, int y) { }
    protected virtual void OnMouseMove(int x, int y) { }
    protected virtual void OnKeyDown(int virtualKeyCode) { }
    protected virtual void OnKeyUp(int virtualKeyCode) { }
    protected virtual void OnMouseWheel(short delta) { }
    protected virtual bool IsKeyDownHandled(int virtualKeyCode) { return false; }
    protected virtual bool OnClose() { return true; }
    protected virtual void OnDestroy() { }
    protected abstract void Cleanup();

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_isDisposed)
        {
            if (disposing)
            {
                Log.Info($"Disposing Win32Window '{Title}' (managed)...");
                Cleanup();
            }

            Log.Info($"Disposing Win32Window '{Title}' (unmanaged)...");
            if (_hwnd != IntPtr.Zero)
            {
                Log.Info($"Requesting destroy for window {_hwnd} ('{Title}') during Dispose...");
                NativeMethods.DestroyWindow(_hwnd);
            }
            else
            {
                if (_gcHandle.IsAllocated)
                {
                    Log.Warning($"Freeing potentially dangling GCHandle for '{Title}' during Dispose (window handle was already zero)...");
                    try { _gcHandle.Free(); } catch (Exception ex) { Log.Error($"Error freeing GCHandle: {ex.Message}"); }
                }
            }

            _isDisposed = true;
            IsOpen = false;
            Log.Info($"Win32Window '{Title}' dispose initiated.");
        }
    }

    ~Win32Window()
    {
        Log.Warning($"Win32Window Finalizer called for '{Title}'! Ensure Dispose() was called.");
        Dispose(disposing: false);
    }
}

public enum MouseButton { Left, Right, Middle, XButton1, XButton2 }
</file>

<file path="Res\Cherris\Config.yaml">
Width: 1280
Height: 720
MinWidth: 1280
MinHeight: 720
MaxWidth: -1
MaxHeight: -1
Title: Cheris
ResizableWindow: true
AntiAliasing: true
MainScenePath: Res/Main.yaml
Backend: Raylib
BackdropType: MicaAlt
VSync: false
</file>

<file path="Source\Nodes\Camera.cs">
using Raylib_cs;

namespace Cherris;

public class Camera : Node2D
{
    public float Zoom { get; set; } = 1;

    public void SetAsActive()
    {
        RenderServer.Instance.SetCamera(this);
    }

    public static implicit operator Camera2D(Camera camera)
    {
        // Use the camera's actual owning window size for the offset
        Vector2 windowSize = camera.GetWindowSizeV2();

        return new()
        {
            Target = camera.GlobalPosition,
            Offset = windowSize / 2,
            Zoom = camera.Zoom,
        };
    }
}
</file>

<file path="Source\Nodes\Clickable.cs">
namespace Cherris;

public abstract class Clickable : Node2D
{
    public bool OnTopLeft = false;
    public bool OnTopRight = false;

    public Clickable()
    {
        ClickServer.Instance.Register(this);
    }

    public override void Free()
    {
        ClickServer.Instance.Unregister(this);
        base.Free();
    }

    public abstract bool IsMouseOver();
}
</file>

<file path="Source\Nodes\ClickableRectangle.cs">
namespace Cherris;

public abstract class ClickableRectangle : Clickable
{
    public override bool IsMouseOver()
    {
        var owningWindowNode = GetOwningWindowNode();
        Vector2 mousePosition;

        if (owningWindowNode != null)
        {
            // If part of a WindowNode, use its local mouse position
            mousePosition = owningWindowNode.LocalMousePosition;
        }
        else
        {
            // Otherwise, assume it's in the MainAppWindow
            var mainAppWindow = ApplicationServer.Instance.GetMainAppWindow();
            if (mainAppWindow != null)
            {
                mousePosition = mainAppWindow.GetLocalMousePosition();
            }
            else
            {
                // Fallback if main window isn't available (should not happen in normal operation)
                Log.Warning($"ClickableRectangle '{Name}': MainAppWindow not found for mouse position query. Using global Input.MousePosition as fallback.");
                mousePosition = Input.MousePosition;
            }
        }

        var globalPos = GlobalPosition;
        var origin = Origin;
        var size = ScaledSize;

        float left = globalPos.X - origin.X;
        float top = globalPos.Y - origin.Y;
        float right = left + size.X;
        float bottom = top + size.Y;

        bool isMouseOver =
            mousePosition.X >= left &&
            mousePosition.X < right &&
            mousePosition.Y >= top &&
            mousePosition.Y < bottom;

        return isMouseOver;
    }
}
</file>

<file path="Source\Nodes\Control.cs">
namespace Cherris;

public class Control : ClickableRectangle
{
    public bool Focusable { get; set; } = true;
    public bool Navigable { get; set; } = true;
    public bool RapidNavigation { get; set; } = true;
    public string? FocusNeighborTop { get; set; }
    public string? FocusNeighborBottom { get; set; }
    public string? FocusNeighborLeft { get; set; }
    public string? FocusNeighborRight { get; set; }
    public string? FocusNeighborNext { get; set; }
    public string? FocusNeighborPrevious { get; set; }
    public string AudioBus { get; set; } = "Master";
    public Sound? FocusGainedSound { get; set; }

    private bool wasFocusedLastFrame = false;
    private readonly Dictionary<string, float> actionHoldTimes = [];
    private const float InitialDelay = 0.5f;
    private const float RepeatInterval = 0.1f;

    public bool Disabled
    {
        get;
        set
        {
            if (value == field)
            {
                return;
            }

            field = value;
            WasDisabled?.Invoke(this);
        }
    } = false;

    public bool Focused
    {
        get;
        set
        {
            if (field == value)
            {
                return;
            }
            field = value;
            FocusChanged?.Invoke(this);

            if (field)
            {
                FocusGained?.Invoke(this);

                if (FocusGainedSound is not null)
                {
                    FocusGainedSound?.Play(AudioBus);
                }
            }
        }
    } = false;

    public string ThemeFile
    {
        set
        {
            OnThemeFileChanged(value);
        }
    }

    // Events

    public delegate void Event(Control control);
    public event Event? FocusChanged;
    public event Event? FocusGained;
    public event Event? WasDisabled;
    public event Event? ClickedOutside;

    // Main

    public override void Process()
    {
        base.Process();

        if (Navigable && Focused && wasFocusedLastFrame)
        {
            HandleArrowNavigation();
        }

        UpdateFocusOnOutsideClicked();
        wasFocusedLastFrame = Focused;
    }

    // Navigation

    private void HandleArrowNavigation()
    {
        var actions = new (string Action, string? Path)[]
        {
            ("UiLeft", FocusNeighborLeft),
            ("UiUp", FocusNeighborTop),
            ("UiRight", FocusNeighborRight),
            ("UiDown", FocusNeighborBottom),
            ("UiNext", FocusNeighborNext),
            ("UiPrevious", FocusNeighborPrevious)
        };

        foreach (var entry in actions)
        {
            if (string.IsNullOrEmpty(entry.Path)) continue;

            if (RapidNavigation)
            {
                if (Input.IsActionDown(entry.Action))
                {
                    if (!actionHoldTimes.ContainsKey(entry.Action))
                    {
                        actionHoldTimes[entry.Action] = 0f;
                    }

                    actionHoldTimes[entry.Action] += Time.Delta;
                    float holdTime = actionHoldTimes[entry.Action];

                    bool shouldNavigate = (holdTime <= Time.Delta + float.Epsilon) ||
                        (holdTime >= InitialDelay && (holdTime - InitialDelay) % RepeatInterval < Time.Delta);

                    if (shouldNavigate)
                    {
                        NavigateToControl(entry.Path, entry.Action, holdTime);
                    }
                }
                else
                {
                    actionHoldTimes[entry.Action] = 0f;
                }
            }
            else
            {
                if (Input.IsActionPressed(entry.Action))
                {
                    NavigateToControl(entry.Path, entry.Action, 0f);
                }
            }
        }
    }

    private void NavigateToControl(string controlPath, string action, float holdTime)
    {
        var neighbor = GetNodeOrNull<Control>(controlPath);

        if (neighbor is null)
        {
            Log.Error($"[Control] [{Name}] NavigateToControl: Could not find '{controlPath}'.");
            return;
        }

        if (neighbor.Disabled)
        {
            return;
        }

        if (RapidNavigation)
        {
            neighbor.actionHoldTimes[action] = holdTime;
        }

        neighbor.Focused = true;
        Focused = false;
    }

    // Focus

    private void UpdateFocusOnOutsideClicked()
    {
        if (!IsMouseOver() && Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            Focused = false;
            ClickedOutside?.Invoke(this);
        }
    }

    protected virtual void HandleClickFocus()
    {
        if (Focusable && IsMouseOver())
        {
            Focused = true;
        }
    }

    // Other

    protected virtual void OnThemeFileChanged(string themeFile) { }
}
</file>

<file path="Source\Nodes\VideoPlayer.cs">
using System.Drawing;
using System.Runtime.InteropServices;
using System.Text;
using LibVLCSharp.Shared;
using SharpGen.Runtime;
using Vortice.Direct2D1;
using Vortice.DXGI;
using Vortice.Mathematics;

namespace Cherris;

public class VideoPlayer : Node2D, IDisposable
{
    private static bool _isLibVlcInitialized = false;
    private static readonly object _initLock = new();
    private static readonly object _frameLock = new();

    private LibVLC? _libVLC;
    private MediaPlayer? _mediaPlayer;
    private Media? _media;
    private bool _isDisposed = false;

    private ID2D1Bitmap? _videoBitmap;
    private byte[]? _latestFrameDataRaw;
    private uint _videoWidth = 0;
    private uint _videoHeight = 0;
    private bool _newFrameAvailable = false;
    private bool _formatConfigured = false;

    private uint _receivedChroma = 0;
    private uint _receivedPitch = 0;
    private uint _bufferSize = 0;

    private byte[]? _conversionBufferBGRA32;

    private static readonly uint FourCC_RV32 = CalculateFourCC("RV32");
    private static readonly uint FourCC_RV24 = CalculateFourCC("RV24");

    private MediaPlayer.LibVLCVideoFormatCb? _videoFormatCallbackDelegate;
    private MediaPlayer.LibVLCVideoLockCb? _videoLockCallbackDelegate;
    private MediaPlayer.LibVLCVideoUnlockCb? _videoUnlockCallbackDelegate;
    private MediaPlayer.LibVLCVideoDisplayCb? _videoDisplayCallbackDelegate;
    private MediaPlayer.LibVLCVideoCleanupCb? _videoCleanupCallbackDelegate;
    
    public bool AutoPlay { get; set; } = false;
    public bool IsPlaying => _mediaPlayer?.IsPlaying ?? false;
    public long DurationMilliseconds => _mediaPlayer?.Length ?? 0;
    public bool SuppressPositionRatioChangedEvent { get; set; } = false;

    public override Vector2 Size
    {
        get
        {
            lock (_frameLock)
            {
                // Return actual video size if available, otherwise fallback to base
                return _videoWidth > 0 && _videoHeight > 0
                    ? new(_videoWidth, _videoHeight)
                    : base.Size; // You might want to set a default size here if needed
            }
        }
        set
        {
            base.Size = value;
        }
    }

    private bool _loop = false;
    public bool Loop
    {
        get => _loop;
        set
        {
            if (_loop == value) return;
            _loop = value;
        }
    }

    private float _volume = 100f;
    public float Volume
    {
        get => _volume;
        set
        {
            _volume = Math.Clamp(value, 0f, 100f);

            if (_mediaPlayer != null)
            {
                _mediaPlayer.Volume = (int)_volume;
            }
        }
    }

    public float PositionRatio
    {
        get => _mediaPlayer?.Position ?? 0f;

        set
        {
            if (_mediaPlayer is null)
            {
                return;
            }

            _mediaPlayer.Position = float.Clamp(value, 0f, 1f);
        }
    }

    private string _filePath = "";
    public string FilePath
    {
        get => _filePath;

        set
        {
            if (_filePath == value)
            {
                return;
            }

            _filePath = value;

            if (_mediaPlayer is not null && _libVLC is not null)
            {
                LoadMedia();
            }

            // Invalidate any existing bitmap if path changes
            lock (_frameLock)
            {
                _videoBitmap?.Dispose();
                _videoBitmap = null;
                _videoWidth = 0;
                _videoHeight = 0;
                _receivedChroma = 0; // Reset format info
                _receivedPitch = 0;
                _bufferSize = 0;
                _latestFrameDataRaw = null;
                _conversionBufferBGRA32 = null;
                _newFrameAvailable = false;
                _formatConfigured = false;
            }
        }
    }

    public float PlaybackSpeed
    {
        get;
        set
        {
            // You might want to clamp the value to a reasonable range, e.g., 0.25f to 4.0f
            // float newSpeed = Math.Max(0.1f, Math.Min(value, 16.0f)); // Example clamping
            float newSpeed = float.Clamp(value, 0.25f, 4f); // Using raw value for now
            
            if (float.Abs(field - newSpeed) <= float.Epsilon) // Check for actual change
            {
                return;
            }

            field = newSpeed;
            _mediaPlayer?.SetRate(PlaybackSpeed);
        }
    } = 1.0f;

    // - - - - - - - - - - - - - - -  Events - - - - - - - - - - - - - - - 

    public event EventHandler? PlaybackStarted;
    public event EventHandler? PlaybackPaused;
    public event EventHandler? PlaybackStopped;
    public event EventHandler? PlaybackEnded;
    public event EventHandler<string>? PlaybackError;
    public event Action<float>? PositionRatioChanged;

    // - - - - - - - - - - - - - - - Main - - - - - - - - - - - - - - - 

    public override void Make()
    {
        base.Make();
        InitializeLibVLC();
    }

    public override void Ready()
    {
        base.Ready();

        if (!AutoPlay || _mediaPlayer == null || _media == null || _mediaPlayer.IsPlaying)
        {
            return;
        }

        Play();
    }

    public override void Free()
    {
        Dispose();
        base.Free();
    }

    public override void Draw(DrawingContext context)
    {
        if (!Visible || context.RenderTarget == null || _isDisposed) return;

        bool bitmapNeedsRecreation = false;
        bool frameNeedsProcessing = false; // Flag if new frame needs conversion/copy
        uint currentWidth = 0;
        uint currentHeight = 0;
        uint currentChroma = 0;
        uint currentPitch = 0;
        bool isNewFrameAvailableInLock = false;

        // --- Step 1: Check state under lock ---
        lock (_frameLock)
        {
            currentWidth = _videoWidth;
            currentHeight = _videoHeight;
            currentChroma = _receivedChroma; // Get the format code
            currentPitch = _receivedPitch;   // Get the pitch for the raw data
            isNewFrameAvailableInLock = _newFrameAvailable;

            // Check if D2D BGRA bitmap needs recreation (size changed OR format wasn't configured before)
            // Only attempt recreation if the format IS configured now.
            if ((_videoBitmap == null || _videoBitmap.PixelSize.Width != currentWidth || _videoBitmap.PixelSize.Height != currentHeight)
                && currentWidth > 0 && currentHeight > 0)
            {
                bitmapNeedsRecreation = true;
            }

            // Check if a new frame needs processing (conversion/copy)
            // Can only process if format is configured AND bitmap exists AND raw data exists
            if (isNewFrameAvailableInLock && _formatConfigured && _videoBitmap != null && _latestFrameDataRaw != null && currentChroma != 0)
            {
                // Only process if bitmap dimensions match current video dimensions
                if (_videoBitmap.PixelSize.Width == currentWidth && _videoBitmap.PixelSize.Height == currentHeight)
                {
                    frameNeedsProcessing = true;
                }
                else // Mismatch, force recreation instead
                {
                    Log.Warning($"Draw: Bitmap dimensions ({_videoBitmap?.PixelSize.Width}x{_videoBitmap?.PixelSize.Height}) mismatch current video dimensions ({currentWidth}x{currentHeight}). Forcing recreation.");

                    if (currentWidth > 0 && currentHeight > 0)
                    {
                        bitmapNeedsRecreation = true; // Force recreation
                    }

                    frameNeedsProcessing = false; // Don't process this frame if dims mismatch
                }
            }
        } // --- End Lock for Step 1 ---

        // --- Step 2: Recreate D2D Bitmap if needed (outside lock) ---
        if (bitmapNeedsRecreation)
        {
            ID2D1Bitmap? oldBitmap = null;
            lock (_frameLock) { oldBitmap = _videoBitmap; _videoBitmap = null; }
            oldBitmap?.Dispose();

            // Double-check dimensions and configured status before creating
            lock (_frameLock)
            {
                if (!_formatConfigured || _videoWidth == 0 || _videoHeight == 0)
                {
                    Log.Warning($"Draw: Cannot recreate bitmap. Format Configured: {_formatConfigured}, Dimensions: {_videoWidth}x{_videoHeight}."); return;
                }
            }

            try
            {
                // D2D Bitmap is always BGRA32
                var bitmapProperties = new BitmapProperties(new Vortice.DCommon.PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Ignore));
                var newBitmap = context.RenderTarget.CreateBitmap(new SizeI((int)currentWidth, (int)currentHeight), bitmapProperties);

                lock (_frameLock) { _videoBitmap = newBitmap; }
                Log.Info($"Draw: BGRA32 Bitmap recreated successfully ({currentWidth}x{currentHeight}).");

                // Check if the pending frame can be processed *now* after recreation
                lock (_frameLock)
                {
                    // Re-check all conditions
                    if (_formatConfigured && isNewFrameAvailableInLock && _latestFrameDataRaw != null && currentChroma != 0 &&
                       _videoBitmap != null && _videoBitmap.PixelSize.Width == currentWidth && _videoBitmap.PixelSize.Height == currentHeight)
                    {
                        frameNeedsProcessing = true; // Process frame now
                    }
                    else { frameNeedsProcessing = false; /*Log.Info("Draw: Frame processing not ready after bitmap recreation.");*/ }
                }
            }
            catch (SharpGenException sgex) when (sgex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
            { Log.Warning($"Draw: Render target needs recreation during Bitmap creation."); lock (_frameLock) { _videoBitmap = null; } return; }
            catch (Exception ex) { Log.Error($"Failed to create ID2D1Bitmap: {ex.Message}"); lock (_frameLock) { _videoBitmap = null; } return; }
        }

        // --- Step 3: Process Frame (Convert/Copy) if needed ---
        if (frameNeedsProcessing)
        {
            byte[]? rawData = null;
            byte[]? bgraData = null; // Target for conversion/copy
            ID2D1Bitmap? bitmapForCopy = null;
            uint widthForUpdate = 0;
            uint heightForUpdate = 0;
            uint chromaForUpdate = 0;
            uint pitchForUpdate = 0; // Pitch of the raw data

            // Get data and refs under lock
            lock (_frameLock)
            {
                // Re-check all conditions *inside* the lock
                // Crucially, check _formatConfigured!
                if (_formatConfigured && _videoBitmap != null && _latestFrameDataRaw != null && _newFrameAvailable && _receivedChroma != 0 &&
                    _videoBitmap.PixelSize.Width == currentWidth && _videoBitmap.PixelSize.Height == currentHeight)
                {
                    widthForUpdate = currentWidth;
                    heightForUpdate = currentHeight;
                    // *** IMPORTANT: Use the CHROMA from the raw data buffer, NOT the one we forced (_receivedChroma) ***
                    // This assumes the Lock/Unlock callback gives us the *actual* format being delivered.
                    // If Lock/Unlock doesn't give format info, we might need another way or assume it matches our request.
                    // For now, let's assume we need to handle the format delivered in rawData, whose chroma might be implicitly RV32 or RV24 etc.
                    // We will use the _receivedChroma as the *assumed* format of the locked buffer for now.
                    chromaForUpdate = _receivedChroma; // <-- Revisit this if Lock/Unlock gives explicit format info
                    pitchForUpdate = _receivedPitch;   // Use the pitch associated with the buffer we locked (should match our forced pitch)
                    rawData = _latestFrameDataRaw;
                    bitmapForCopy = _videoBitmap;

                    // Ensure BGRA conversion buffer exists if needed (or for direct copy target)
                    uint bgraSize = widthForUpdate * heightForUpdate * 4;
                    if (_conversionBufferBGRA32 == null || _conversionBufferBGRA32.Length != bgraSize)
                    {
                        try { _conversionBufferBGRA32 = new byte[bgraSize]; }
                        catch (Exception ex) { Log.Error($"Failed to allocate BGRA buffer: {ex.Message}"); _conversionBufferBGRA32 = null; }
                    }
                    bgraData = _conversionBufferBGRA32;
                }
                else { /* Conditions no longer met */ rawData = null; bgraData = null; bitmapForCopy = null; }
            } // --- End Lock ---

            bool processedSuccessfully = false;
            if (rawData != null && bgraData != null && bitmapForCopy != null && widthForUpdate > 0 && heightForUpdate > 0)
            {
                try
                {
                    // *** FORMAT HANDLING ***
                    // Here we process based on 'chromaForUpdate', which currently is assumed to be the RV32 we requested.
                    if (chromaForUpdate == FourCC_RV32) // BGRA32
                    {
                        uint expectedBgraPitch = widthForUpdate * 4;
                        if (pitchForUpdate == expectedBgraPitch)
                        {
                            // Pitches match, direct copy
                            bitmapForCopy.CopyFromMemory(new Rectangle(0, 0, (int)widthForUpdate, (int)heightForUpdate), rawData, pitchForUpdate);
                            processedSuccessfully = true;
                        }
                        else
                        {
                            // This case *shouldn't* happen if we forced RV32 with the correct pitch, but handle defensively.
                            Log.Warning($"RV32 pitch mismatch (Expected {expectedBgraPitch}, Got {pitchForUpdate}). Using intermediate buffer copy.");
                            CopyMemoryWithPitch(rawData, pitchForUpdate, bgraData, expectedBgraPitch, widthForUpdate * 4, heightForUpdate);
                            bitmapForCopy.CopyFromMemory(new Rectangle(0, 0, (int)widthForUpdate, (int)heightForUpdate), bgraData, expectedBgraPitch);
                            processedSuccessfully = true;
                        }
                    }
                    // LibVLC might ignore our RV32 request and send something else like RV24.
                    // We need to be prepared for this possibility if the above doesn't work.
                    // For now, we assume RV32 is delivered if the setup succeeded.
                    // else if (chromaForUpdate == FourCC_RV24) // BGR24 - Keep this conversion just in case
                    // {
                    //     ConvertBGR24ToBGRA32(rawData, bgraData, widthForUpdate, heightForUpdate, pitchForUpdate);
                    //     uint bgraPitch = widthForUpdate * 4;
                    //     bitmapForCopy.CopyFromMemory(new Rectangle(0, 0, (int)widthForUpdate, (int)heightForUpdate), bgraData, bgraPitch);
                    //     processedSuccessfully = true;
                    // }
                    else
                    {
                        // This implies the format delivered doesn't match RV32, which we requested.
                        Log.Error($"Draw: Skipping frame processing. Unexpected video format received in buffer (Expected RV32): {FourCCToString(chromaForUpdate)} (0x{chromaForUpdate:X8})");
                    }

                    if (processedSuccessfully)
                    {
                        lock (_frameLock) { _newFrameAvailable = false; }
                    }

                }
                catch (SharpGenException sgex) when (sgex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
                { Log.Warning($"Draw: Render target needs recreation during CopyFromMemory."); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; _newFrameAvailable = false; } return; }
                catch (Exception ex) { Log.Error($"Failed during frame processing/copy: {ex.Message}"); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; _newFrameAvailable = false; } }
            }
            else if (frameNeedsProcessing) { Log.Warning($"Draw: Skipped frame processing. HasBitmap={bitmapForCopy != null}, HasRawData={rawData != null}, HasBGRAData={bgraData != null}, Chroma={chromaForUpdate}, W={widthForUpdate}, H={heightForUpdate}"); }
        }


        // --- Step 4: Draw D2D Bitmap ---
        ID2D1Bitmap? bitmapToDraw = null;
        lock (_frameLock) { bitmapToDraw = _videoBitmap; } // Get current bitmap ref


        if (bitmapToDraw != null && currentWidth > 0 && currentHeight > 0) // Use originally captured dimensions
        {
            try
            {
                var position = GlobalPosition - Origin;
                var size = ScaledSize;
                var destRect = new RectangleF(position.X, position.Y, size.X, size.Y);
                var sourceRect = new RectangleF(0, 0, bitmapToDraw.PixelSize.Width, bitmapToDraw.PixelSize.Height); // Use bitmap's actual size

                context.RenderTarget.DrawBitmap(bitmapToDraw, destRect, 1.0f, BitmapInterpolationMode.Linear, sourceRect);
            }
            catch (SharpGenException sgex) when (sgex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
            { Log.Warning($"Draw: Render target needs recreation during DrawBitmap."); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; } return; }
            catch (ObjectDisposedException) { Log.Warning($"Draw: Bitmap was disposed before DrawBitmap."); lock (_frameLock) { _videoBitmap = null; } }
            catch (Exception ex) { Log.Error($"Failed to draw video bitmap: {ex.Message}"); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; } }
        }
        else if (Visible) { DrawPlaceholder(context, GlobalPosition - Origin, base.Size); } // Draw placeholder if visible but no bitmap
    }

    private void InitializeLibVLC()
    {
        lock (_initLock)
        {
            if (!_isLibVlcInitialized)
            {
                try
                {
                    Core.Initialize();
                    _isLibVlcInitialized = true;
                    Log.Info("LibVLC Core initialized.");
                }
                catch (Exception ex)
                {
                    Log.Error($"Failed to initialize LibVLC Core: {ex.Message}");
                    PlaybackError?.Invoke(this, $"Failed to initialize LibVLC Core: {ex.Message}");
                    return;
                }
            }
        }

        try
        {
            List<string> libvlcOptions =
            [
                "--no-osd",
                "--avcodec-hw=none"
                // "--verbose=2" // Uncomment for more detailed VLC logs if needed
            ];

            _libVLC = new(libvlcOptions.ToArray());

            Log.Info($"LibVLC instance created with options: {string.Join(" ", libvlcOptions)}");

            _mediaPlayer = new MediaPlayer(_libVLC);

            _videoFormatCallbackDelegate = new(VideoFormatCallback);
            _videoCleanupCallbackDelegate = new(VideoCleanupCallback);
            _videoLockCallbackDelegate = new(VideoLockCallback);
            _videoUnlockCallbackDelegate = new(VideoUnlockCallback);
            _videoDisplayCallbackDelegate = new(VideoDisplayCallback);

            _mediaPlayer.SetVideoFormatCallbacks(_videoFormatCallbackDelegate, _videoCleanupCallbackDelegate);
            _mediaPlayer.SetVideoCallbacks(_videoLockCallbackDelegate, _videoUnlockCallbackDelegate, _videoDisplayCallbackDelegate);

            _mediaPlayer.Playing += OnPlaying;
            _mediaPlayer.Paused += OnPaused;
            _mediaPlayer.Stopped += OnStopped;
            _mediaPlayer.EndReached += OnEndReached;
            _mediaPlayer.EncounteredError += OnEncounteredError;
            _mediaPlayer.PositionChanged += OnPositionChanged;

            _mediaPlayer.Volume = (int)Volume;
            // Set initial playback speed if mediaplayer is already created
            // This is mostly redundant if LoadMedia also sets it, but good for safety.
            _mediaPlayer.SetRate(PlaybackSpeed);


            if (!string.IsNullOrEmpty(FilePath))
            {
                LoadMedia();
            }
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to create LibVLC instance or MediaPlayer: {ex.Message}");
            PlaybackError?.Invoke(this, $"Failed to create LibVLC/MediaPlayer: {ex.Message}");
            DisposeVlcResources();
        }
    }

    private static uint CalculateFourCC(string code)
    {
        if (code is null || code.Length != 4)
        {
            throw new ArgumentException("FourCC code must be 4 characters long.", nameof(code));
        }

        byte[] bytes = Encoding.ASCII.GetBytes(code);

        if (BitConverter.IsLittleEndian)
        {
            return BitConverter.ToUInt32(bytes, 0);
        }

        Array.Reverse(bytes);

        return BitConverter.ToUInt32(bytes, 0);
    }

    private static string FourCCToString(uint fourCC)
    {
        byte[] bytes = BitConverter.GetBytes(fourCC);

        if (!BitConverter.IsLittleEndian)
        {
            Array.Reverse(bytes);
        }

        bool isAsciiPrintable = bytes.All(b => b >= 32 && b <= 126);

        return isAsciiPrintable
            ? Encoding.ASCII.GetString(bytes)
            : $"0x{fourCC:X8}";
    }

    private uint VideoFormatCallback(ref nint opaque, nint chroma, ref uint width, ref uint height, ref uint pitches, ref uint lines)
    {
        // This callback might be called multiple times.
        // We need valid width, height, *and* pitches/lines to fully configure.
        uint currentChromaInt = 0;
        try
        {
            if (IntPtr.Size == 4) currentChromaInt = (uint)chroma.ToInt32();
            else currentChromaInt = (uint)chroma.ToInt64();
        }
        catch (OverflowException ex)
        {
            Log.Error($"VideoFormatCallback: Chroma IntPtr value overflows uint32. {ex.Message}");
            return 0; // Cannot process
        }

        string currentChromaStr = FourCCToString(currentChromaInt);

        Log.Info($"VideoFormatCallback: Received Format='{currentChromaStr}' (0x{currentChromaInt:X8}), Dimensions={width}x{height}, Pitch={pitches}, Lines={lines}");

        // *** Reject if dimensions are fundamentally invalid ***
        if (width == 0 || height == 0)
        {
            Log.Error($"VideoFormatCallback: Rejecting format due to invalid dimensions (W:{width}, H:{height}).");
            // Reset state if we previously had valid info
            lock (_frameLock)
            {
                ResetFormatState_Locked();
            }
            return 0; // Indicate failure
        }

        // *** Force BGRA32 (RV32) format for Direct2D compatibility ***
        uint targetChroma = FourCC_RV32;
        uint targetPitch = width * 4; // BGRA = 4 bytes per pixel
        uint targetLines = height;
        string targetChromaStr = FourCCToString(targetChroma);

        lock (_frameLock)
        {
            // Check if anything crucial changed OR if we haven't configured yet
            bool dimensionsChanged = (_videoWidth != width || _videoHeight != height);
            // We are forcing RV32, so we don't check _receivedChroma vs targetChroma for change here

            if (dimensionsChanged || !_formatConfigured)
            {
                Log.Info($"VideoFormatCallback: Configuring/Updating format - Size: {width}x{height}. Forcing Chroma: {targetChromaStr}, Pitch: {targetPitch}, Lines: {targetLines}. Previously Configured: {_formatConfigured}");

                // Clear potentially outdated resources if dimensions changed
                if (dimensionsChanged)
                {
                    _videoBitmap?.Dispose(); _videoBitmap = null;
                    _latestFrameDataRaw = null; _conversionBufferBGRA32 = null;
                    _newFrameAvailable = false;
                }

                // Store the *target* format details
                _receivedChroma = targetChroma; // Store what we requested
                _videoWidth = width;
                _videoHeight = height;
                _receivedPitch = targetPitch; // Store calculated pitch for BGRA32
                _bufferSize = targetPitch * targetLines; // Calculate buffer size for BGRA32

                _formatConfigured = true; // Mark as successfully configured
                Log.Info($"Calculated buffer size for forced BGRA32: {_bufferSize} bytes");
            }
            // Update the parameters passed by reference to tell LibVLC we want RV32
            Marshal.WriteInt32(chroma, (int)targetChroma); // Write the FourCC code
            pitches = targetPitch;
            lines = targetLines;
        }

        return targetLines; // Return the height (number of lines) to indicate success
    }

    private void VideoCleanupCallback(ref nint opaque)
    {
        Log.Info("VideoCleanupCallback called.");
    }

    private nint VideoLockCallback(nint opaque, nint planes)
    {
        lock (_frameLock)
        {
            // Check if format is FULLY configured (valid pitch/lines received)
            if (!_formatConfigured || _bufferSize == 0 || _receivedPitch == 0)
            {
                Log.Warning($"VideoLockCallback: Cannot lock, format not fully configured yet (Configured={_formatConfigured}, Size={_bufferSize}, Pitch={_receivedPitch}).");
                return nint.Zero;
            }

            // Allocate/Reallocate raw frame buffer if needed
            if (_latestFrameDataRaw == null || _latestFrameDataRaw.Length != _bufferSize)
            {
                try
                {
                    _latestFrameDataRaw = new byte[_bufferSize];
                    Log.Info($"Allocated raw frame buffer: {_bufferSize} bytes for format {FourCCToString(_receivedChroma)}");
                }
                catch (Exception ex)
                {
                    Log.Error($"VideoLockCallback: Exception allocating raw buffer of size {_bufferSize}. {ex.Message}");
                    _latestFrameDataRaw = null;
                    ResetFormatState_Locked(); // Mark format as unconfigured
                    return nint.Zero;
                }
            }

            // We should have a buffer here.
            if (_latestFrameDataRaw == null)
            {
                Log.Error("VideoLockCallback: Raw Frame buffer is null after allocation check.");
                return nint.Zero;
            }

            // Pin the buffer and provide pointer to VLC
            var handle = GCHandle.Alloc(_latestFrameDataRaw, GCHandleType.Pinned);
            var bufferPtr = handle.AddrOfPinnedObject();

            if (planes == IntPtr.Zero)
            {
                Log.Error("VideoLockCallback: Received null planes pointer.");
                handle.Free();
                return nint.Zero;
            }
            // For packed formats (like RV32, RV24), VLC expects a single plane pointer.
            // For planar formats (like I420), it expects pointers for Y, U, V planes.
            // We assume planes[0] is the target for packed formats.
            // TODO: Handle planar formats correctly if needed (write multiple pointers).
            Marshal.WriteIntPtr(planes, 0, bufferPtr); // Write pointer to planes[0]

            return GCHandle.ToIntPtr(handle); // Return handle to be freed in Unlock
        }
    }

    private void VideoUnlockCallback(nint opaque, nint picture, nint planes)
    {
        lock (_frameLock)
        {
            if (picture == IntPtr.Zero)
            {
                Log.Warning("VideoUnlockCallback: Received null picture handle.");
                return;
            }

            _newFrameAvailable = true; // Signal that a raw frame is ready

            try
            {
                var handle = GCHandle.FromIntPtr(picture);
                if (handle.IsAllocated) handle.Free();
                else Log.Warning("VideoUnlockCallback: GCHandle was not allocated?");
            }
            catch (Exception ex)
            {
                Log.Error($"VideoUnlockCallback: Exception freeing GCHandle {picture}. {ex.Message}");
            }
        }
    }

    private void VideoDisplayCallback(nint opaque, nint picture)
    {
        // Not strictly needed for our rendering logic which polls _newFrameAvailable.
    }

    private void LoadMedia()
    {
        if (_libVLC == null || _mediaPlayer == null || string.IsNullOrEmpty(FilePath))
        {
            Log.Warning($"Cannot load media: LibVLC/MediaPlayer not ready or FilePath is empty for node '{Name}'.");
            return;
        }

        if (_mediaPlayer.IsPlaying) _mediaPlayer.Stop();

        lock (_frameLock)
        {
            _media?.Dispose(); _media = null;
            _videoBitmap?.Dispose(); _videoBitmap = null;
            _latestFrameDataRaw = null;
            _conversionBufferBGRA32 = null;
            _videoWidth = 0; _videoHeight = 0;
            _receivedChroma = 0; _receivedPitch = 0; _bufferSize = 0;
            _newFrameAvailable = false;
            Log.Info($"Cleared previous media state for node '{Name}'.");
            _formatConfigured = false;
        }


        string absolutePath;
        try { absolutePath = Path.GetFullPath(FilePath); }
        catch (Exception ex) { Log.Error($"Error getting full path '{FilePath}': {ex.Message}"); PlaybackError?.Invoke(this, $"Invalid path: {ex.Message}"); return; }

        if (!File.Exists(absolutePath)) { Log.Error($"Video file not found: {absolutePath}"); PlaybackError?.Invoke(this, $"Video file not found: {absolutePath}"); return; }

        // No specific options needed here now regarding chroma
        List<string> mediaOptions = new List<string> { ":no-video-title-show" };

        try
        {
            _media = new Media(_libVLC, new Uri(absolutePath), mediaOptions.ToArray());
            _mediaPlayer.Media = _media;
            Log.Info($"Loaded media: {absolutePath} for node '{Name}'.");

            // Apply the current playback speed to the new media
            if (_mediaPlayer != null)
            {
                _mediaPlayer.SetRate(PlaybackSpeed);
            }
        }
        catch (Exception ex)
        {
            Log.Error($"Error loading media '{absolutePath}': {ex.Message}");
            PlaybackError?.Invoke(this, $"Error loading media: {ex.Message}");
            _media?.Dispose(); _media = null;
        }
        // Reset format flag on new media load
        lock (_frameLock) { _formatConfigured = false; }
    }

    // - - - - - - - - - - - - - - - Usage - - - - - - - - - - - - - - - 

    public void Play()
    {
        if (_mediaPlayer != null && _media != null)
        {
            if (_mediaPlayer.State == VLCState.Error) { Log.Warning($"Cannot play node '{Name}', player state is Error."); PlaybackError?.Invoke(this, $"Player state is Error"); return; }

            // Ensure playback speed is set before playing, in case it was changed while stopped/paused.
            _mediaPlayer.SetRate(PlaybackSpeed);

            if (!_mediaPlayer.IsPlaying)
            {
                Log.Info($"Playing media: {FilePath} for node '{Name}' at speed: {PlaybackSpeed}x.");
                if (!_mediaPlayer.Play())
                {
                    Log.Error($"MediaPlayer.Play() returned false for node '{Name}'. State: {_mediaPlayer.State}");
                    PlaybackError?.Invoke(this, "Play() failed.");
                }
            }
        }
        else { Log.Warning($"Cannot play: MediaPlayer or Media not ready for node '{Name}'."); }
    }

    public void Pause()
    {
        if (_mediaPlayer?.CanPause ?? false) { _mediaPlayer.Pause(); }
        else { Log.Warning($"Cannot pause node '{Name}'."); }
    }

    public void Stop()
    {
        if (_mediaPlayer != null) { _mediaPlayer.Stop(); }
        else { Log.Warning($"Cannot stop node '{Name}'."); }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    // - - - - - - - - - - - - - - - Static - - - - - - - - - - - - - - - 

    private static void ConvertBGR24ToBGRA32(byte[] bgr24Data, byte[] bgra32Data, uint width, uint height, uint bgrPitch)
    {
        uint bgraPitch = width * 4;
        int numPixelsWidth = (int)width;

        ulong requiredBgraSize = (ulong)height * bgraPitch;
        ulong requiredBgrSize = (ulong)height * bgrPitch;

        if ((ulong)bgra32Data.LongLength < requiredBgraSize || (ulong)bgr24Data.LongLength < requiredBgrSize)
        {
            Log.Error($"Buffer size mismatch in ConvertBGR24ToBGRA32 (Pitched). BGR:{bgr24Data.Length}, BGRA:{bgra32Data.Length}, Expected BGR:{requiredBgrSize}, Expected BGRA:{requiredBgraSize}");
            return;
        }

        for (int y = 0; y < height; y++)
        {
            int bgrRowStart = (int)(y * bgrPitch);
            int bgraRowStart = (int)(y * bgraPitch);

            for (int x = 0; x < numPixelsWidth; x++)
            {
                int bgrIndex = bgrRowStart + x * 3;
                int bgraIndex = bgraRowStart + x * 4;

                if (bgrIndex + 2 >= bgr24Data.Length || bgraIndex + 3 >= bgra32Data.Length)
                {
                    Log.Error($"Index out of bounds during BGR->BGRA conversion at x={x}, y={y}.");
                    return;
                }

                byte b = bgr24Data[bgrIndex + 0];
                byte g = bgr24Data[bgrIndex + 1];
                byte r = bgr24Data[bgrIndex + 2];

                bgra32Data[bgraIndex + 0] = b;
                bgra32Data[bgraIndex + 1] = g;
                bgra32Data[bgraIndex + 2] = r;
                bgra32Data[bgraIndex + 3] = 255;
            }
        }
    }

    private static unsafe void CopyMemoryWithPitch(byte[] source, uint sourcePitch, byte[] destination, uint destPitch, uint bytesPerRow, uint rowCount)
    {
        if (source is null || destination is null || bytesPerRow == 0 || rowCount == 0)
        {
            return;
        }

        var requiredSourceSize = (ulong)(rowCount - 1) * sourcePitch + bytesPerRow;
        var requiredDestSize = (ulong)(rowCount - 1) * destPitch + bytesPerRow;

        if (bytesPerRow > sourcePitch || bytesPerRow > destPitch)
        {
            Log.Error("CopyMemoryWithPitch: bytesPerRow exceeds pitch.");
            return;
        }

        if (requiredSourceSize > (ulong)source.LongLength || requiredDestSize > (ulong)destination.LongLength)
        {
            Log.Error($"CopyMemoryWithPitch: Calculated size exceeds buffer length. Source Required: " +
                $"{requiredSourceSize}" +
                $"vs Actual: {source.LongLength}." +
                $"Dest Required: {requiredDestSize}" +
                $"vs Actual: {destination.LongLength}");

            return;
        }

        fixed (byte* pSource = source, pDest = destination)
        {
            byte* pSrcRow = pSource;
            byte* pDstRow = pDest;

            for (uint i = 0; i < rowCount; i++)
            {
                Buffer.MemoryCopy(pSrcRow, pDstRow, bytesPerRow, bytesPerRow);

                pSrcRow += sourcePitch;
                pDstRow += destPitch;
            }
        }
    }

    private static void DrawPlaceholder(DrawingContext context, Vector2 position, Vector2 size)
    {
        Rect placeholderRect = new(position.X, position.Y, size.X, size.Y);
        ID2D1SolidColorBrush? brush = context.OwnerWindow?.GetOrCreateBrush(Colors.DarkGray);

        if (brush == null || context.RenderTarget == null)
        {
            return;
        }

        context.RenderTarget.FillRectangle(placeholderRect, brush);
    }

    // - - - - - - - - - - - - - - - Event handlers - - - - - - - - - - - - - - - 

    private void OnPlaying(object? sender, EventArgs e)
    {
        PlaybackStarted?.Invoke(this, EventArgs.Empty);
    }

    private void OnPaused(object? sender, EventArgs e)
    {
        PlaybackPaused?.Invoke(this, EventArgs.Empty);
    }

    private void OnStopped(object? sender, EventArgs e)
    {
        PlaybackStopped?.Invoke(this, EventArgs.Empty);

        lock (_frameLock)
        {
            _newFrameAvailable = false;
        }
    }

    private void OnEndReached(object? sender, EventArgs e)
    {
        PlaybackEnded?.Invoke(this, EventArgs.Empty); lock (_frameLock) { _newFrameAvailable = false; }
        if (Loop && _mediaPlayer != null && _media != null && !_isDisposed) { _mediaPlayer.Stop(); _mediaPlayer.Play(); }
    }

    private void OnEncounteredError(object? sender, EventArgs e)
    {
        Log.Error($"LibVLCSharp error for node '{Name}'. State: {_mediaPlayer?.State}");
        PlaybackError?.Invoke(this, "LibVLCSharp error. Check logs.");

        lock (_frameLock)
        {
            _newFrameAvailable = false;
        }
    }

    // Handler for MediaPlayer.PositionChanged
    private void OnPositionChanged(object? sender, MediaPlayerPositionChangedEventArgs e)
    {
        if (SuppressPositionRatioChangedEvent) // Check the flag
        {
            return;
        }

        PositionRatioChanged?.Invoke(e.Position);
    }

    private void ResetFormatState_Locked()
    {
        _videoBitmap?.Dispose(); _videoBitmap = null;
        _latestFrameDataRaw = null; _conversionBufferBGRA32 = null;
        _newFrameAvailable = false; _videoWidth = 0; _videoHeight = 0;
        _receivedChroma = 0; _receivedPitch = 0; _bufferSize = 0;
        _formatConfigured = false; // Mark as unconfigured
    }

    // - - - - - - - - - - - - - - - Diospose - - - - - - - - - - - - - - - 

    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed)
        {
            return;
        }

        _isDisposed = true;

        Log.Info($"Disposing VideoPlayer '{Name}' (disposing={disposing})...");

        try
        {
            if (_mediaPlayer != null && _mediaPlayer.IsPlaying)
            {
                _mediaPlayer.Stop();
            }
        }
        catch (Exception ex)
        {
            Log.Warning($"Exception stopping MediaPlayer during dispose: {ex.Message}");
        }

        if (disposing)
        {
            if (_mediaPlayer != null)
            {
                _mediaPlayer.Playing -= OnPlaying;
                _mediaPlayer.Paused -= OnPaused;
                _mediaPlayer.Stopped -= OnStopped;
                _mediaPlayer.EndReached -= OnEndReached;
                _mediaPlayer.EncounteredError -= OnEncounteredError;
                _mediaPlayer.PositionChanged -= OnPositionChanged;

                try
                {
                    _mediaPlayer.SetVideoFormatCallbacks(null, null);
                    _mediaPlayer.SetVideoCallbacks(null, null, null);
                }
                catch (Exception ex)
                {
                    Log.Warning($"Exception detaching callbacks: {ex.Message}");
                }
            }

            try
            {
                _media?.Dispose();
            }
            catch (Exception ex)
            {
                Log.Warning($"Exception disposing Media: {ex.Message}");
            }
            finally
            {
                _media = null;
            }

            try
            {
                _mediaPlayer?.Dispose();
            }
            catch (Exception ex)
            {
                Log.Warning($"Exception disposing MediaPlayer: {ex.Message}");
            }
            finally
            {
                _mediaPlayer = null;
            }

            try
            {
                _libVLC?.Dispose();
            }
            catch (Exception ex)
            {
                Log.Warning($"Exception disposing LibVLC: {ex.Message}");
            }
            finally
            {
                _libVLC = null;
            }

            _videoFormatCallbackDelegate = null;
            _videoCleanupCallbackDelegate = null;
            _videoLockCallbackDelegate = null;
            _videoUnlockCallbackDelegate = null;
            _videoDisplayCallbackDelegate = null;
        }

        ID2D1Bitmap? bitmapToDispose = null;

        lock (_frameLock)
        {
            bitmapToDispose = _videoBitmap; _videoBitmap = null;
            _latestFrameDataRaw = null; // Release raw buffer
            _conversionBufferBGRA32 = null; // Release conversion buffer
            _newFrameAvailable = false;
            _videoWidth = 0;
            _videoHeight = 0;
            _receivedChroma = 0;
            _receivedPitch = 0;
            _bufferSize = 0;
        }

        _formatConfigured = false; // Ensure flag is reset
        bitmapToDispose?.Dispose();

        Log.Info($"VideoPlayer '{Name}' disposed.");
    }

    private void DisposeVlcResources()
    {
        Log.Warning($"DisposeVlcResources called directly for '{Name}'. Use Dispose().");
        Dispose(true);
    }

    ~VideoPlayer()
    {
        Dispose(false);
    }
}
</file>

<file path="Source\Nodes\WindowNode.cs">
namespace Cherris;

public class WindowNode : Node2D
{
    protected SecondaryWindow? secondaryWindow;
    private string windowTitle = "Cherris Window";
    private int windowWidth = 640;
    private int windowHeight = 480;
    private SystemBackdropType backdropType = SystemBackdropType.None;

    protected bool isQueuedForFree = false;

    public string Title
    {
        get => windowTitle;
        set
        {
            if (windowTitle == value) return;
            windowTitle = value;
        }
    }

    public int Width
    {
        get => windowWidth;
        set
        {
            if (windowWidth == value) return;
            windowWidth = value;
        }
    }

    public int Height
    {
        get => windowHeight;
        set
        {
            if (windowHeight == value) return;
            windowHeight = value;
        }
    }

    public SystemBackdropType BackdropType
    {
        get => backdropType;
        set
        {
            if (backdropType == value) return;
            backdropType = value;
            secondaryWindow?.ApplySystemBackdrop();
        }
    }

    public override void Make()
    {
        base.Make();
        InitializeWindow();
    }

    public override void Process()
    {
        base.Process();

        if (isQueuedForFree)
        {
            FreeInternal();
        }
    }

    private void InitializeWindow()
    {
        if (secondaryWindow is not null)
        {
            Log.Warning($"WindowNode '{Name}' already has an associated window. Skipping creation.");
            return;
        }

        try
        {
            secondaryWindow = new SecondaryWindow(Title, this.Width, this.Height, this);

            if (!secondaryWindow.TryCreateWindow())
            {
                Log.Error($"WindowNode '{Name}' failed to create its window.");
                secondaryWindow = null;
                return;
            }

            secondaryWindow.BackdropType = this.BackdropType;

            if (!secondaryWindow.InitializeWindowAndGraphics())
            {
                Log.Error($"WindowNode '{Name}' failed to initialize window graphics.");
                secondaryWindow.Dispose();
                secondaryWindow = null;
                return;
            }

            secondaryWindow.ShowWindow();
            Log.Info($"WindowNode '{Name}' successfully created and initialized its window.");
        }
        catch (Exception ex)
        {
            Log.Error($"Error during WindowNode '{Name}' initialization: {ex.Message}");
            secondaryWindow?.Dispose();
            secondaryWindow = null;
        }
    }

    public void QueueFree()
    {
        isQueuedForFree = true;
    }

    protected virtual void FreeInternal()
    {
        Log.Info($"Freeing WindowNode '{Name}' and its associated window.");
        secondaryWindow?.Close();
        secondaryWindow = null;
        base.Free();
    }

    public override void Free()
    {
        if (!isQueuedForFree)
        {
            Log.Warning($"Direct call to Free() on WindowNode '{Name}' detected. Use QueueFree() instead.");
            QueueFree();
        }
    }

    internal void RenderChildren(DrawingContext context)
    {
        foreach (Node child in Children)
        {
            RenderNodeRecursive(child, context);
        }
    }

    private static void RenderNodeRecursive(Node node, DrawingContext context)
    {
        if (node is WindowNode)
        {
            return;
        }

        if (node is VisualItem { Visible: true } visualItem)
        {
            visualItem.Draw(context);
        }

        var childrenToRender = new List<Node>(node.Children);
        foreach (Node child in childrenToRender)
        {
            RenderNodeRecursive(child, context);
        }
    }

    public SecondaryWindow? GetWindowHandle() => secondaryWindow;

    public Vector2 LocalMousePosition => secondaryWindow?.GetLocalMousePosition() ?? Input.MousePosition;
}
</file>

<file path="Source\Resources\Animation.cs">
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Cherris;

public class Animation
{
    public List<Keyframe> Keyframes { get; set; } = new();

    public class Keyframe
    {
        [YamlMember(Alias = "T")]
        public float Time { get; set; }

        public Dictionary<string, Dictionary<string, float>> Nodes { get; set; } = [];
    }

    public Animation() { }

    public Animation(string filePath)
    {
        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(PascalCaseNamingConvention.Instance)
            .Build();

        Keyframes = deserializer.Deserialize<List<Keyframe>>(File.ReadAllText(filePath));
    }
}
</file>

<file path="Source\Resources\AudioStream.cs">
namespace Cherris;

public class AudioStream
{
    //public float Length { get; private set; } = 0.1f;
    //public string Path { get; private set; }
    //
    //private Music raylibMusic;
    //
    //public static implicit operator Music(AudioStream audio) => audio.raylibMusic;
    //
    //private AudioStream(Music music, float length, string path)
    //{
    //    raylibMusic = music;
    //    Length = length;
    //    Path = path;
    //}
    //
    public static AudioStream? Load(string filePath)
    {
        return null;
    }
}
</file>

<file path="Source\Resources\Font.cs">
using Raylib_cs;

namespace Cherris;

public class Font
{
    public string Name = "";
    public int Size = 0;

    private Raylib_cs.Font raylibFont;

    public Vector2 Dimensions
    {
        get
        {
            return Raylib.MeasureTextEx(raylibFont, " ", Size, 0);
        }
    }

    public Font(string filePath, int size)
    {
        Size = size;
        Name = Path.GetFileNameWithoutExtension(filePath);

        int[] codepoints = new int[255 - 32 + 1];
        for (int i = 0; i < codepoints.Length; i++)
        {
            codepoints[i] = 32 + i;
        }

        raylibFont = Raylib.LoadFontEx(filePath, size, codepoints, codepoints.Length);
        Raylib.SetTextureFilter(raylibFont.Texture, TextureFilter.Bilinear);
    }

    public static implicit operator Raylib_cs.Font(Font textFont) => textFont.raylibFont;

    public static Vector2 MeasureText(Font font, string text, int size, float spacing)
    {
        Vector2 measurements = Raylib.MeasureTextEx(
            font,
            text,
            size,
            spacing);

        return measurements;
    }
}
</file>

<file path="Source\Resources\Shader.cs">
namespace Cherris;

public class Shader
{
    private Raylib_cs.Shader raylibShader;

    private Shader(Raylib_cs.Shader shader)
    {
        raylibShader = shader;
    }

    public static Shader? Load(string? vertexShaderPath, string? fragmentShaderPath)
    {
        Raylib_cs.Shader shader = Raylib_cs.Raylib.LoadShader(vertexShaderPath, fragmentShaderPath);

        if (!Raylib_cs.Raylib.IsShaderValid(shader))
        {
            Log.Error($"Failed to load shader: {vertexShaderPath},{fragmentShaderPath}");
            return null;
        }

        return new(shader);
    }

    public static implicit operator Raylib_cs.Shader(Shader shader)
    {
        return shader.raylibShader;
    }

    public void SetValue(int loc, float[] values, ShaderUniformDataType uniformType)
    {
        Raylib_cs.Raylib.SetShaderValue(
            this,
            loc,
            values,
            (Raylib_cs.ShaderUniformDataType)uniformType);
    }

    public int GetLocation(string uniformName)
    {
        return Raylib_cs.Raylib.GetShaderLocation(this, uniformName);
    }
}
</file>

<file path="Source\Resources\ShaderUniformDataType.cs">
namespace Cherris;

public enum ShaderUniformDataType
{
    Float = 0,
    Vec2,
    Vec3,
    Vec4,
    Int,
    IVec2,
    IVec3,
    IVec4,
    Sampler2D
}
</file>

<file path="Source\Resources\Sound.cs">
namespace Cherris;

public class Sound
{
    public string Path { get; private set; } = "";

    private Raylib_cs.Sound raylibSound;

    public static implicit operator Raylib_cs.Sound(Sound sound) => sound.raylibSound;

    private Sound(Raylib_cs.Sound sound, string filePath)
    {
        raylibSound = sound;
        Path = filePath;
    }

    public static Sound? Load(string filePath)
    {
        Raylib_cs.Sound sound = Raylib_cs.Raylib.LoadSound(filePath);

        if (sound.FrameCount == 0)
        {
            return null;
        }

        return new(sound, filePath);
    }

    public void Play(string bus = "Master")
    {
        //AudioServer.Instance.PlaySound(this, bus);
    }
}
</file>

<file path="Source\Resources\Texture.cs">
using Raylib_cs;

namespace Cherris;

public class Texture
{
    public Vector2 Size { get; private set; } = Vector2.Zero;
    private Texture2D raylibTexture;

    public Texture(string filePath)
    {
        string pngPath =
            Path.GetExtension(filePath).ToLower() == ".png" ?
            filePath :
            GetPngPath(filePath);

        raylibTexture = Raylib.LoadTexture(pngPath);
        Size = new(raylibTexture.Width, raylibTexture.Height);

        if (pngPath != filePath)
        {
            File.Delete(pngPath);
        }
    }

    public Texture()
    {
    }

    public static implicit operator Texture2D(Texture texture) => texture.raylibTexture;

    private static string GetPngPath(string imagePath)
    {
        if (!Directory.Exists("Res/Cherris/Temporary"))
        {
            Directory.CreateDirectory("Res/Temporary");
        }

        string pngPath = $"Res/Cherris/Temporary/{Path.GetFileNameWithoutExtension(imagePath)}.png";

        if (!File.Exists(pngPath))
        {
            //using var image = SixLabors.ImageSharp.Image.Load(imagePath);
            //image.SaveAsPng(pngPath);
        }

        return pngPath;
    }
}
</file>

<file path="Source\Scene\NodePropertySetter.cs">
namespace Cherris;

public static class NodePropertySetter
{
    private static readonly string[] SpecialProperties = { "type", "name", "path", "children", "Node" };

    public static void SetProperties(Node node, Dictionary<string, object> element, List<(Node, string, object)>? deferredNodeAssignments = null)
    {
        foreach ((string key, object value) in element)
        {
            if (SpecialProperties.Contains(key, StringComparer.OrdinalIgnoreCase))
            {
                continue;
            }

            SetNestedMember(node, key, value, deferredNodeAssignments);
        }
    }

    public static void SetNestedMember(object target, string memberPath, object value, List<(Node, string, object)>? deferredNodeAssignments = null)
    {
        string[] pathParts = memberPath.Split('/');
        object currentObject = target;

        for (var i = 0; i < pathParts.Length; i++)
        {
            var memberInfo = ReflectionUtils.GetMemberInfo(currentObject.GetType(), pathParts[i]);
            bool isFinalSegment = i == pathParts.Length - 1;

            if (isFinalSegment)
            {
                HandleFinalSegment(target, memberPath, currentObject, memberInfo, value, deferredNodeAssignments);
            }
            else
            {
                currentObject = GetOrCreateIntermediateObject(currentObject, memberInfo);
            }
        }
    }

    private static void HandleFinalSegment(object rootTarget, string memberPath, object currentObject, System.Reflection.MemberInfo memberInfo, object value, List<(Node, string, object)>? deferredAssignments)
    {
        var memberType = ReflectionUtils.GetMemberType(memberInfo);

        if (ShouldDeferAssignment(memberType, value))
        {
            if (rootTarget is Node nodeTarget)
            {
                deferredAssignments?.Add((nodeTarget, memberPath, value));
            }
            else
            {
                Log.Error($"Cannot defer assignment for non-Node root target type: {rootTarget.GetType().Name}");
            }
        }
        else
        {
            var convertedValue = ValueConversionUtils.ConvertValue(memberType, value);
            ReflectionUtils.SetMemberValue(currentObject, memberInfo, convertedValue);
        }
    }

    private static bool ShouldDeferAssignment(Type memberType, object value)
    {
        return memberType.IsSubclassOf(typeof(Node)) && value is string;
    }

    private static object GetOrCreateIntermediateObject(object currentObject, System.Reflection.MemberInfo memberInfo)
    {
        object? existingValue = ReflectionUtils.GetMemberValue(currentObject, memberInfo);

        if (existingValue != null)
        {
            return existingValue;
        }

        object newInstance = ReflectionUtils.CreateMemberInstance(memberInfo);

        ReflectionUtils.SetMemberValue(currentObject, memberInfo, newInstance);

        return newInstance;
    }
}
</file>

<file path="Source\Scene\PackedScene.cs">
using System.Reflection;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;
using System.Linq; // Added for LINQ methods like FirstOrDefault

namespace Cherris;

public sealed class PackedScene(string path)
{
    private readonly string _path = path;
    private static readonly IDeserializer _deserializer = new DeserializerBuilder()
        .WithNamingConvention(PascalCaseNamingConvention.Instance) // Changed from CamelCase
        .Build();

    public T Instantiate<T>() where T : Node
    {
        var deferredNodeAssignments = new List<(Node, string, object)>();
        var namedNodes = new Dictionary<string, Node>();

        string yamlContent = File.ReadAllText(_path);
        var rootElement = _deserializer.Deserialize<Dictionary<string, object>>(yamlContent);
        Node rootNode = (T)ParseNode(rootElement, null, deferredNodeAssignments, namedNodes);
        AssignDeferredNodes(deferredNodeAssignments, namedNodes);
        return (T)rootNode;
    }

    private Node ParseNode(Dictionary<string, object> element, Node? parent, List<(Node, string, object)> deferredNodeAssignments, Dictionary<string, Node> namedNodes)
    {
        var node = CreateNodeInstance(element);
        ProcessNestedScene(element, ref node);
        SetNodeProperties(element, node, deferredNodeAssignments);
        AddToParent(parent, node);
        RegisterNode(node, namedNodes);
        ProcessChildNodes(element, node, deferredNodeAssignments, namedNodes);
        return node;
    }

    private static Node CreateNodeInstance(Dictionary<string, object> element)
    {
        if (!element.TryGetValue("Node", out var nodeDescriptorObj))
            throw new KeyNotFoundException("Element is missing the 'Node' key.");
        var nodeDescriptor = (string)nodeDescriptorObj;
        var parts = nodeDescriptor.Split(["::"], StringSplitOptions.None);
        if (parts.Length != 2)
            throw new FormatException($"Invalid Node descriptor '{nodeDescriptor}'. Expected 'Type::Name'.");

        var typeNameToResolve = parts[0]; // e.g., "MainScene"
        var nodeInstanceName = parts[1];

        // Use our enhanced type resolution.
        Type? nodeType = FindTypeByNameInRelevantAssemblies(typeNameToResolve);

        if (nodeType == null)
        {
            // If our method fails, give TypeResolverUtils a chance, as it might have other logic (e.g. aliases)
            // However, the error implies TypeResolverUtils is already failing for this case.
            try
            {
                nodeType = TypeResolverUtils.ResolveType(typeNameToResolve);
            }
            catch (Exception ex)
            {
                // Assuming Log class is available as used in ReflectionUtils
                // Log.Warning($"[PackedScene] TypeResolverUtils also failed to find type '{typeNameToResolve}': {ex.Message}");
            }
        }

        if (nodeType == null)
        {
            throw new InvalidOperationException($"Type '{typeNameToResolve}' not found. Searched entry assembly, core assembly, all loaded assemblies, and via TypeResolverUtils.");
        }

        var node = (Node)Activator.CreateInstance(nodeType)!;
        node.Name = nodeInstanceName;
        return node;
    }

    private static Type? FindTypeByNameInRelevantAssemblies(string simpleOrFullName)
    {
        // Strategy:
        // 1. Try direct resolution (for fully qualified names or well-known types that Type.GetType can handle)
        Type? foundType = Type.GetType(simpleOrFullName, throwOnError: false, ignoreCase: true);
        if (foundType != null) return foundType;

        // 2. Search Entry Assembly (typically user's game/app assembly)
        Assembly? entryAssembly = Assembly.GetEntryAssembly();
        if (entryAssembly != null)
        {
            try
            {
                foundType = entryAssembly.GetTypes().FirstOrDefault(t => t.Name.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase) || (t.FullName != null && t.FullName.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase)));
                if (foundType != null) return foundType;
            }
            catch (ReflectionTypeLoadException) { /* Ignore assembly if types cannot be loaded */ }
        }

        // 3. Search Core Cherris Assembly (where Node is defined)
        Assembly coreAssembly = typeof(Node).Assembly;
        if (coreAssembly != entryAssembly) // Avoid re-scanning if entry assembly is the core assembly
        {
            try
            {
                foundType = coreAssembly.GetTypes().FirstOrDefault(t => t.Name.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase) || (t.FullName != null && t.FullName.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase)));
                if (foundType != null) return foundType;
            }
            catch (ReflectionTypeLoadException) { /* Ignore assembly if types cannot be loaded */ }
        }

        // 4. Search all other loaded assemblies (as a broader fallback)
        foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
        {
            if (assembly == entryAssembly || assembly == coreAssembly) continue; // Already checked

            try
            {
                foundType = assembly.GetTypes().FirstOrDefault(t => t.Name.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase) || (t.FullName != null && t.FullName.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase)));
                if (foundType != null) return foundType;
            }
            catch (ReflectionTypeLoadException)
            {
                // Some assemblies might fail to load types, ignore them and continue.
            }
        }
        return null; // Type not found through these prioritized searches
    }


    private static void ProcessNestedScene(Dictionary<string, object> element, ref Node node)
    {
        if (element.TryGetValue("path", out var pathValue))
        {
            if (!element.TryGetValue("Node", out var nodeDescriptorObj))
                throw new KeyNotFoundException("Element with 'path' is missing the 'Node' key.");
            var nodeDescriptor = (string)nodeDescriptorObj;
            var parts = nodeDescriptor.Split(new[] { "::" }, StringSplitOptions.None);
            if (parts.Length != 2)
                throw new FormatException($"Invalid Node descriptor '{nodeDescriptor}'. Expected 'Type::Name'.");
            var nodeName = parts[1];

            var scenePath = (string)pathValue;
            var nestedScene = new PackedScene(scenePath);
            node = nestedScene.Instantiate<Node>();
            node.Name = nodeName;
        }
    }

    private static void SetNodeProperties(Dictionary<string, object> element, Node node, List<(Node, string, object)> deferredNodeAssignments)
    {
        Dictionary<string, object> properties = element
            .Where(kvp => !IsReservedKey(kvp.Key))
            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

        NodePropertySetter.SetProperties(node, properties, deferredNodeAssignments);
    }

    private static bool IsReservedKey(string key)
    {
        return key is "children" or "Node" or "path";
    }

    private static void AddToParent(Node? parent, Node node)
    {
        parent?.AddChild(node, node.Name);
    }

    private static void RegisterNode(Node node, Dictionary<string, Node> namedNodes)
    {
        namedNodes[node.Name] = node;
    }

    private void ProcessChildNodes(Dictionary<string, object> element, Node parentNode, List<(Node, string, object)> deferredNodeAssignments, Dictionary<string, Node> namedNodes)
    {
        if (!element.TryGetValue("children", out var childrenObj)) return;
        var children = ConvertChildrenToList(childrenObj);
        foreach (var child in children)
        {
            if (child is Dictionary<object, object> childDict)
            {
                var convertedChild = ConvertChildDictionary(childDict);
                ParseNode(convertedChild, parentNode, deferredNodeAssignments, namedNodes);
            }
        }
    }

    private static List<object> ConvertChildrenToList(object childrenObj)
    {
        return childrenObj is List<object> list ? list : [];
    }

    private static Dictionary<string, object> ConvertChildDictionary(Dictionary<object, object> childDict)
    {
        return childDict.ToDictionary(kvp => kvp.Key.ToString()!, kvp => kvp.Value);
    }

    private void AssignDeferredNodes(List<(Node, string, object)> deferredNodeAssignments, Dictionary<string, Node> namedNodes)
    {
        foreach (var (targetNode, memberPath, nodePath) in deferredNodeAssignments)
        {
            AssignDeferredNode(targetNode, memberPath, nodePath, namedNodes);
        }
    }

    private void AssignDeferredNode(Node targetNode, string memberPath, object nodePath, Dictionary<string, Node> namedNodes)
    {
        string[] pathParts = memberPath.Split('/');
        object currentObject = targetNode;

        for (int i = 0; i < pathParts.Length; i++)
        {
            string part = pathParts[i];
            Type currentType = currentObject.GetType();
            (MemberInfo? memberInfo, object? nextObject) = GetMemberAndNextObject(currentType, part, currentObject);
            if (i == pathParts.Length - 1)
            {
                AssignNodeToMember(memberInfo, currentObject, nodePath, targetNode, namedNodes);
            }
            else
            {
                currentObject = nextObject!;
            }
        }
    }

    private static (MemberInfo?, object?) GetMemberAndNextObject(Type type, string memberName, object currentObject)
    {
        PropertyInfo? propertyInfo = type.GetProperty(memberName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        if (propertyInfo != null)
        {
            object? nextObject = propertyInfo.GetValue(currentObject) ?? Activator.CreateInstance(propertyInfo.PropertyType);
            propertyInfo.SetValue(currentObject, nextObject);
            return (propertyInfo, nextObject);
        }

        FieldInfo? fieldInfo = type.GetField(memberName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        if (fieldInfo != null)
        {
            object? nextObject = fieldInfo.GetValue(currentObject) ?? Activator.CreateInstance(fieldInfo.FieldType);
            fieldInfo.SetValue(currentObject, nextObject);
            return (fieldInfo, nextObject);
        }

        throw new Exception($"Member '{memberName}' not found on type '{type.Name}'.");
    }

    private static void AssignNodeToMember(MemberInfo? memberInfo, object targetObject, object nodePath, Node targetNode, Dictionary<string, Node> namedNodes)
    {
        if (memberInfo is PropertyInfo propertyInfo && propertyInfo.PropertyType.IsSubclassOf(typeof(Node)))
        {
            Node referencedNode = ResolveNodePath(nodePath, namedNodes, targetNode);
            propertyInfo.SetValue(targetObject, referencedNode);
        }
        else if (memberInfo is FieldInfo fieldInfo && fieldInfo.FieldType.IsSubclassOf(typeof(Node)))
        {
            Node referencedNode = ResolveNodePath(nodePath, namedNodes, targetNode);
            fieldInfo.SetValue(targetObject, referencedNode);
        }
        else
        {
            throw new Exception($"Member '{memberInfo?.Name}' is not a Node-derived type.");
        }
    }

    private static Node ResolveNodePath(object nodePath, Dictionary<string, Node> namedNodes, Node targetNode)
    {
        if (nodePath is string pathString)
        {
            return namedNodes.TryGetValue(pathString, out Node? node)
                ? node
                : targetNode.GetNode<Node>(pathString);
        }

        throw new Exception($"Unsupported node path type: {nodePath.GetType()}");
    }
}
</file>

<file path="Source\Scene\PackedSceneXml.cs">
using System.Xml.Linq;
using System.Reflection;
using System.Globalization;

namespace Cherris;

public sealed class PackedSceneXml(string path)
{
    private readonly string _path = path;

    public T Instantiate<T>() where T : Node
    {
        var doc = XDocument.Load(_path);
        var rootElement = doc.Root;

        if (rootElement == null || rootElement.Name != "Node")
            throw new Exception($"Invalid root element in scene file '{_path}'");

        var rootNode = (T)LoadNode(rootElement);
        return rootNode;
    }

    private Node LoadNode(XElement element)
    {
        // Get the node name attribute (required)
        string nodeName = element.Attribute("name")?.Value
            ?? throw new Exception($"Missing 'name' attribute on element <{element.Name}>");

        // Use the element's tag name as the type name
        string nodeType = element.Name.LocalName;

        var node = CreateNodeInstance(nodeType);
        node.Name = nodeName;

        // Load child nodes:
        // Children are all elements which are NOT recognized as properties (like Position, Scale, etc.)
        foreach (var childElement in element.Elements())
        {
            // Check if the child element is a property or a node:
            if (IsPropertyElement(childElement.Name.LocalName))
            {
                // This is a property element, set property on this node
                SetNodeProperty(node, childElement);
            }
            else
            {
                // Otherwise, treat it as a child node
                var childNode = LoadNode(childElement);
                node.AddChild(childNode, childNode.Name);
            }
        }

        return node;
    }

    private static bool IsPropertyElement(string elementName)
    {
        // List your known property names here; you can add more as needed
        return elementName == "Position" ||
               elementName == "Scale" ||
               elementName == "Size" ||
               elementName == "FilePath" ||
               elementName == "AutoPlay" ||
               elementName == "Text";
    }

    private void SetNodeProperty(Node node, XElement element)
    {
        string propertyName = element.Name.LocalName;
        var propertyInfo = node.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);

        if (propertyInfo == null)
            return; // Property not found on node, silently skip or log if you want

        if (propertyInfo.PropertyType == typeof(Vector2))
        {
            float x = float.Parse(element.Attribute("x")?.Value ?? "0", CultureInfo.InvariantCulture);
            float y = float.Parse(element.Attribute("y")?.Value ?? "0", CultureInfo.InvariantCulture);
            propertyInfo.SetValue(node, new Vector2(x, y));
        }
        else if (propertyInfo.PropertyType == typeof(bool))
        {
            propertyInfo.SetValue(node, bool.Parse(element.Value));
        }
        else if (propertyInfo.PropertyType == typeof(string))
        {
            propertyInfo.SetValue(node, element.Value);
        }
        else
        {
            object converted = Convert.ChangeType(element.Value, propertyInfo.PropertyType, CultureInfo.InvariantCulture);
            propertyInfo.SetValue(node, converted);
        }
    }

    private static Node CreateNodeInstance(string typeName)
    {
        // You may need to fully qualify the type name if it's in a namespace:
        // For example: "Cherris.HSlider"
        // So you might want to prepend your namespace if missing:
        if (!typeName.Contains('.'))
        {
            typeName = "Cherris." + typeName;
        }

        var type = Type.GetType(typeName)
                   ?? throw new Exception($"Unknown node type: '{typeName}'");

        return Activator.CreateInstance(type) as Node
               ?? throw new Exception($"Could not create instance of type '{typeName}'");
    }
}
</file>

<file path="Source\Scene\ReflectionUtils.cs">
using System.Reflection;

namespace Cherris;

public static class ReflectionUtils
{
    private const BindingFlags MemberBindingFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;

    public static MemberInfo GetMemberInfo(Type type, string memberName)
    {
        MemberInfo[] allMembers = type.GetMember(memberName, MemberBindingFlags | BindingFlags.IgnoreCase);

        if (allMembers.Length == 0)
        {
            throw new InvalidOperationException($"Member '{memberName}' not found on type '{type.Name}'");
        }

        if (allMembers.Length > 1)
        {
            var property = allMembers.OfType<PropertyInfo>().FirstOrDefault();
            if (property is not null)
            {
                return property;
            }

            var field = allMembers.OfType<FieldInfo>().FirstOrDefault();
            if (field != null)
            {
                return field;
            }

            Log.Error($"[GetMemberInfo] Ambiguity detected for member '{memberName}' on type '{type.Name}'. Found {allMembers.Length} members:");
            foreach (MemberInfo m in allMembers)
            {
                string memberTypeName = m switch { PropertyInfo p => p.PropertyType.Name, FieldInfo f => f.FieldType.Name, _ => m.MemberType.ToString() };
                Log.Error($"  - Name: {m.Name}, Kind: {m.MemberType}, Type: {memberTypeName}, Declared by: {m.DeclaringType?.FullName}");
            }

            throw new AmbiguousMatchException($"Ambiguous match found for member '{memberName}' on type '{type.Name}'.");
        }

        return allMembers[0];
    }

    public static Type GetMemberType(MemberInfo memberInfo)
    {
        return memberInfo switch
        {
            PropertyInfo p => p.PropertyType,
            FieldInfo f => f.FieldType,
            _ => throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'")
        };
    }

    public static object? GetMemberValue(object target, MemberInfo memberInfo)
    {
        return memberInfo switch
        {
            PropertyInfo p => p.GetValue(target),
            FieldInfo f => f.GetValue(target),
            _ => throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'")
        };
    }

    public static void SetMemberValue(object target, MemberInfo memberInfo, object value)
    {
        switch (memberInfo)
        {
            case PropertyInfo p:
                try
                {
                    p.SetValue(target, value);
                }
                catch (Exception ex)
                {
                    Log.Error($"Failed setting property '{p.Name}' on '{target.GetType().Name}': {ex.Message}");
                    throw;
                }
                break;

            case FieldInfo f:
                try
                {
                    f.SetValue(target, value);
                }
                catch (Exception ex)
                {
                    Log.Error($"Failed setting field '{f.Name}' on '{target.GetType().Name}': {ex.Message}");
                    throw;
                }
                break;

            default:
                throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'");
        }
    }

    public static object CreateMemberInstance(MemberInfo memberInfo)
    {
        Type typeToCreate = memberInfo switch
        {
            PropertyInfo p => p.PropertyType,
            FieldInfo f => f.FieldType,
            _ => throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'")
        };

        return Activator.CreateInstance(typeToCreate) ?? throw new InvalidOperationException($"Failed to create instance of {typeToCreate.Name}");
    }
}
</file>

<file path="Source\Scene\SceneTree.cs">
using System.Runtime.CompilerServices;

namespace Cherris;

public sealed class SceneTree
{
    public static SceneTree Instance { get; } = new();

    public Node? RootNode { get; set; }
    public bool Paused { get; set; }

    private readonly ConditionalWeakTable<Node, object> readyNodes = [];
    private readonly List<SceneTreeTimer> timers = [];
    private readonly List<Tween> activeTweens = [];

    private SceneTree() { }

    public void Process()
    {
        if (RootNode is null)
        {
            return;
        }

        ProcessNode(RootNode);

        ProcessTweens();

        if (!Paused)
        {
            ProcessTimers();
        }
    }

    public void RenderScene(DrawingContext context)
    {
        if (RootNode is null)
        {
            return;
        }

        RenderNode(RootNode, context);
    }

    private void ProcessNode(Node node)
    {
        if (node is null || !node.Active)
        {
            return;
        }

        Node.ProcessMode effectiveMode = ComputeEffectiveProcessMode(node);
        bool shouldProcess = ShouldProcess(effectiveMode);

        if (shouldProcess)
        {
            EnsureNodeReady(node);
            node.ProcessBegin();
            node.Process();
        }


        var childrenToProcess = new List<Node>(node.Children);
        foreach (Node child in childrenToProcess)
        {
            ProcessNode(child);
        }

        if (shouldProcess)
        {
            node.ProcessEnd();
        }
    }

    private void EnsureNodeReady(Node node)
    {
        if (!readyNodes.TryGetValue(node, out _))
        {
            node.Ready();
            readyNodes.Add(node, null);
        }
    }

    private static Node.ProcessMode ComputeEffectiveProcessMode(Node node)
    {
        if (node.ProcessingMode != Node.ProcessMode.Inherit)
        {
            return node.ProcessingMode;
        }

        Node? current = node.Parent;

        while (current != null)
        {
            if (current.ProcessingMode != Node.ProcessMode.Inherit)
            {
                return current.ProcessingMode;
            }

            current = current.Parent;
        }

        return Node.ProcessMode.Pausable;
    }

    private bool ShouldProcess(Node.ProcessMode mode) => mode switch
    {
        Node.ProcessMode.Disabled => false,
        Node.ProcessMode.Always => true,
        Node.ProcessMode.Pausable => !Paused,
        Node.ProcessMode.WhenPaused => Paused,
        _ => false
    };

    private static void RenderNode(Node node, DrawingContext context)
    {

        if (node is WindowNode)
        {

            return;
        }

        if (node is VisualItem { Visible: true } visualItem)
        {
            visualItem.Draw(context);
        }


        var childrenToRender = new List<Node>(node.Children);
        foreach (Node child in childrenToRender)
        {
            RenderNode(child, context);
        }
    }

    public SceneTreeTimer CreateTimer(float time)
    {
        SceneTreeTimer timer = new(time);
        timers.Add(timer);
        return timer;
    }

    public void RemoveTimer(SceneTreeTimer timer)
    {
        timers.Remove(timer);
    }

    private void ProcessTimers()
    {
        var timersToProcess = new List<SceneTreeTimer>(timers);
        foreach (SceneTreeTimer timer in timersToProcess)
        {
            timer.Process();
        }
    }

    public void ChangeScene(Node node)
    {
        RootNode?.Free();
        RootNode = node;
        readyNodes.Clear();
    }

    public Tween CreateTween(Node creatorNode, Node.ProcessMode processMode = Node.ProcessMode.Inherit)
    {
        Tween tween = new(creatorNode, processMode);
        activeTweens.Add(tween);
        return tween;
    }

    private void ProcessTweens()
    {
        var tweensToProcess = new List<Tween>(activeTweens);
        foreach (Tween tween in tweensToProcess)
        {
            if (!tween.Active)
            {
                activeTweens.Remove(tween);
                continue;
            }

            if (tween.ShouldProcess(Paused))
            {
                // TODO: Properly integrate Time.Delta or pass it
                tween.Update(Time.Delta);
            }

            if (!tween.Active)
            {
                activeTweens.Remove(tween);
            }
        }
    }
}
</file>

<file path="Source\Scene\SceneTreeTimer.cs">
namespace Cherris;

public class SceneTreeTimer(float waitTime)
{
    public float WaitTime { get; set; } = waitTime;
    private float timePassed = 0;

    public delegate void TimerEventHandler();
    public event TimerEventHandler? Timeout;

    public void Process()
    {
        //timePassed += Time.Delta;

        if (timePassed >= WaitTime)
        {
            Timeout?.Invoke();
            SceneTree.Instance.RemoveTimer(this);
        }
    }
}
</file>

<file path="Source\Scene\StringExtensions.cs">
namespace Cherris;

public static class StringExtensions
{
    public static string TrimQuotes(this string input)
    {
        if (input is null || input.Length < 2)
        {
            return input ?? "";
        }

        if ((input[0] == '"' && input[^1] == '"') || (input[0] == '\'' && input[^1] == '\''))
        {
            return input[1..^1];
        }

        return input;
    }
}
</file>

<file path="Source\Scene\TypeResolverUtils.cs">
using System.Reflection;

namespace Cherris;

public static class TypeResolverUtils
{
    public static Type ResolveType(string typeName)
    {
        Type? foundType = null;

        foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
        {
            foundType = assembly.GetType(typeName, false, true);

            if (foundType is not null)
            {
                break;
            }

            if (typeName.Contains('.'))
            {
                continue;
            }

            foundType = assembly.GetType($"Cherris.{typeName}", false, true);

            if (foundType != null)
            {
                break;
            }
        }

        return foundType ?? throw new TypeLoadException($"Type '{typeName}' not found in any loaded assembly.");
    }
}
</file>

<file path="Source\Scene\ValueConversionUtils.cs">
using System.Collections;
using System.Globalization;

namespace Cherris;

public static class ValueConversionUtils
{
    public static object ConvertValue(Type targetType, object value)
    {
        return value switch
        {
            Dictionary<object, object> dict => ConvertNestedObject(targetType, dict),
            IList list => ConvertList(targetType, list),
            _ => ConvertPrimitive(targetType, value)
        };
    }

    private static object ConvertNestedObject(Type targetType, Dictionary<object, object> dict)
    {
        object instance = Activator.CreateInstance(targetType)
            ?? throw new InvalidOperationException($"Failed to create {targetType.Name} instance");

        foreach (var (key, val) in dict)
        {
            string memberName = key.ToString() ?? throw new InvalidDataException("Dictionary key cannot be null");
            var memberInfo = ReflectionUtils.GetMemberInfo(targetType, memberName);
            var memberActualType = ReflectionUtils.GetMemberType(memberInfo);
            var convertedValue = ConvertValue(memberActualType, val);
            ReflectionUtils.SetMemberValue(instance, memberInfo, convertedValue);
        }

        return instance;
    }

    private static object ConvertList(Type targetType, IList list)
    {
        if (targetType == typeof(List<int>))
        {
            return list.Cast<object>().Select(Convert.ToInt32).ToList();
        }

        if (targetType == typeof(Vector2))
        {
            return ParseVector2(list);
        }

        if (targetType == typeof(Color))
        {
            return ParseColor(list);
        }

        if (targetType.IsGenericType && targetType.GetGenericTypeDefinition() == typeof(List<>))
        {
            Type itemType = targetType.GetGenericArguments()[0];
            var genericList = (IList)Activator.CreateInstance(targetType)!;

            foreach (object? item in list)
            {
                genericList.Add(Convert.ChangeType(item, itemType, CultureInfo.InvariantCulture));
            }

            return genericList;
        }

        throw new NotSupportedException($"Unsupported list conversion to type {targetType}");
    }

    private static object ConvertPrimitive(Type targetType, object value)
    {
        string stringValue = value?.ToString()?.TrimQuotes().Trim() ?? ""; // Added .Trim() here

        if (targetType.IsEnum)
        {
            // Pre-parse diagnostic logging specifically for AnchorPreset
            if (targetType.Name == "AnchorPreset") // Check against simple name first
            {
                string currentValidNames = string.Join(", ", Enum.GetNames(targetType));
                Log.Info($"[ValueConversionUtils] Attempting to parse for enum '{targetType.FullName}' (from Assembly: '{targetType.Assembly.FullName}'): Value='{stringValue}', Available Enum Names: [{currentValidNames}]");
            }

            try
            {
                return Enum.Parse(targetType, stringValue, true);
            }
            catch (ArgumentException ex) // Specifically catch ArgumentException from Enum.Parse
            {
                string validNames = string.Join(", ", Enum.GetNames(targetType));
                string assemblyName = targetType.Assembly.FullName ?? "Unknown Assembly";
                Log.Error($"[ValueConversionUtils] ArgumentException during Enum.Parse. Target Enum: '{targetType.FullName}' (from Assembly: '{assemblyName}'), Value: '{stringValue}', Message: '{ex.Message}'. Valid names for this enum: [{validNames}]");
                throw new InvalidOperationException($"Failed to parse enum '{targetType.FullName}' (from Assembly: '{assemblyName}') from value '{stringValue}'. Valid values are: [{validNames}]. Ensure no extra whitespace and correct casing (ignored).", ex);
            }
            catch (Exception ex) // Catch any other unexpected exceptions during enum parsing
            {
                string validNames = string.Join(", ", Enum.GetNames(targetType));
                string assemblyName = targetType.Assembly.FullName ?? "Unknown Assembly";
                Log.Error($"[ValueConversionUtils] Generic Exception during Enum.Parse. Target Enum: '{targetType.FullName}' (from Assembly: '{assemblyName}'), Value: '{stringValue}', Message: '{ex.Message}'. Valid names for this enum: [{validNames}]");
                throw new InvalidOperationException($"An unexpected error occurred while parsing enum '{targetType.FullName}' (from Assembly: '{assemblyName}') from value '{stringValue}'. Valid values are: [{validNames}].", ex);
            }
        }

        TypeCode typeCode = Type.GetTypeCode(targetType);

        try
        {
            switch (typeCode)
            {
                case TypeCode.Int32:
                    return int.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.UInt32:
                    return uint.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.Single:
                    return float.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.Double:
                    return double.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.Boolean:
                    return bool.Parse(stringValue);

                case TypeCode.String:
                    return stringValue; // Already trimmed and quotes handled
            }
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Failed to convert primitive value '{stringValue}' to type {targetType.Name}.", ex);
        }

        if (targetType == typeof(AudioStream))
        {
            return ResourceLoader.Load<AudioStream>(stringValue)!;
        }

        if (targetType == typeof(Sound))
        {
            return ResourceLoader.Load<Sound>(stringValue)!;
        }

        if (targetType == typeof(Animation))
        {
            return ResourceLoader.Load<Animation>(stringValue)!;
        }

        if (targetType == typeof(Texture))
        {
            return ResourceLoader.Load<Texture>(stringValue)!;
        }

        if (targetType == typeof(Font))
        {
            return ResourceLoader.Load<Font>(stringValue)!;
        }

        try
        {
            return Convert.ChangeType(stringValue, targetType, CultureInfo.InvariantCulture);
        }
        catch (Exception ex)
        {
            throw new NotSupportedException($"Unsupported primitive/resource type conversion from '{value?.GetType().Name ?? "null"}' to '{targetType.Name}' for value '{stringValue}'.", ex);
        }
    }

    private static Vector2 ParseVector2(IList list)
    {
        if (list.Count != 2)
        {
            throw new ArgumentException($"Vector2 requires exactly 2 elements, got {list.Count}");
        }

        try
        {
            var x = Convert.ToSingle(list[0], CultureInfo.InvariantCulture);
            var y = Convert.ToSingle(list[1], CultureInfo.InvariantCulture);
            return new Vector2(x, y);
        }
        catch (Exception ex)
        {
            throw new ArgumentException($"Failed to parse Vector2 elements: {ex.Message}", ex);
        }
    }

    private static Color ParseColor(IList list)
    {
        if (list.Count < 3 || list.Count > 4)
        {
            throw new ArgumentException($"Color requires 3 or 4 elements (R, G, B, [A]), got {list.Count}");
        }

        try
        {
            float r = ConvertToFloatColor(list[0]);
            float g = ConvertToFloatColor(list[1]);
            float b = ConvertToFloatColor(list[2]);
            float a = list.Count > 3 ? ConvertToFloatColor(list[3]) : 1.0f;

            return new Color(r, g, b, a);
        }
        catch (Exception ex)
        {
            throw new ArgumentException($"Failed to parse Color elements: {ex.Message}", ex);
        }
    }

    private static float ConvertToFloatColor(object component)
    {
        float value = Convert.ToSingle(component, CultureInfo.InvariantCulture);

        return value > 1.0f && value <= 255.0f
            ? value / 255.0f
            : float.Clamp(value, 0.0f, 1.0f);
    }
}
</file>

<file path="Source\Servers\ApplicationServer.cs">
using System.Reflection;
using YamlDotNet.Serialization;

namespace Cherris;

public sealed class ApplicationServer
{
    private static readonly Lazy<ApplicationServer> lazyInstance = new(() => new ApplicationServer());
    private MainAppWindow? mainWindow;
    private Configuration? applicationConfig;
    private readonly List<SecondaryWindow> secondaryWindows = new();

    private const string ConfigFilePath = "Res/Cherris/Config.yaml";
    private const string LogFilePath = "Res/Cherris/Log.txt";

    public static ApplicationServer Instance => lazyInstance.Value;

    private ApplicationServer()
    {

    }

    public IntPtr GetMainWindowHandle()
    {
        return mainWindow?.Handle ?? IntPtr.Zero;
    }

    public MainAppWindow? GetMainAppWindow()
    {
        return mainWindow;
    }

    public void Run()
    {
        if (!Start())
        {
            Log.Error("ApplicationCore failed to start.");
            return;
        }

        if (mainWindow is null)
        {
            Log.Error("Main window was not initialized.");
            return;
        }

        MainLoop();

        Log.Info("Main loop exited. Application exiting.");
        Cleanup();
    }

    private bool Start()
    {
        CreateLogFile();
        SetCurrentDirectory();

        applicationConfig = LoadConfig();
        if (applicationConfig is null)
        {
            Log.Error("Failed to load configuration.");
            return false;
        }

        try
        {
            mainWindow = new MainAppWindow(
                applicationConfig.Title,
                applicationConfig.Width,
                applicationConfig.Height);

            if (!mainWindow.TryCreateWindow())
            {
                Log.Error("Failed to create main window.");
                return false;
            }

            mainWindow.Closed += OnMainWindowClosed;

            ApplyConfig();

            if (!mainWindow.InitializeWindowAndGraphics())
            {
                Log.Error("Failed to initialize window graphics.");
                return false;
            }

            mainWindow.ShowWindow();
        }
        catch (Exception ex)
        {
            Log.Error($"Error during window initialization: {ex.Message}");
            return false;
        }

        return true;
    }

    private void MainLoop()
    {
        while (mainWindow != null && mainWindow.IsOpen)
        {
            ProcessSystemMessages();

            ClickServer.Instance.Process();
            SceneTree.Instance.Process();

            mainWindow.RenderFrame();
            RenderSecondaryWindows();

            Input.Update();
        }
    }

    private void ProcessSystemMessages()
    {
        while (NativeMethods.PeekMessage(out NativeMethods.MSG msg, IntPtr.Zero, 0, 0, NativeMethods.PM_REMOVE))
        {
            if (msg.message == NativeMethods.WM_QUIT)
            {
                Log.Info("WM_QUIT received, signaling application close.");
                mainWindow?.Close();
                break;
            }

            NativeMethods.TranslateMessage(ref msg);
            NativeMethods.DispatchMessage(ref msg);
        }
    }

    private void RenderSecondaryWindows()
    {
        List<SecondaryWindow> windowsToRender = new(secondaryWindows);

        foreach (SecondaryWindow window in windowsToRender)
        {
            if (window.IsOpen)
            {
                window.RenderFrame();
            }
            else
            {
                secondaryWindows.Remove(window);
            }
        }
    }

    private void OnMainWindowClosed()
    {
        Log.Info("Main window closed signal received. Closing secondary windows.");
        CloseAllSecondaryWindows();
    }

    private void Cleanup()
    {
        Log.Info("ApplicationCore Cleanup starting.");
        CloseAllSecondaryWindows();
        mainWindow?.Dispose();
        mainWindow = null;
        Log.Info("ApplicationCore Cleanup finished.");
    }

    private void CloseAllSecondaryWindows()
    {
        var windowsToClose = new List<SecondaryWindow>(secondaryWindows);
        foreach (var window in windowsToClose)
        {
            window.Close();
        }
    }

    internal void RegisterSecondaryWindow(SecondaryWindow window)
    {
        if (!secondaryWindows.Contains(window))
        {
            secondaryWindows.Add(window);
            Log.Info($"Registered secondary window: {window.Title}");
        }
    }

    internal void UnregisterSecondaryWindow(SecondaryWindow window)
    {
        if (secondaryWindows.Remove(window))
        {
            Log.Info($"Unregistered secondary window: {window.Title}");
        }
    }

    private static void SetRootNodeFromConfig(string scenePath)
    {
        if (string.IsNullOrEmpty(scenePath))
        {
            Log.Warning("MainScenePath is not defined in the configuration.");
            return;
        }

        try
        {
            var packedScene = new PackedScene(scenePath);
            SceneTree.Instance.RootNode = packedScene.Instantiate<Node>();
            Log.Info($"Loaded main scene: {scenePath}");
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to load main scene '{scenePath}': {ex.Message}");
            SceneTree.Instance.RootNode = new Node { Name = "ErrorRoot" };
        }
    }

    private static void CreateLogFile()
    {
        try
        {
            string? logDirectory = Path.GetDirectoryName(LogFilePath);
            if (!string.IsNullOrEmpty(logDirectory) && !Directory.Exists(logDirectory))
            {
                Directory.CreateDirectory(logDirectory);
            }

            if (File.Exists(LogFilePath))
            {
                File.Delete(LogFilePath);
            }

            using (File.Create(LogFilePath)) { }
            Log.Info($"Log file created at {Path.GetFullPath(LogFilePath)}");
        }
        catch (Exception ex)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"[FATAL] Failed to create log file: {ex.Message}");
            Console.ResetColor();
        }
    }

    private static void SetCurrentDirectory()
    {
        try
        {
            string? assemblyLocation = Assembly.GetEntryAssembly()?.Location;
            if (string.IsNullOrEmpty(assemblyLocation))
            {
                Log.Warning("Could not get assembly location.");
                return;
            }

            string? directoryName = Path.GetDirectoryName(assemblyLocation);
            if (string.IsNullOrEmpty(directoryName))
            {
                Log.Warning($"Could not get directory name from assembly location: {assemblyLocation}");
                return;
            }

            Environment.CurrentDirectory = directoryName;
            Log.Info($"Current directory set to: {directoryName}");
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to set current directory: {ex.Message}");
        }
    }

    private Configuration? LoadConfig()
    {
        if (!File.Exists(ConfigFilePath))
        {
            Log.Error($"Configuration file not found: {ConfigFilePath}");
            return null;
        }

        try
        {
            var deserializer = new DeserializerBuilder().Build();
            string yaml = File.ReadAllText(ConfigFilePath);
            var config = deserializer.Deserialize<Configuration>(yaml);
            Log.Info("Configuration loaded successfully.");
            return config;
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to load or parse configuration file '{ConfigFilePath}': {ex.Message}");
            return null;
        }
    }

    private void ApplyConfig()
    {
        if (applicationConfig is null)
        {
            Log.Error("Cannot apply configuration because it was not loaded.");
            return;
        }

        if (mainWindow != null)
        {
            mainWindow.BackdropType = applicationConfig.BackdropType;
            mainWindow.VSyncEnabled = applicationConfig.VSync;
        }

        SetRootNodeFromConfig(applicationConfig.MainScenePath);
    }
}
</file>

<file path="Source\Nodes\Ui\Button.cs">
using Vortice.Mathematics;

namespace Cherris;

public class Button : Control
{
    public enum ActionMode { Release, Press }
    public enum ClickBehavior { Left, Right, Both }

    private bool pressedLeft = false;
    private bool pressedRight = false;
    private bool wasHovered = false;
    private string displayedText = "";

    public Vector2 TextOffset { get; set; } = Vector2.Zero;
    public HAlignment TextHAlignment { get; set; } = HAlignment.Center;
    public VAlignment TextVAlignment { get; set; } = VAlignment.Center;
    public ButtonStylePack Styles { get; set; } = new();
    public ActionMode LeftClickActionMode { get; set; } = ActionMode.Release;
    public ActionMode RightClickActionMode { get; set; } = ActionMode.Release;
    public ClickBehavior Behavior { get; set; } = ClickBehavior.Left;
    public float AvailableWidth { get; set; } = 0;
    public bool StayPressed { get; set; } = false;
    public bool ClipText { get; set; } = false;
    public bool AutoWidth { get; set; } = false;
    public Vector2 TextMargin { get; set; } = new(2, 2);
    public string Ellipsis { get; set; } = "...";
    public Texture? Icon { get; set; } = null;
    public float IconMargin { get; set; } = 12;
    public Sound? ClickSound { get; set; }
    public Sound? HoverSound { get; set; }

    public string Text
    {
        get;

        set
        {
            if (field == value)
            {
                return;
            }

            field = value;
            displayedText = value;
        }
    } = "";

    public event Action? LeftClicked;
    public event Action? RightClicked;
    public event Action? MouseEntered;
    public event Action? MouseExited;

    public Button()
    {
        Size = new(100, 26);
        Offset = Vector2.Zero;
        OriginPreset = OriginPreset.None;

        WasDisabled += (button) =>
        {
            Styles.Current = Disabled
            ? Styles.Disabled
            : Styles.Normal;
        };
    }

    public override void Process()
    {
        base.Process();

        if (Disabled)
        {
            return;
        }

        HandleClicks();
        HandleKeyboardInput();
    }

    protected virtual void OnEnterPressed() { }

    private void HandleKeyboardInput()
    {
        bool enterPressed = Input.IsKeyPressed(KeyCode.Enter);

        if (!Focused || !enterPressed)
        {
            return;
        }

        bool invoked = false;
        if (Behavior == ClickBehavior.Left || Behavior == ClickBehavior.Both)
        {
            LeftClicked?.Invoke();
            invoked = true;
        }

        if (Behavior == ClickBehavior.Right || Behavior == ClickBehavior.Both)
        {
            RightClicked?.Invoke();
            invoked = true;
        }

        if (invoked)
        {
            ClickSound?.Play(AudioBus);
            OnEnterPressed();
        }
    }

    private void HandleClicks()
    {
        bool isMouseOver = IsMouseOver();
        bool leftClickInvoked = false;
        bool rightClickInvoked = false;

        if (Behavior == ClickBehavior.Left || Behavior == ClickBehavior.Both)
        {
            leftClickInvoked = HandleSingleClick(
                ref pressedLeft,
                MouseButtonCode.Left,
                LeftClickActionMode,
                LeftClicked);
        }

        if (Behavior == ClickBehavior.Right || Behavior == ClickBehavior.Both)
        {
            rightClickInvoked = HandleSingleClick(
                ref pressedRight,
                MouseButtonCode.Right,
                RightClickActionMode,
                RightClicked);
        }

        HandleHover(isMouseOver);
        UpdateTheme(isMouseOver, pressedLeft || pressedRight);
    }

    private bool HandleSingleClick(ref bool pressedState, MouseButtonCode button, ActionMode mode, Action? handler)
    {
        bool invoked = false;
        bool mouseOver = IsMouseOver();
        bool buttonPressedThisFrame = Input.IsMouseButtonPressed(button);
        bool buttonReleasedThisFrame = Input.IsMouseButtonReleased(button);

        if (mouseOver && buttonPressedThisFrame && !Disabled)
        {
            pressedState = true;
            HandleClickFocus();

            if (mode == ActionMode.Press)
            {
                handler?.Invoke();
                ClickSound?.Play(AudioBus);
                invoked = true;
            }
        }

        if (!buttonReleasedThisFrame || !pressedState)
        {
            return invoked;
        }

        if (!Disabled && mouseOver && mode == ActionMode.Release)
        {
            handler?.Invoke();
            ClickSound?.Play(AudioBus);
            invoked = true;
        }

        if (!StayPressed)
        {
            pressedState = false;
        }
        else if (!mouseOver && mode == ActionMode.Release)
        {
            pressedState = false;
        }
        else if (mode == ActionMode.Press && !mouseOver)
        {
            pressedState = false;
        }

        return invoked;
    }

    private void HandleHover(bool isMouseOver)
    {
        if (Disabled)
        {
            if (wasHovered)
            {
                wasHovered = false;
                MouseExited?.Invoke();
            }

            return;
        }

        if (isMouseOver && !wasHovered)
        {
            MouseEntered?.Invoke();
            HoverSound?.Play(AudioBus);
            wasHovered = true;
        }
        else if (wasHovered)
        {
            wasHovered = false;
            MouseExited?.Invoke();
        }
    }

    private void UpdateTheme(bool isMouseOver, bool isPressedForStayPressed)
    {
        if (Disabled)
        {
            Styles.Current = Styles.Disabled;
            return;
        }

        bool isLeftDown = (Behavior == ClickBehavior.Left || Behavior == ClickBehavior.Both) && Input.IsMouseButtonDown(MouseButtonCode.Left);
        bool isRightDown = (Behavior == ClickBehavior.Right || Behavior == ClickBehavior.Both) && Input.IsMouseButtonDown(MouseButtonCode.Right);

        bool isPhysicallyHeldDown = isMouseOver && (isLeftDown || isRightDown);

        if (isPressedForStayPressed && StayPressed)
        {
            Styles.Current = Styles.Pressed;
        }
        else if (isPhysicallyHeldDown)
        {
            Styles.Current = Styles.Pressed;
        }
        else if (Focused)
        {
            Styles.Current = isMouseOver ? Styles.Hover : Styles.Focused;
        }
        else if (isMouseOver)
        {
            Styles.Current = Styles.Hover;
        }
        else
        {
            Styles.Current = Styles.Normal;
        }
    }

    protected override void OnThemeFileChanged(string themeFile)
    {
        Log.Warning($"OnThemeFileChanged not fully implemented for Button: {themeFile}");
    }

    public override void Draw(DrawingContext context)
    {
        if (!Visible)
        {
            return;
        }

        DrawBackground(context);
        DrawText(context);
    }

    private void DrawBackground(DrawingContext context)
    {
        Vector2 position = GlobalPosition - Origin;
        Vector2 size = ScaledSize;
        Rect bounds = new(position.X, position.Y, size.X, size.Y);

        DrawStyledRectangle(context, bounds, Styles.Current);
    }

    private void DrawIcon(DrawingContext context)
    {
        if (Icon is null || context.RenderTarget is null)
        {
            return;
        }

        Log.Warning("DrawIcon is not implemented.");
    }

    private void DrawText(DrawingContext context)
    {
        if (Styles.Current is null) return;

        Vector2 position = GlobalPosition - Origin;
        Vector2 size = ScaledSize;

        var textLayoutRect = new Rect(
            position.X + TextMargin.X + TextOffset.X,
            position.Y + TextMargin.Y + TextOffset.Y,
            Math.Max(0, size.X - TextMargin.X * 2),
            Math.Max(0, size.Y - TextMargin.Y * 2)
        );

        DrawFormattedText(
            context,
            displayedText,
            textLayoutRect,
            Styles.Current,
            TextHAlignment,
            TextVAlignment
        );
    }

    private void ResizeToFitText()
    {
        if (!AutoWidth || Styles?.Current is null)
        {
            return;
        }

        Log.Warning("ResizeToFitText requires DirectWrite implementation.");
    }

    private void ClipDisplayedText()
    {
        if (!ClipText || string.IsNullOrEmpty(Text) || Styles?.Current is null)
        {
            displayedText = Text;
            return;
        }

        Log.Warning("ClipDisplayedText requires DirectWrite implementation.");

        displayedText = Text;
    }

    private string GetTextClippedWithEllipsis(string input)
    {
        if (input.Length > Ellipsis.Length)
        {
            return input.Substring(0, input.Length - Ellipsis.Length) + Ellipsis;
        }
        return input;
    }
}
</file>

<file path="Source\Resources\Cache\AnimationCache.cs">
namespace Cherris;

public class AnimationCache
{
    private static AnimationCache? _instance;
    public static AnimationCache Instance => _instance ??= new AnimationCache();

    private readonly Dictionary<string, Animation> animations = [];

    private AnimationCache() { }

    public Animation Get(string animationPath)
    {
        if (animations.TryGetValue(animationPath, out Animation? animation))
        {
            return animation;
        }

        Animation newAnimation = new(animationPath);
        return newAnimation;
    }

    public void Dispose()
    {
        animations.Clear();
    }
}
</file>

<file path="Source\Resources\Cache\AudioStreamCache.cs">
namespace Cherris;

public class AudioStreamCache
{
    public static AudioStreamCache? Instance => field ??= new();

    private readonly Dictionary<string, AudioStream?> audioStreams = [];

    private AudioStreamCache() { }

    public AudioStream? Get(string filePath)
    {
        if (audioStreams.TryGetValue(filePath, out AudioStream? audio))
        {
            return audio;
        }

        AudioStream? newAudio = AudioStream.Load(filePath);

        if (newAudio is null)
        {
            Log.Error($"Could not load audio stream: {filePath}");
            return null;
        }

        audioStreams[filePath] = newAudio;
        return newAudio;
    }
}
</file>

<file path="Source\Resources\Cache\FontCache.cs">
namespace Cherris;

public sealed class FontCache
{
    public static FontCache? Instance => field ??= new();

    private readonly Dictionary<string, Font> fonts = [];

    private FontCache() { }

    public Font Get(string fontKey)
    {
        if (fonts.TryGetValue(fontKey, out Font? font))
        {
            return font;
        }

        (string fontPath, int fontSize) = ParseFontKey(fontKey);

        // Load the font and store it
        Font newFont = new(fontPath, fontSize);
        fonts.Add(fontKey, newFont);

        return newFont;
    }

    private static (string fontPath, int fontSize) ParseFontKey(string fontKey)
    {
        int colonIndex = fontKey.LastIndexOf(':');

        if (colonIndex == -1)
        {
            throw new ArgumentException($"Invalid font key format: {fontKey}. Expected format: 'FontPath:WindowSize'.");
        }

        string fontPath = fontKey[..colonIndex];
        string sizeString = fontKey[(colonIndex + 1)..];

        if (!int.TryParse(sizeString, out int fontSize))
        {
            throw new ArgumentException($"Invalid font size in: {fontKey}. WindowSize must be a valid integer.");
        }

        return (fontPath, fontSize);
    }
}
</file>

<file path="Source\Resources\Cache\ShaderCache.cs">
/*
namespace Cherris;

public class ShaderCache
{
    public static ShaderCache Instance { get; } = new();

    private readonly Dictionary<string, Shader?> shaders = [];

    private ShaderCache() { }

    public Shader? Get(string key)
    {
        if (shaders.TryGetValue(key, out Shader? shader))
        {
            return shader;
        }

        var newSound = Shad.Load(key);

        if (newSound is null)
        {
            Log.Error($"[SoundCache] Could not load sound: {key}");
        }

        shaders[key] = newSound;
        return newSound;
    }
}
*/
</file>

<file path="Source\Resources\Cache\SoundCache.cs">
namespace Cherris;

public class SoundCache
{
    public static SoundCache? Instance => field ??= new();

    private readonly Dictionary<string, Sound?> soundEffects = [];

    private SoundCache() { }

    public Sound? Get(string soundKey)
    {
        if (soundEffects.TryGetValue(soundKey, out Sound? soundEffect))
        {
            return soundEffect;
        }

        Sound? newSound = Sound.Load(soundKey);

        if (newSound is null)
        {
            Log.Error($"Could not load sound: {soundKey}");
        }

        soundEffects[soundKey] = newSound;
        return newSound;
    }
}
</file>

<file path="Source\Resources\Cache\TextureCache.cs">
namespace Cherris;

public sealed class TextureCache
{
    public static TextureCache? Instance => field ??= new();

    private readonly Dictionary<string, Texture> textures = [];

    private TextureCache() { }

    public Texture Get(string path)
    {
        if (textures.TryGetValue(path, out Texture? value))
        {
            return value;
        }

        Texture textureWrapper = new(path);
        textures[path] = textureWrapper;

        return textureWrapper;
    }

    public void Remove(string path)
    {
        if (textures.TryGetValue(path, out Texture? value))
        {
            //Raylib.UnloadTexture(value);
            textures.Remove(path);

            string pngPath = GetPngPath(path);

            if (pngPath != path && File.Exists(pngPath))
            {
                File.Delete(pngPath);
            }
        }
    }

    private string GetPngPath(string path)
    {
        string pngPath =
            Path.GetExtension(path).ToLower() == ".png" ?
            path :
            $"Res/Temporary/{Path.GetFileNameWithoutExtension(path)}.png";

        return pngPath;
    }
}
</file>

<file path="Source\Nodes\Ui\Slider\HSlider.cs">
using Vortice.Mathematics; // For Rect

namespace Cherris;

public class HSlider : Slider
{
    public HSliderDirection Direction { get; set; } = HSliderDirection.LeftToRight;

    protected override void CalculateTrackBounds()
    {
        // trackPosition is the top-left corner of the drawable slider area.
        // Since GlobalPosition is now the top-left of the Node2D's bounding box,
        // trackPosition can be set directly to GlobalPosition.
        trackPosition = GlobalPosition;

        // trackMin and trackMax are used for converting mouse position to slider value.
        // They should represent the clickable/effective range of the track itself.
        trackMin = trackPosition.X;
        // If the grabber's center can align with the track ends:
        trackMax = trackPosition.X + Size.X;
        // If the grabber must stay fully within track visually (for mouse interaction):
        // trackMax = trackPosition.X + Size.X - GrabberSize.X; (This might be too restrictive for value calculation)
        // Let ConvertPositionToValue and CalculateGrabberPosition handle clamping based on full Size.X range.
    }

    protected override void UpdateHoverStates()
    {
        Vector2 mousePos = GetLocalMousePosition();

        // Track hover: considers the whole Size of the slider, relative to its top-left (trackPosition)
        trackHovered = mousePos.X >= trackPosition.X &&
                       mousePos.X <= trackPosition.X + Size.X &&
                       mousePos.Y >= trackPosition.Y &&
                       mousePos.Y <= trackPosition.Y + Size.Y;

        // Grabber hover: uses actual grabber bounds
        Vector2 grabberTopLeftPos = CalculateGrabberPosition(); // This is top-left of grabber
        grabberHovered = mousePos.X >= grabberTopLeftPos.X &&
                         mousePos.X <= grabberTopLeftPos.X + GrabberSize.X &&
                         mousePos.Y >= grabberTopLeftPos.Y &&
                         mousePos.Y <= grabberTopLeftPos.Y + GrabberSize.Y;
    }

    protected override void HandleInput()
    {
        HandleMousePress();
        HandleMouseDrag();
        HandleMouseWheel();
    }

    private void HandleMousePress()
    {
        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            // Mouse position is already local to the window.
            // We need to check if it's within the slider's bounds (trackPosition to trackPosition + Size).
            float localMouseX = GetLocalMousePosition().X;

            if (trackHovered) // If clicked anywhere on the track (trackHovered already checks this)
            {
                // Clamp mouse X to be within the visual track extents for value calculation
                float clampedMouseXOnTrack = Math.Clamp(localMouseX, trackPosition.X, trackPosition.X + Size.X);
                Value = ConvertPositionToValue(clampedMouseXOnTrack);
                grabberPressed = true; // Start "dragging" immediately
                PlaySound();
            }
        }
        else if (Input.IsMouseButtonReleased(MouseButtonCode.Left))
        {
            grabberPressed = false;
        }
    }

    private void HandleMouseDrag()
    {
        if (!grabberPressed) return;

        if (Input.IsMouseButtonReleased(MouseButtonCode.Left)) // Check for release during drag
        {
            grabberPressed = false;
            return;
        }

        float localMouseX = GetLocalMousePosition().X;
        // Clamp mouse X to be within the visual track extents for value calculation
        float clampedMouseXOnTrack = Math.Clamp(localMouseX, trackPosition.X, trackPosition.X + Size.X);
        Value = ConvertPositionToValue(clampedMouseXOnTrack);
    }

    private void HandleMouseWheel()
    {
        if (!trackHovered && !grabberHovered) return; // Only respond if mouse is over slider

        float wheelDelta = Input.GetMouseWheelMovement();
        if (wheelDelta == 0) return;

        Value = ApplyStep(Value + (wheelDelta * Step * (Direction == HSliderDirection.LeftToRight ? 1 : -1)));
        PlaySound();
    }

    protected override float ConvertPositionToValue(float positionOnTrackInLocalSpace)
    {
        // positionOnTrackInLocalSpace is a local X coordinate (e.g., mouse.X)
        // effectiveTrackMin is the track's starting X coordinate (trackPosition.X)
        float effectiveTrackMin = trackPosition.X;
        float effectiveTrackWidth = Size.X;

        if (effectiveTrackWidth <= 0) return MinValue;

        // Normalize the position relative to the track's start and width
        float normalized = (positionOnTrackInLocalSpace - effectiveTrackMin) / effectiveTrackWidth;
        normalized = Math.Clamp(normalized, 0f, 1f);

        if (Direction == HSliderDirection.RightToLeft)
        {
            normalized = 1f - normalized;
        }

        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return ApplyStep(rawValue);
    }

    protected override void DrawForeground(DrawingContext context)
    {
        float range = MaxValue - MinValue;
        float fillRatio = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        fillRatio = Math.Clamp(fillRatio, 0f, 1f);

        float foregroundWidth = Size.X * fillRatio;
        Rect foregroundRect;

        // trackPosition is the top-left of the slider.
        if (Direction == HSliderDirection.RightToLeft)
        {
            foregroundRect = new Rect(
                trackPosition.X + Size.X - foregroundWidth, // Starts from the right and extends left
                trackPosition.Y,
                foregroundWidth,
                Size.Y
            );
        }
        else // LeftToRight
        {
            foregroundRect = new Rect(
                trackPosition.X, // Starts from the left
                trackPosition.Y,
                foregroundWidth,
                Size.Y
            );
        }

        if (foregroundRect.Width > 0 && foregroundRect.Height > 0)
        {
            DrawStyledRectangle(context, foregroundRect, Style.Foreground);
        }
    }

    protected override Vector2 CalculateGrabberPosition()
    {
        // Returns the TOP-LEFT position of the grabber.
        float range = MaxValue - MinValue;
        float normalizedValue = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        normalizedValue = Math.Clamp(normalizedValue, 0f, 1f);

        if (Direction == HSliderDirection.RightToLeft)
        {
            normalizedValue = 1f - normalizedValue;
        }

        // Calculate the CENTER X of where the grabber should be based on value.
        float grabberCenterX = trackPosition.X + normalizedValue * Size.X;

        // Calculate the TOP-LEFT X of the grabber.
        float grabberLeftX = grabberCenterX - GrabberSize.X / 2f;

        // Clamp grabber's top-left X to ensure it doesn't go visually outside the main track area
        // The grabber should appear to slide along the track.
        grabberLeftX = Math.Clamp(grabberLeftX, trackPosition.X, trackPosition.X + Size.X - GrabberSize.X);

        float yPos = trackPosition.Y + (Size.Y / 2f) - GrabberSize.Y / 2f; // Center grabber vertically within the track
        return new Vector2(grabberLeftX, yPos);
    }

    protected override void UpdateGrabberThemeVisuals()
    {
        if (Disabled)
        {
            Style.Grabber.Current = Style.Grabber.Disabled;
            return;
        }

        if (grabberPressed)
        {
            Style.Grabber.Current = Style.Grabber.Pressed;
        }
        else if (Focused)
        {
            // If focused, use Hover style if also hovered, otherwise Focused style.
            Style.Grabber.Current = grabberHovered ? Style.Grabber.Hover : Style.Grabber.Focused;
        }
        else if (grabberHovered)
        {
            Style.Grabber.Current = Style.Grabber.Hover;
        }
        else
        {
            Style.Grabber.Current = Style.Grabber.Normal;
        }
    }

    protected override void HandleKeyboardNavigation()
    {
        // Assumes Focused is true when called
        if (Input.IsActionPressed("UiLeft"))
        {
            Value = ApplyStep(Value - Step * (Direction == HSliderDirection.LeftToRight ? 1 : -1));
            PlaySound();
        }
        else if (Input.IsActionPressed("UiRight"))
        {
            Value = ApplyStep(Value + Step * (Direction == HSliderDirection.LeftToRight ? 1 : -1));
            PlaySound();
        }
    }
}
</file>

<file path="Source\Nodes\Ui\Slider\HSliderDirection.cs">
namespace Cherris;

public enum HSliderDirection
{
    LeftToRight,
    RightToLeft
}
</file>

<file path="Source\Nodes\Ui\Slider\Slider.cs">
using Vortice.Mathematics; // For Rect

namespace Cherris;

public abstract class Slider : Control
{
    // Add this property
    public bool SuppressValueChangedEvent { get; set; } = false;

    private float _value = 0.5f;
    public float Value
    {
        get => _value;
        set
        {
            float newValue = ApplyStep(value); // ApplyStep also clamps
            
            if (_value == newValue)
            {
                return;
            }

            _value = newValue;
            
            if (SuppressValueChangedEvent) // Check the flag
            {
                return;
            }

            ValueChanged?.Invoke(_value); // Invoke the event
        }
    }

    public float MinValue { get; set; } = 0f;
    public float MaxValue { get; set; } = 1f;
    public Sound? MoveSound { get; set; }
    public SliderStyle Style { get; set; } = new();
    public Vector2 GrabberSize { get; set; } = new(12, 24);

    protected bool grabberPressed;
    protected bool grabberHovered;
    protected bool trackHovered;
    protected Vector2 trackPosition;
    protected float trackMin;
    protected float trackMax;

    private float _step = 0.01f;
    public float Step
    {
        get => _step;
        set => _step = Math.Max(value, 0f);
    }

    public event Action<float>? ValueChanged; // Added event

    public Slider()
    {
        Size = new(200, 16);
        Focusable = true;
        Navigable = true;

        Style.Foreground.FillColor = DefaultTheme.Accent;
        Style.Foreground.Roundness = 0.2f;
        Style.Background.Roundness = 0.2f;
        Style.Grabber.Roundness = 0.5f;
        Style.Grabber.BorderLength = 1f;
        Style.Grabber.Normal.FillColor = DefaultTheme.NormalFill;
        Style.Grabber.Hover.FillColor = DefaultTheme.HoverFill;
        Style.Grabber.Pressed.FillColor = DefaultTheme.Accent;
        Style.Grabber.Focused.BorderColor = DefaultTheme.FocusBorder;
    }

    public override void Process()
    {
        base.Process();

        if (Disabled)
        {
            grabberPressed = false;
            UpdateGrabberThemeVisuals();
            return;
        }

        CalculateTrackBounds();
        UpdateHoverStates();

        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            HandleClickFocus();
        }

        HandleInput();

        if (Focused)
        {
            HandleKeyboardNavigation();
            OnFocusLost();
        }

        UpdateGrabberThemeVisuals();
    }

    protected Vector2 GetLocalMousePosition()
    {
        var owningWindowNode = GetOwningWindowNode();
        return owningWindowNode?.LocalMousePosition ?? Input.MousePosition;
    }

    protected abstract void HandleKeyboardNavigation();

    protected virtual void OnFocusLost()
    {
        if (Input.IsActionPressed("UiAccept") ||
            (Input.IsMouseButtonPressed(MouseButtonCode.Left) && !IsMouseOver()))
        {
            Focused = false;
        }
    }

    protected override void OnThemeFileChanged(string themeFile)
    {
        try
        {
            Style = FileLoader.Load<SliderStyle>(themeFile);
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to load SliderStyle from '{themeFile}': {ex.Message}");
        }
    }

    protected void PlaySound()
    {
        if (!Disabled)
        {
            MoveSound?.Play(AudioBus);
        }
    }

    protected abstract void CalculateTrackBounds();
    protected abstract void UpdateHoverStates();
    protected abstract void HandleInput();
    protected abstract void UpdateGrabberThemeVisuals();
    protected abstract float ConvertPositionToValue(float position);
    protected abstract void DrawForeground(DrawingContext context);
    protected abstract Vector2 CalculateGrabberPosition();

    protected float ApplyStep(float rawValue)
    {
        float clampedValue = Math.Clamp(rawValue, MinValue, MaxValue);

        if (Step <= 0 || MinValue >= MaxValue)
        {
            return clampedValue;
        }

        float steppedValue = MinValue + (float)Math.Round((clampedValue - MinValue) / Step) * Step;
        return Math.Clamp(steppedValue, MinValue, MaxValue);
    }

    public override void Draw(DrawingContext context)
    {
        if (!Visible) return;

        DrawBackground(context);
        DrawForeground(context);
        DrawGrabber(context);
    }

    private void DrawBackground(DrawingContext context)
    {
        var bounds = new Rect(trackPosition.X, trackPosition.Y, Size.X, Size.Y);
        DrawStyledRectangle(context, bounds, Style.Background);
    }

    private void DrawGrabber(DrawingContext context)
    {
        Vector2 grabberPos = CalculateGrabberPosition();
        ButtonStyle currentGrabberStyle = Style.Grabber.Current;

        var bounds = new Rect(grabberPos.X, grabberPos.Y, GrabberSize.X, GrabberSize.Y);
        DrawStyledRectangle(context, bounds, currentGrabberStyle);
    }

    protected override void HandleClickFocus()
    {
        if (Disabled || !Focusable) return;

        if (trackHovered || grabberHovered)
        {
            Focused = true;
        }
    }
}
</file>

<file path="Source\Nodes\Ui\Slider\SliderStyle.cs">
namespace Cherris;

public class SliderStyle
{
    public BoxStyle Background { get; set; } = new()
    {
        FillColor = DefaultTheme.DisabledFill, // Example default
        BorderColor = DefaultTheme.DisabledBorder
    };
    public BoxStyle Foreground { get; set; } = new()
    {
        FillColor = DefaultTheme.Accent, // Example default
        BorderColor = DefaultTheme.AccentBorder
    };
    public ButtonStylePack Grabber { get; set; } = new();
}
</file>

<file path="Source\Nodes\Ui\Slider\VSlider.cs">
using Vortice.Mathematics; // For Rect

namespace Cherris;

public class VSlider : Slider
{
    public VSliderDirection Direction { get; set; } = VSliderDirection.TopToBottom;

    public VSlider() // VSlider specific defaults
    {
        Size = new(16, 200); // Default tall and thin
        GrabberSize = new(24, 12); // Wider than tall for VSlider grabber
    }
    protected override void CalculateTrackBounds()
    {
        trackPosition = GlobalPosition - Origin;
        trackMin = trackPosition.Y;
        trackMax = trackPosition.Y + Size.Y;
    }

    protected override void UpdateHoverStates()
    {
        Vector2 mousePos = GetLocalMousePosition();

        trackHovered = mousePos.X >= trackPosition.X &&
                       mousePos.X <= trackPosition.X + Size.X &&
                       mousePos.Y >= trackPosition.Y &&
                       mousePos.Y <= trackPosition.Y + Size.Y;

        Vector2 grabberCenterPos = CalculateGrabberPosition();
        grabberHovered = mousePos.X >= grabberCenterPos.X &&
                         mousePos.X <= grabberCenterPos.X + GrabberSize.X &&
                         mousePos.Y >= grabberCenterPos.Y &&
                         mousePos.Y <= grabberCenterPos.Y + GrabberSize.Y;
    }

    protected override void HandleInput()
    {
        HandleMousePress();
        HandleMouseDrag();
        HandleMouseWheel();
    }

    private void HandleMousePress()
    {
        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            if (trackHovered)
            {
                float clampedMouseY = Math.Clamp(GetLocalMousePosition().Y, trackPosition.Y, trackPosition.Y + Size.Y);
                Value = ConvertPositionToValue(clampedMouseY);
                grabberPressed = true;
                PlaySound();
            }
        }
        else if (Input.IsMouseButtonReleased(MouseButtonCode.Left))
        {
            grabberPressed = false;
        }
    }

    private void HandleMouseDrag()
    {
        if (!grabberPressed) return;

        if (Input.IsMouseButtonReleased(MouseButtonCode.Left))
        {
            grabberPressed = false;
            return;
        }

        float clampedMouseY = Math.Clamp(GetLocalMousePosition().Y, trackPosition.Y, trackPosition.Y + Size.Y);
        Value = ConvertPositionToValue(clampedMouseY);
    }

    private void HandleMouseWheel()
    {
        if (!trackHovered && !grabberHovered) return;

        float wheelDelta = Input.GetMouseWheelMovement();
        if (wheelDelta == 0) return;

        // Positive wheelDelta for VSlider usually means increase value (scroll "down" the list, "up" the value)
        Value = ApplyStep(Value + (wheelDelta * Step * (Direction == VSliderDirection.TopToBottom ? 1 : -1)));
        PlaySound();
    }

    protected override float ConvertPositionToValue(float positionOnTrack)
    {
        float effectiveTrackMin = trackPosition.Y;
        float effectiveTrackHeight = Size.Y;

        if (effectiveTrackHeight <= 0) return MinValue;

        float normalized = (positionOnTrack - effectiveTrackMin) / effectiveTrackHeight;
        normalized = Math.Clamp(normalized, 0f, 1f);

        if (Direction == VSliderDirection.BottomToTop) // For BottomToTop, higher Y means lower value
        {
            normalized = 1f - normalized;
        }
        // For TopToBottom, higher Y means higher value (already handled by default normalization)


        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return ApplyStep(rawValue);
    }

    protected override void DrawForeground(DrawingContext context)
    {
        float range = MaxValue - MinValue;
        float fillRatio = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        fillRatio = Math.Clamp(fillRatio, 0f, 1f);

        float foregroundHeight = Size.Y * fillRatio;
        Rect foregroundRect;

        if (Direction == VSliderDirection.BottomToTop)
        {
            foregroundRect = new Rect(
                trackPosition.X,
                trackPosition.Y + Size.Y - foregroundHeight,
                Size.X,
                foregroundHeight
            );
        }
        else // TopToBottom
        {
            foregroundRect = new Rect(
                trackPosition.X,
                trackPosition.Y,
                Size.X,
                foregroundHeight
            );
        }

        if (foregroundRect.Width > 0 && foregroundRect.Height > 0)
        {
            DrawStyledRectangle(context, foregroundRect, Style.Foreground);
        }
    }

    protected override Vector2 CalculateGrabberPosition()
    {
        float range = MaxValue - MinValue;
        float normalizedValue = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        normalizedValue = Math.Clamp(normalizedValue, 0f, 1f);

        if (Direction == VSliderDirection.BottomToTop)
        {
            normalizedValue = 1f - normalizedValue;
        }

        float grabberCenterY = trackPosition.Y + normalizedValue * Size.Y;
        float grabberTopY = grabberCenterY - GrabberSize.Y / 2f;

        grabberTopY = Math.Clamp(grabberTopY, trackPosition.Y, trackPosition.Y + Size.Y - GrabberSize.Y);

        float xPos = trackPosition.X + (Size.X / 2f) - GrabberSize.X / 2f; // Center grabber horizontally
        return new Vector2(xPos, grabberTopY);
    }

    protected override void UpdateGrabberThemeVisuals()
    {
        if (Disabled)
        {
            Style.Grabber.Current = Style.Grabber.Disabled;
            return;
        }

        if (grabberPressed)
        {
            Style.Grabber.Current = Style.Grabber.Pressed;
        }
        else if (Focused)
        {
            Style.Grabber.Current = grabberHovered ? Style.Grabber.Hover : Style.Grabber.Focused;
        }
        else if (grabberHovered)
        {
            Style.Grabber.Current = Style.Grabber.Hover;
        }
        else
        {
            Style.Grabber.Current = Style.Grabber.Normal;
        }
    }

    protected override void HandleKeyboardNavigation()
    {
        if (Input.IsActionPressed("UiUp")) // Up arrow typically increases value for vertical controls
        {
            Value = ApplyStep(Value + Step * (Direction == VSliderDirection.TopToBottom ? -1 : 1)); // Inverted logic for TTB
            PlaySound();
        }
        else if (Input.IsActionPressed("UiDown")) // Down arrow decreases value
        {
            Value = ApplyStep(Value - Step * (Direction == VSliderDirection.TopToBottom ? -1 : 1)); // Inverted logic for TTB
            PlaySound();
        }
    }
}
</file>

<file path="Source\Nodes\Ui\Slider\VSliderDirection.cs">
namespace Cherris;

public enum VSliderDirection
{
    TopToBottom,
    BottomToTop
}
</file>

