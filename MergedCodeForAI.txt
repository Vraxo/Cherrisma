<file path="MainScene.cs">
using Cherris;

namespace Cherrisma;

public class MainScene : Node
{
    public override void Process()
    {
        base.Process();

        // The HSlider's position will now be determined by its AnchorPreset and Margin
        // properties, as defined in the Res/Main.yaml file.
        // The line below is removed to prevent overriding the declarative layout.
        // GetNode<HSlider>("Slider").Position = GetWindowSizeV2() / 2;
    }
}
</file>

<file path="Program.cs">
using Cherris;

namespace Cherrisma;

public sealed class EntryPoint
{
    public static void Main()
    {
        ApplicationServer.Instance.Run();
    }
}
</file>

<file path="Res\Main.yaml">
Node: MainScene::MainScene
children:
    - Node: LineEdit::LineEdit
      AnchorPreset: TopCenter
      MarginTop: 32
      RelativeWidth: 0.5

    - Node: HBoxContainer::ButtonContainer
      AnchorPreset: BottomCenter
      HAlignment: Center # HBoxContainer will center its content (the buttons)
      MarginBottom: 74
      Separation: 8
      children:
        - Node: Button::ButtonPrevious
          Text: "<"
          Size: [32, 32]
          HAlignment: Right # Ensures button's origin is (0,y)
          FocusNeighborRight: ../PlayPauseButton
          Styles:
            Roundness: 1
        - Node: Button::PlayPauseButton
          Text: "||"
          Size: [32, 32]
          HAlignment: Right # Ensures button's origin is (0,y)
          Styles:
            Roundness: 1
        - Node: Button::ButtonNext
          Text: ">"
          Size: [32, 32]
          HAlignment: Right # Ensures button's origin is (0,y)
          Styles:
            Roundness: 1

    - Node: HSlider::Slider
      AnchorPreset: BottomCenter
      Size: [300, 8]
      RelativeWidth: 0.5
      MarginBottom: 32
      GrabberSize: [24, 24]
      Style:
        Foreground:
          Roundness: 1
        Background:
          Roundness: 1
        Grabber:
          FillColor: [0, 0, 0, 0]
          BorderColor: [0, 0, 0, 0]
          Roundness: 1
</file>

<file path="Res\Cherris\Config.yaml">
Width: 950
Height: 750
MinWidth: 1280
MinHeight: 720
MaxWidth: -1
MaxHeight: -1
Title: Cheris
ResizableWindow: true
AntiAliasing: true
MainScenePath: Res/Main.yaml
Backend: Raylib
BackdropType: MicaAlt
VSync: false
</file>

<file path="Res\Main.yaml">

</file>

<file path="Source\AnchorPreset.cs">
namespace Cherris;

public enum AnchorPreset
{
    None,
    TopLeft,
    TopCenter,
    TopRight,
    CenterLeft,
    Center,
    CenterRight,
    BottomLeft,
    BottomCenter,
    BottomRight
}
</file>

<file path="Source\BoxStyle.cs">
using Vortice.Mathematics;

namespace Cherris;

public class BoxStyle
{
    public float Roundness { get; set; } = 0.2f;
    public Color4 FillColor { get; set; } = DefaultTheme.NormalFill;
    public Color4 BorderColor { get; set; } = DefaultTheme.NormalBorder;

    public float BorderLengthTop { get; set; } = 1.0f;
    public float BorderLengthRight { get; set; } = 1.0f;
    public float BorderLengthBottom { get; set; } = 1.0f;
    public float BorderLengthLeft { get; set; } = 1.0f;

    public float BorderLength
    {
        set
        {
            BorderLengthTop = value;
            BorderLengthRight = value;
            BorderLengthBottom = value;
            BorderLengthLeft = value;
        }
    }
}
</file>

<file path="Source\ButtonStyle.cs">
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace Cherris;

public class ButtonStyle : BoxStyle
{
    public Font? Font { get; set; } = null;
    public Color4 FontColor { get; set; } = DefaultTheme.Text;

    public string FontName { get; set; } = "Roboto Mono";
    public float FontSize { get; set; } = 16.0f;
    public FontWeight FontWeight { get; set; } = FontWeight.Normal;
    public FontStyle FontStyle { get; set; } = FontStyle.Normal;
    public FontStretch FontStretch { get; set; } = FontStretch.Normal;
    public WordWrapping WordWrapping { get; set; } = WordWrapping.WholeWord;
}
</file>

<file path="Source\ButtonStylePack.cs">
using System;
using System.Collections.Generic;
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace Cherris;

public sealed class ButtonStylePack
{
    public ButtonStyle Current { get; set; } = new();
    public ButtonStyle Normal { get; set; } = new();
    public ButtonStyle Hover { get; set; } = new();
    public ButtonStyle Pressed { get; set; } = new();
    public ButtonStyle Disabled { get; set; } = new();
    public ButtonStyle Focused { get; set; } = new();

    private IEnumerable<ButtonStyle> AllStyles => [Current, Normal, Hover, Pressed, Disabled, Focused];

    public ButtonStylePack()
    {
        Hover.FillColor = DefaultTheme.HoverFill;

        Pressed.FillColor = DefaultTheme.Accent;

        Disabled.FillColor = DefaultTheme.DisabledFill;
        Disabled.BorderColor = DefaultTheme.DisabledBorder;
        Disabled.FontColor = DefaultTheme.DisabledText;

        Focused.BorderColor = DefaultTheme.FocusBorder;
        Focused.BorderLength = 1;
    }

    public float FontSize
    {
        get;
        set
        {
            field = value;
            SetAll(s => s.FontSize = value);
        }
    } = 0;

    public Font Font
    {
        set => SetAll(s => s.Font = value);
    }

    public Color FontColor
    {
        set => SetAll(s => s.FontColor = value);
    }

    public float Roundness
    {
        set => SetAll(s => s.Roundness = value);
    }

    public float BorderLength
    {
        set => SetAll(s => s.BorderLength = value);
    }

    public Color FillColor
    {
        set => SetAll(s => s.FillColor = value);
    }

    public Color BorderColor
    {
        set => SetAll(s => s.BorderColor = value);
    }

    public float BorderLengthTop
    {
        set => SetAll(s => s.BorderLengthTop = value);
    }

    public float BorderLengthBottom
    {
        set => SetAll(s => s.BorderLengthBottom = value);
    }

    public WordWrapping WordWrapping
    {
        set => SetAll(s => s.WordWrapping = value);
    }

    private void SetAll(Action<ButtonStyle> setter)
    {
        foreach (ButtonStyle style in AllStyles)
        {
            setter(style);
        }
    }
}
</file>

<file path="Source\ClickServer.cs">
namespace Cherris;

public sealed class ClickServer
{
    public static ClickServer Instance { get; } = new();

    public int MinLayer = -1;

    private readonly List<Clickable> clickables = [];
    private const bool Debug = false;

    private ClickServer() { }

    public void Register(Clickable clickable)
    {
        clickables.Add(clickable);
    }

    public void Unregister(Clickable clickable)
    {
        clickables.Remove(clickable);
    }

    public void Process()
    {
        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            SignalClick(MouseButtonCode.Left);
        }

        if (Input.IsMouseButtonPressed(MouseButtonCode.Right))
        {
            SignalClick(MouseButtonCode.Right);
        }
    }

    public int GetHighestLayer()
    {
        int highestLayer = MinLayer;

        foreach (Clickable clickable in clickables)
        {
            if (clickable.Layer <= highestLayer)
            {
                continue;
            }

            highestLayer = clickable.Layer;
        }

        return highestLayer;
    }

    private void SignalClick(MouseButtonCode mouseButton)
    {
        List<Clickable> viableClickables = GetViableClickables();

        if (viableClickables.Count <= 0)
        {
            return;
        }

        Clickable? topClickable = GetTopClickable(viableClickables);

        if (topClickable is null)
        {
            return;
        }

        if (mouseButton == MouseButtonCode.Left)
        {
            topClickable.OnTopLeft = true;
            Log.Info($"'{topClickable.Name}' has been left clicked.", Debug);
        }
        else
        {
            topClickable.OnTopRight = true;
            Log.Info($"'{topClickable.Name}' has been right clicked.", Debug);
        }
    }

    private List<Clickable> GetViableClickables()
    {
        List<Clickable> viableClickables = [];

        foreach (Clickable clickable in clickables)
        {
            if (!IsMouseOverNode2D(clickable))
            {
                continue;
            }

            viableClickables.Add(clickable);
        }

        Log.Info($"{viableClickables.Count} viable clickables.", Debug);

        return viableClickables;
    }

    private Clickable? GetTopClickable(List<Clickable> viableClickables)
    {
        Clickable? topClickable = null;
        int highestLayer = MinLayer;

        foreach (Clickable clickable in viableClickables)
        {
            if (clickable.Layer < highestLayer)
            {
                continue;
            }

            highestLayer = clickable.Layer;
            topClickable = clickable;
        }

        Log.Info($"The highest layer is {viableClickables.Count}.", Debug);

        return topClickable;
    }

    private static bool IsMouseOverNode2D(Node2D node)
    {
        Vector2 mousePosition = Input.WorldMousePosition;

        bool isMouseOver =
            mousePosition.X > node.GlobalPosition.X - node.Origin.X &&
            mousePosition.X < node.GlobalPosition.X + node.ScaledSize.X - node.Origin.X &&
            mousePosition.Y > node.GlobalPosition.Y - node.Origin.Y &&
            mousePosition.Y < node.GlobalPosition.Y + node.ScaledSize.Y - node.Origin.Y;

        return isMouseOver;
    }
}
</file>

<file path="Source\Configuration.cs">
namespace Cherris;

public class Configuration
{
    public int Width { get; set; } = 0;
    public int Height { get; set; } = 0;
    public int MinWidth { get; set; } = 0;
    public int MinHeight { get; set; } = 0;
    public int MaxWidth { get; set; } = 0;
    public int MaxHeight { get; set; } = 0;
    public string Title { get; set; } = "Cherris";
    public bool ResizableWindow { get; set; } = true;
    public bool AntiAliasing { get; set; } = true;
    public string MainScenePath { get; set; } = "";
    public string Backend { get; set; } = "Raylib";
    public SystemBackdropType BackdropType { get; set; } = SystemBackdropType.MicaAlt;
    public bool VSync { get; set; } = true;
}
</file>

<file path="Source\DefaultTheme.cs">
// DefaultTheme.cs
using Vortice.Mathematics;

namespace Cherris;

// Defines default colors for the UI theme
public static class DefaultTheme
{
    // Basic Palette
    public static readonly Color4 White = Colors.White;
    public static readonly Color4 Black = Colors.Black;
    public static readonly Color4 Transparent = Colors.Transparent;

    // UI Element Colors (Examples, adjust as needed)
    public static readonly Color4 NormalFill = new Color4(0.25f, 0.25f, 0.3f, 1.0f);
    public static readonly Color4 NormalBorder = new Color4(0.4f, 0.4f, 0.45f, 1.0f);

    public static readonly Color4 HoverFill = new Color4(0.35f, 0.35f, 0.4f, 1.0f);
    public static readonly Color4 HoverBorder = new Color4(0.5f, 0.5f, 0.55f, 1.0f);

    public static readonly Color4 Accent = new Color4(0.2f, 0.4f, 0.8f, 1.0f); // Used for Pressed Fill
    public static readonly Color4 AccentBorder = new Color4(0.3f, 0.5f, 0.9f, 1.0f); // Used for Pressed Border

    public static readonly Color4 DisabledFill = new Color4(0.2f, 0.2f, 0.2f, 0.8f);
    public static readonly Color4 DisabledBorder = new Color4(0.3f, 0.3f, 0.3f, 0.8f);
    public static readonly Color4 DisabledText = new Color4(0.5f, 0.5f, 0.5f, 1.0f);

    public static readonly Color4 FocusBorder = Colors.LightSkyBlue; // Example focus color

    public static readonly Color4 Text = Colors.WhiteSmoke;
}
</file>

<file path="Source\Direct2DAppWindow.cs">
using System;
using System.Collections.Generic;
using System.Diagnostics;
using SharpGen.Runtime;
using Vortice.DCommon;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.DXGI;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;
using D2DFactoryType = Vortice.Direct2D1.FactoryType;
using DW = Vortice.DirectWrite;
using Rect = Vortice.Mathematics.Rect;
using SizeI = Vortice.Mathematics.SizeI;

namespace Cherris;

public abstract class Direct2DAppWindow : Win32Window
{
    protected ID2D1Factory1? d2dFactory;
    protected IDWriteFactory? dwriteFactory;
    protected ID2D1HwndRenderTarget? renderTarget;

    protected Color4 backgroundColor = Colors.Black;
    protected bool graphicsInitialized = false;

    private Stopwatch fpsTimer = new();
    private long lastFpsUpdateTimeTicks = 0;
    private int frameCountSinceUpdate = 0;
    private const long FpsUpdateIntervalTicks = TimeSpan.TicksPerSecond / 2;
    private ID2D1SolidColorBrush? fpsTextBrush;
    private IDWriteTextFormat? fpsTextFormat;
    private readonly Color4 fpsTextColor = DefaultTheme.Text;
    private readonly string fpsFontName = "Consolas";
    private readonly float fpsFontSize = 14.0f;

    private Dictionary<Color4, ID2D1SolidColorBrush> brushCache = new();
    private Dictionary<string, IDWriteTextFormat> textFormatCache = new();

    public float CurrentFps { get; private set; } = 0.0f;
    public IDWriteFactory? DWriteFactory => dwriteFactory;


    public Direct2DAppWindow(string title = "Vortice DirectUI Base Window", int width = 800, int height = 600)
        : base(title, width, height)
    { }

    protected override bool Initialize()
    {
        Log.Info($"Direct2DAppWindow '{Title}' initializing Vortice Graphics...");
        return InitializeGraphics();
    }

    protected override void Cleanup()
    {
        Log.Info($"Direct2DAppWindow '{Title}' cleaning up its resources...");
        CleanupGraphics();
    }

    public override void RenderFrame()
    {
        if (!fpsTimer.IsRunning)
        {
            fpsTimer.Start();
            lastFpsUpdateTimeTicks = fpsTimer.ElapsedTicks;
            frameCountSinceUpdate = 0;
        }

        frameCountSinceUpdate++;
        long elapsedTicks = fpsTimer.ElapsedTicks;
        long timeSinceLastUpdate = elapsedTicks - lastFpsUpdateTimeTicks;

        if (timeSinceLastUpdate >= FpsUpdateIntervalTicks)
        {
            float secondsElapsed = (float)timeSinceLastUpdate / TimeSpan.TicksPerSecond;
            CurrentFps = (secondsElapsed > 0.001f) ? (frameCountSinceUpdate / secondsElapsed) : 0.0f;
            frameCountSinceUpdate = 0;
            lastFpsUpdateTimeTicks = elapsedTicks;
        }

        if (!graphicsInitialized || renderTarget is null || dwriteFactory is null)
        {
            if (!graphicsInitialized && Handle != nint.Zero && IsOpen)
            {
                Log.Warning($"Graphics not initialized in RenderFrame for '{Title}', attempting reinitialization.");
                InitializeGraphics();
                if (!graphicsInitialized || renderTarget is null || dwriteFactory is null)
                {
                    Log.Error($"Reinitialization failed in RenderFrame for '{Title}'.");
                    return;
                }
            }
            else
            {
                Log.Warning($"RenderFrame skipped for '{Title}': Graphics not ready or window closed.");
                return;
            }
        }

        try
        {
            renderTarget.BeginDraw();
            renderTarget.Clear(backgroundColor);

            var drawingContext = new DrawingContext(renderTarget, dwriteFactory, this);

            DrawUIContent(drawingContext);

            if (fpsTextBrush is not null && fpsTextFormat is not null)
            {
                string fpsText = $"FPS: {CurrentFps:F1}";
                Rect fpsLayoutRect = new Rect(5f, 5f, 150f, 30f);
                renderTarget.DrawText(fpsText, fpsTextFormat, fpsLayoutRect, fpsTextBrush);
            }

            Result endDrawResult = renderTarget.EndDraw();

            if (endDrawResult.Failure)
            {
                Log.Error($"EndDraw failed for '{Title}': {endDrawResult.Description}");
                if (endDrawResult.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Log.Warning($"Render target needs recreation for '{Title}' (Detected in EndDraw).");
                    graphicsInitialized = false;
                    CleanupGraphics();
                    InitializeGraphics();
                }
            }
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Error($"Render target needs recreation for '{Title}' (Caught SharpGenException in RenderFrame): {ex.Message}");
            graphicsInitialized = false;
            CleanupGraphics();
            InitializeGraphics();
        }
        catch (Exception ex)
        {
            Log.Error($"Rendering Error in RenderFrame for '{Title}': {ex}");
            graphicsInitialized = false;
            CleanupGraphics();
            InitializeGraphics();
        }
    }

    protected abstract void DrawUIContent(DrawingContext context);

    protected override void OnSize(int width, int height)
    {
        if (graphicsInitialized && renderTarget is not null && width > 0 && height > 0)
        {
            Log.Info($"Window '{Title}' resized to {width}x{height}. Resizing render target...");
            try
            {
                var newPixelSize = new SizeI(width, height);

                CleanupDeviceSpecificResources();

                renderTarget.Resize(newPixelSize);

                RecreateDeviceSpecificResources();

                Log.Info($"Successfully resized render target for '{Title}'.");
                Invalidate();
            }
            catch (SharpGenException ex)
            {
                Log.Error($"Failed to resize Render Target for '{Title}' (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
                if (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
                {
                    Log.Warning($"Render target needs recreation for '{Title}' (Detected in Resize Exception).");
                    graphicsInitialized = false;
                    CleanupGraphics();
                    InitializeGraphics();
                }
            }
            catch (Exception ex)
            {
                Log.Error($"Failed to resize Render Target for '{Title}' (General Exception): {ex}");
                graphicsInitialized = false;
                CleanupGraphics();
                InitializeGraphics();
            }
        }
        else if (!graphicsInitialized && Handle != nint.Zero && IsOpen && width > 0 && height > 0)
        {
            Log.Warning($"OnSize called for '{Title}' but graphics not initialized. Attempting initialization.");
            InitializeGraphics();
        }
        else if (width <= 0 || height <= 0)
        {
            Log.Warning($"Ignoring OnSize call for '{Title}' with invalid dimensions: {width}x{height}");
        }
    }

    protected override void OnMouseMove(int x, int y) { }
    protected override void OnMouseDown(MouseButton button, int x, int y) { }
    protected override void OnMouseUp(MouseButton button, int x, int y) { }
    protected override void OnKeyDown(int keyCode) { }
    protected override void OnKeyUp(int keyCode) { }
    protected override void OnMouseWheel(short delta) { }

    protected virtual bool InitializeGraphics()
    {
        if (graphicsInitialized) return true;
        if (Handle == nint.Zero || !IsOpen)
        {
            Log.Warning($"InitializeGraphics skipped for '{Title}': Invalid handle or window not open.");
            return false;
        }

        Log.Info($"Attempting Graphics Initialization for '{Title}' HWND {Handle}...");

        try
        {
            CleanupGraphics();

            Result factoryResult = D2D1.D2D1CreateFactory(D2DFactoryType.SingleThreaded, out d2dFactory);
            factoryResult.CheckError();
            if (d2dFactory is null) throw new InvalidOperationException($"D2D Factory creation failed silently for '{Title}'.");

            Result dwriteResult = DWrite.DWriteCreateFactory(DW.FactoryType.Shared, out dwriteFactory);
            dwriteResult.CheckError();
            if (dwriteFactory is null) throw new InvalidOperationException($"DWrite Factory creation failed silently for '{Title}'.");

            var clientRectSize = GetClientRectSize();
            if (clientRectSize.Width <= 0 || clientRectSize.Height <= 0)
            {
                Log.Warning($"Invalid client rect size ({clientRectSize.Width}x{clientRectSize.Height}) for '{Title}'. Aborting graphics initialization.");
                CleanupGraphics();
                return false;
            }

            var dxgiPixelFormat = new PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Premultiplied);
            var renderTargetProperties = new RenderTargetProperties(dxgiPixelFormat);
            var hwndRenderTargetProperties = new HwndRenderTargetProperties
            {
                Hwnd = Handle,
                PixelSize = new SizeI(clientRectSize.Width, clientRectSize.Height),
                PresentOptions = VSyncEnabled ? PresentOptions.None : PresentOptions.Immediately
            };

            renderTarget = d2dFactory.CreateHwndRenderTarget(renderTargetProperties, hwndRenderTargetProperties);
            if (renderTarget is null) throw new InvalidOperationException($"Render target creation returned null unexpectedly for '{Title}'.");

            renderTarget.TextAntialiasMode = D2D.TextAntialiasMode.Cleartype;

            brushCache = new Dictionary<Color4, ID2D1SolidColorBrush>();
            textFormatCache = new Dictionary<string, IDWriteTextFormat>();

            RecreateDeviceSpecificResources();

            frameCountSinceUpdate = 0;
            CurrentFps = 0;
            lastFpsUpdateTimeTicks = 0;
            fpsTimer.Restart();

            Log.Info($"Vortice Graphics initialized successfully for '{Title}' HWND {Handle}.");
            graphicsInitialized = true;
            return true;
        }
        catch (SharpGenException ex)
        {
            Log.Error($"Graphics Initialization failed for '{Title}' (SharpGenException): {ex.Message} HRESULT: {ex.ResultCode}");
            CleanupGraphics(); graphicsInitialized = false; return false;
        }
        catch (Exception ex)
        {
            Log.Error($"Graphics Initialization failed for '{Title}' (General Exception): {ex}");
            CleanupGraphics(); graphicsInitialized = false; return false;
        }
    }

    private void RecreateDeviceSpecificResources()
    {
        if (renderTarget is null || dwriteFactory is null) return;

        try
        {
            fpsTextFormat?.Dispose();
            fpsTextFormat = dwriteFactory.CreateTextFormat(fpsFontName, null, FontWeight.Normal, FontStyle.Normal, FontStretch.Normal, fpsFontSize, "en-us");
            fpsTextFormat.TextAlignment = DW.TextAlignment.Leading;
            fpsTextFormat.ParagraphAlignment = ParagraphAlignment.Near;

            fpsTextBrush?.Dispose();
            fpsTextBrush = renderTarget.CreateSolidColorBrush(fpsTextColor);

            Log.Info($"Recreated FPS drawing resources for '{Title}'.");
        }
        catch (Exception ex)
        {
            Log.Error($"Warning: Failed to recreate device-specific resources for '{Title}': {ex.Message}");
            CleanupDeviceSpecificResources();
        }
    }

    private void CleanupDeviceSpecificResources()
    {
        fpsTextBrush?.Dispose(); fpsTextBrush = null;
        fpsTextFormat?.Dispose(); fpsTextFormat = null;

        foreach (var brush in brushCache.Values) brush?.Dispose();
        brushCache.Clear();
        foreach (var format in textFormatCache.Values) format?.Dispose();
        textFormatCache.Clear();
        Log.Info($"Cleaned device-specific resources (brushes, formats) for '{Title}'.");
    }

    protected virtual void CleanupGraphics()
    {
        bool resourcesExisted = d2dFactory is not null || renderTarget is not null || dwriteFactory is not null;
        if (resourcesExisted) Log.Info($"Cleaning up Vortice Graphics resources for '{Title}'...");

        fpsTimer.Stop();

        CleanupDeviceSpecificResources();

        renderTarget?.Dispose(); renderTarget = null;
        dwriteFactory?.Dispose(); dwriteFactory = null;
        d2dFactory?.Dispose(); d2dFactory = null;
        graphicsInitialized = false;

        if (resourcesExisted) Log.Info($"Finished cleaning graphics resources for '{Title}'.");
    }

    protected SizeI GetClientRectSize()
    {
        if (Handle != nint.Zero && NativeMethods.GetClientRect(Handle, out NativeMethods.RECT r))
        {
            int width = Math.Max(1, r.right - r.left);
            int height = Math.Max(1, r.bottom - r.top);
            return new SizeI(width, height);
        }

        int baseWidth = Math.Max(1, Width);
        int baseHeight = Math.Max(1, Height);
        if (Handle != nint.Zero)
        {
            Log.Warning($"GetClientRect failed for '{Title}'. Falling back to stored size: {baseWidth}x{baseHeight}");
        }
        return new SizeI(baseWidth, baseHeight);
    }

    public ID2D1SolidColorBrush? GetOrCreateBrush(Color4 color)
    {
        if (renderTarget is null)
        {
            Log.Warning($"GetOrCreateBrush called on '{Title}' with null RenderTarget.");
            return null;
        }

        if (brushCache.TryGetValue(color, out ID2D1SolidColorBrush? brush) && brush is not null)
        {
            return brush;
        }
        else if (brushCache.ContainsKey(color))
        {
            brushCache.Remove(color);
        }

        try
        {
            brush = renderTarget.CreateSolidColorBrush(color);
            if (brush is not null)
            {
                brushCache[color] = brush;
            }
            return brush;
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Warning($"Recreate target detected in GetOrCreateBrush for color {color} on '{Title}'.");
            CleanupDeviceSpecificResources();
            return null;
        }
        catch (Exception ex)
        {
            Log.Error($"Error creating brush for color {color} on '{Title}': {ex.Message}");
            return null;
        }
    }

    public IDWriteTextFormat? GetOrCreateTextFormat(ButtonStyle style)
    {
        if (dwriteFactory is null || style is null)
        {
            Log.Warning($"GetOrCreateTextFormat called on '{Title}' with null DWriteFactory or null style.");
            return null;
        }

        string cacheKey = $"{style.FontName}_{style.FontSize}_{style.FontWeight}_{style.FontStyle}_{style.FontStretch}_{style.WordWrapping}";

        if (textFormatCache.TryGetValue(cacheKey, out IDWriteTextFormat? format) && format is not null)
        {
            return format;
        }
        else if (textFormatCache.ContainsKey(cacheKey))
        {
            textFormatCache.Remove(cacheKey);
        }

        try
        {
            format = dwriteFactory.CreateTextFormat(
                style.FontName,
                null,
                style.FontWeight,
                style.FontStyle,
                style.FontStretch,
                style.FontSize,
                "en-us"
            );

            if (format is not null)
            {
                format.WordWrapping = style.WordWrapping;
                textFormatCache[cacheKey] = format;
            }
            return format;
        }
        catch (Exception ex)
        {
            Log.Error($"Error creating text format for key {cacheKey} on '{Title}': {ex.Message}");
            return null;
        }
    }
}
</file>

<file path="Source\DisplayServer.cs">
namespace Cherris;

public sealed class DisplayServer
{
    private static DisplayServer? _instance;
    public static DisplayServer Instance => _instance ??= new();

    // Public

    public DisplayServer()
    {
        // Constructor remains if any future non-Raylib global display settings are needed.
    }

    // All Raylib-specific methods and properties have been removed.
    // Window size and mouse position are now handled by individual window instances (Win32Window derived classes)
    // and can be queried via Node.GetOwningWindow() and then window.Width/Height or window.GetLocalMousePosition().
}
</file>

<file path="Source\DrawingContext.cs">
using Vortice.Direct2D1;
using Vortice.DirectWrite;

namespace Cherris;


public readonly struct DrawingContext
{
    public readonly ID2D1HwndRenderTarget RenderTarget;
    public readonly IDWriteFactory DWriteFactory;
    public readonly Direct2DAppWindow OwnerWindow;


    public DrawingContext(ID2D1HwndRenderTarget renderTarget, IDWriteFactory dwriteFactory, Direct2DAppWindow ownerWindow)
    {
        RenderTarget = renderTarget;
        DWriteFactory = dwriteFactory;
        OwnerWindow = ownerWindow;
    }
}
</file>

<file path="Source\FileLoader.cs">
using Cherris;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

public static class FileLoader
{
    private static readonly IDeserializer _deserializer = new DeserializerBuilder()
        .WithNamingConvention(PascalCaseNamingConvention.Instance)
        .Build();

    public static T Load<T>(string filePath) where T : new()
    {
        string yamlContent = File.ReadAllText(filePath);
        object data = _deserializer.Deserialize<object>(yamlContent);

        T instance = new();

        // Deferred assignments are only relevant if the root instance is a Node.
        // However, NodePropertySetter.SetNestedMember now expects the list,
        // so we provide it, but it will only be used if rootInstance is Node.
        List<(Node, string, object)>? deferredAssignments = null;
        if (instance is Node)
        {
            deferredAssignments = new List<(Node, string, object)>();
        }

        ProcessYamlData(instance, data, "", deferredAssignments);
        return instance;
    }

    private static void ProcessYamlData(object target, object yamlData, string currentPath, List<(Node, string, object)>? deferredNodeAssignments)
    {
        switch (yamlData)
        {
            case Dictionary<object, object> dict:
                foreach (KeyValuePair<object, object> entry in dict)
                {
                    string key = entry.Key.ToString()!;
                    string newPath = string.IsNullOrEmpty(currentPath)
                        ? key
                        : $"{currentPath}/{key}";

                    ProcessYamlData(target, entry.Value, newPath, deferredNodeAssignments);
                }
                break;

            case List<object> list:
                // For lists, we directly try to set the member. ValueConversionUtils will handle list conversion.
                NodePropertySetter.SetNestedMember(target, currentPath, list, deferredNodeAssignments);
                break;

            default: // Primitives, strings, enums, etc.
                NodePropertySetter.SetNestedMember(target, currentPath, yamlData, deferredNodeAssignments);
                break;
        }
    }
}
</file>

<file path="Source\GlobalSuppressions.cs">
// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.

using System.Diagnostics.CodeAnalysis;

[assembly: SuppressMessage("Style", "IDE0130:Namespace does not match folder structure", Justification = "<Pending>", Scope = "namespace", Target = "~N:Cherris")]
</file>

<file path="Source\GlobalUsings.cs">
// Types
//global using Color = Raylib_cs.Color;
//global using Image = Raylib_cs.Image;
//global using Rectangle = Raylib_cs.Rectangle;
global using Color = Vortice.Mathematics.Color4;
global using Vector2 = System.Numerics.Vector2;

// Resources

// Nodes
//global using Button = Cherris.Button;
//global using CheckBox = Cherris.CheckBox;
//global using ProgressBar = Cherris.ProgressBar;
//global using Timer = Cherris.Timer;
</file>

<file path="Source\HAlignment.cs">
namespace Cherris;

public enum OriginPreset
{
    None,
    Center,
    CenterLeft,
    CenterRight,
    TopLeft,
    TopCenter,
    TopRight,
    BottomCenter,
    BottomLeft,
    BottomRight,
}

public enum HAlignment
{
    Left,
    Center,
    Right,
    None
}
</file>

<file path="Source\Input.cs">
// file: Input.cs
namespace Cherris;

public static class Input
{
    private static Vector2 _currentMousePosition = Vector2.Zero;
    private static readonly HashSet<MouseButtonCode> _currentMouseButtonsDown = [];
    private static readonly HashSet<MouseButtonCode> _previousMouseButtonsDown = [];
    private static readonly HashSet<KeyCode> _currentKeysDown = [];
    private static readonly HashSet<KeyCode> _previousKeysDown = [];
    private static float _mouseWheelMovement = 0f;

    private static readonly Dictionary<string, KeyCode> _positiveXActions = [];
    private static readonly Dictionary<string, KeyCode> _negativeXActions = [];
    private static readonly Dictionary<string, KeyCode> _positiveYActions = [];
    private static readonly Dictionary<string, KeyCode> _negativeYActions = [];

    // Placeholder for character input queue (to be populated by MainAppWindow from WM_CHAR)
    private static readonly Queue<char> _typedCharQueue = new();


    public static void Update()
    {
        _previousMouseButtonsDown.Clear();
        foreach (var button in _currentMouseButtonsDown)
        {
            _previousMouseButtonsDown.Add(button);
        }

        _previousKeysDown.Clear();
        foreach (var key in _currentKeysDown)
        {
            _previousKeysDown.Add(key);
        }

        _mouseWheelMovement = 0f;
        // _typedCharQueue is not cleared here; it's consumed.
    }

    internal static void UpdateMouseButton(MouseButtonCode button, bool isDown)
    {
        if (isDown)
        {
            _currentMouseButtonsDown.Add(button);
        }
        else
        {
            _currentMouseButtonsDown.Remove(button);
        }
    }

    internal static void UpdateKey(KeyCode key, bool isDown)
    {
        if (isDown)
        {
            _currentKeysDown.Add(key);
        }
        else
        {
            _currentKeysDown.Remove(key);
        }
    }

    internal static void UpdateMousePosition(Vector2 position)
    {
        _currentMousePosition = position;
    }

    internal static void UpdateMouseWheel(float delta)
    {
        _mouseWheelMovement = delta;
    }

    // Method to be called by MainAppWindow when a WM_CHAR is processed
    internal static void AddTypedCharacter(char c)
    {
        // Optionally filter non-printable characters here, though WM_CHAR usually provides printable ones.
        // Backspace, Enter, Tab etc. are typically handled via WM_KEYDOWN.
        if (!char.IsControl(c) || c == '\t') // Allow tab as a character, filter other control chars
        {
            _typedCharQueue.Enqueue(c);
        }
    }

    // Method for UI elements like LineEdit to consume typed characters
    public static char? ConsumeNextTypedChar()
    {
        if (_typedCharQueue.Count > 0)
        {
            return _typedCharQueue.Dequeue();
        }
        return null;
    }


    public static bool IsActionDown(string actionName)
    {
        if (_positiveXActions.TryGetValue(actionName, out var posXKey) && IsKeyDown(posXKey)) return true;
        if (_negativeXActions.TryGetValue(actionName, out var negXKey) && IsKeyDown(negXKey)) return true;
        if (_positiveYActions.TryGetValue(actionName, out var posYKey) && IsKeyDown(posYKey)) return true;
        if (_negativeYActions.TryGetValue(actionName, out var negYKey) && IsKeyDown(negYKey)) return true;

        return false;
    }

    public static bool IsActionPressed(string actionName)
    {
        if (_positiveXActions.TryGetValue(actionName, out var posXKey) && IsKeyPressed(posXKey)) return true;
        if (_negativeXActions.TryGetValue(actionName, out var negXKey) && IsKeyPressed(negXKey)) return true;
        if (_positiveYActions.TryGetValue(actionName, out var posYKey) && IsKeyPressed(posYKey)) return true;
        if (_negativeYActions.TryGetValue(actionName, out var negYKey) && IsKeyPressed(negYKey)) return true;
        return false;
    }


    public static bool IsKeyPressed(KeyCode keyboardKey)
    {
        return _currentKeysDown.Contains(keyboardKey) && !_previousKeysDown.Contains(keyboardKey);
    }

    public static bool IsKeyReleased(KeyCode keyboardKey)
    {
        return !_currentKeysDown.Contains(keyboardKey) && _previousKeysDown.Contains(keyboardKey);
    }

    public static bool IsKeyDown(KeyCode keyboardKey)
    {
        return _currentKeysDown.Contains(keyboardKey);
    }


    public static bool IsMouseButtonPressed(MouseButtonCode button)
    {
        return _currentMouseButtonsDown.Contains(button) && !_previousMouseButtonsDown.Contains(button);
    }

    public static bool IsMouseButtonReleased(MouseButtonCode button)
    {
        return !_currentMouseButtonsDown.Contains(button) && _previousMouseButtonsDown.Contains(button);
    }

    public static bool IsMouseButtonDown(MouseButtonCode button)
    {
        return _currentMouseButtonsDown.Contains(button);
    }

    public static float GetMouseWheelMovement()
    {
        return _mouseWheelMovement;
    }

    public static Vector2 MousePosition => _currentMousePosition;

    public static Vector2 WorldMousePosition => _currentMousePosition;

    //public static MouseCursorCode Cursor
    //{
    //
    //    set { }
    //}

    public static Vector2 GetVector(string negativeX, string positiveX, string negativeY, string positiveY, float deadzone = -1.0f)
    {
        float x = 0.0f;
        float y = 0.0f;

        if (_positiveXActions.TryGetValue(positiveX, out var posXKey) && IsKeyDown(posXKey)) x += 1.0f;
        if (_negativeXActions.TryGetValue(negativeX, out var negXKey) && IsKeyDown(negXKey)) x -= 1.0f;
        if (_positiveYActions.TryGetValue(positiveY, out var posYKey) && IsKeyDown(posYKey)) y += 1.0f;
        if (_negativeYActions.TryGetValue(negativeY, out var negYKey) && IsKeyDown(negYKey)) y -= 1.0f;

        var vector = new Vector2(x, y);

        if (deadzone < 0.0f)
        {
            return vector.LengthSquared() > 0 ? Vector2.Normalize(vector) : Vector2.Zero;
        }
        else
        {
            float length = vector.Length();
            if (length < deadzone)
            {
                return Vector2.Zero;
            }
            else
            {
                var normalized = vector / length;
                float mappedLength = (length - deadzone) / (1.0f - deadzone);
                return normalized * mappedLength;
            }
        }
    }

    public static void AddActionKey(string actionName, KeyCode key, bool isPositiveX = false, bool isNegativeX = false, bool isPositiveY = false, bool isNegativeY = false)
    {
        if (isPositiveX) _positiveXActions[actionName] = key;
        if (isNegativeX) _negativeXActions[actionName] = key;
        if (isPositiveY) _positiveYActions[actionName] = key;
        if (isNegativeY) _negativeYActions[actionName] = key;
    }

    public static void SetupDefaultActions()
    {
        AddActionKey("UiUp", KeyCode.UpArrow, isNegativeY: true);
        AddActionKey("UiUp", KeyCode.W, isNegativeY: true);
        AddActionKey("UiDown", KeyCode.DownArrow, isPositiveY: true);
        AddActionKey("UiDown", KeyCode.S, isPositiveY: true);
        AddActionKey("UiLeft", KeyCode.LeftArrow, isNegativeX: true);
        AddActionKey("UiLeft", KeyCode.A, isNegativeX: true);
        AddActionKey("UiRight", KeyCode.RightArrow, isPositiveX: true);
        AddActionKey("UiRight", KeyCode.D, isPositiveX: true);
        AddActionKey("UiAccept", KeyCode.Enter, isPositiveX: true);
        AddActionKey("UiAccept", KeyCode.Space, isPositiveX: true);
        AddActionKey("UiCancel", KeyCode.Escape, isPositiveX: true);
    }
}
</file>

<file path="Source\KeyCode.cs">
// file: KeyCode.cs
// Minimal KeyCode enum based on common Win32 VK codes needed
// Reference: https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
namespace Cherris;

public enum KeyCode
{
    Unknown = 0,

    Space = 0x20,
    Apostrophe = 222,
    Comma = 188,
    Minus = 189,
    Period = 190,
    Slash = 191,
    Alpha0 = 48,
    Alpha1 = 49,
    Alpha2 = 50,
    Alpha3 = 51,
    Alpha4 = 52,
    Alpha5 = 53,
    Alpha6 = 54,
    Alpha7 = 55,
    Alpha8 = 56,
    Alpha9 = 57,
    Semicolon = 186,
    Equal = 187,
    A = 65,
    B = 66,
    C = 67,
    D = 68,
    E = 69,
    F = 70,
    G = 71,
    H = 72,
    I = 73,
    J = 74,
    K = 75,
    L = 76,
    M = 77,
    N = 78,
    O = 79,
    P = 80,
    Q = 81,
    R = 82,
    S = 83,
    T = 84,
    U = 85,
    V = 86,
    W = 87,
    X = 88,
    Y = 89,
    Z = 90,
    LeftBracket = 219,
    Backslash = 220,
    RightBracket = 221,
    GraveAccent = 192,

    Escape = 0x1B,
    Enter = 0x0D,        // VK_RETURN
    Tab = 0x09,         // VK_TAB
    Backspace = 0x08,   // VK_BACK
    Insert = 0x2D,      // VK_INSERT
    Delete = 0x2E,      // VK_DELETE
    RightArrow = 0x27,    // VK_RIGHT
    LeftArrow = 0x25,     // VK_LEFT
    DownArrow = 0x28,     // VK_DOWN
    UpArrow = 0x26,       // VK_UP
    PageUp = 0x21,      // VK_PRIOR
    PageDown = 0x22,    // VK_NEXT
    Home = 0x24,        // VK_HOME
    End = 0x23,         // VK_END
    CapsLock = 0x14,    // VK_CAPITAL
    ScrollLock = 0x91,  // VK_SCROLL
    NumLock = 0x90,     // VK_NUMLOCK
    PrintScreen = 0x2C, // VK_SNAPSHOT
    Pause = 0x13,       // VK_PAUSE
    F1 = 0x70,          // VK_F1
    F2 = 0x71,
    F3 = 0x72,
    F4 = 0x73,
    F5 = 0x74,
    F6 = 0x75,
    F7 = 0x76,
    F8 = 0x77,
    F9 = 0x78,
    F10 = 0x79,
    F11 = 0x7A,
    F12 = 0x7B,
    Numpad0 = 0x60,     // VK_NUMPAD0
    Numpad1 = 0x61,
    Numpad2 = 0x62,
    Numpad3 = 0x63,
    Numpad4 = 0x64,
    Numpad5 = 0x65,
    Numpad6 = 0x66,
    Numpad7 = 0x67,
    Numpad8 = 0x68,
    Numpad9 = 0x69,
    NumpadDecimal = 0x6E,// VK_DECIMAL
    NumpadDivide = 0x6F, // VK_DIVIDE
    NumpadMultiply = 0x6A,// VK_MULTIPLY
    NumpadSubtract = 0x6D,// VK_SUBTRACT
    NumpadAdd = 0x6B,    // VK_ADD
    NumpadEnter = 0x6C,  // VK_SEPARATOR (Often Numpad Enter)
    LeftShift = 0xA0,   // VK_LSHIFT
    LeftControl = 0xA2, // VK_LCONTROL
    LeftAlt = 0xA4,     // VK_LMENU
    LeftSuper = 0x5B,   // VK_LWIN
    RightShift = 0xA1,  // VK_RSHIFT
    RightControl = 0xA3,// VK_RCONTROL
    RightAlt = 0xA5,    // VK_RMENU
    RightSuper = 0x5C,  // VK_RWIN
    Menu = 0x5D         // VK_APPS
}
</file>

<file path="Source\Log.cs">
namespace Cherris;

using System;
using System.IO;
using System.Runtime.CompilerServices;

public class Log
{
    private readonly static string LogFilePath = "Res/Log.txt";
    private readonly static ConsoleColor infoColor = ConsoleColor.DarkGray;
    private readonly static ConsoleColor warningColor = ConsoleColor.Yellow;
    private readonly static ConsoleColor errorColor = ConsoleColor.Red;

    public static void Info(string message, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        string fullMessage = $"[{DateTime.Now:HH:mm:ss}] [INFO] [{Path.GetFileName(filePath)}:{lineNumber}] {message}";
        Console.ForegroundColor = infoColor;
        Console.WriteLine(fullMessage);
        Console.ResetColor();
        File.AppendAllText(LogFilePath, Environment.NewLine + fullMessage);
    }

    public static void Info(string message, bool condition, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        if (!condition)
        {
            return;
        }

        Console.ForegroundColor = infoColor;
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] [INFO] [{Path.GetFileName(filePath)}:{lineNumber}] {message}");
        Console.ResetColor();
    }

    public static void Warning(string message, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        string fullMessage = $"[{DateTime.Now:HH:mm:ss}] [WARNING] [{Path.GetFileName(filePath)}:{lineNumber}] {message}";
        Console.ForegroundColor = warningColor;
        Console.WriteLine(fullMessage);
        Console.ResetColor();
        File.AppendAllText(LogFilePath, Environment.NewLine + fullMessage);
    }

    public static void Warning(string message, bool condition, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        if (!condition)
        {
            return;
        }

        Console.ForegroundColor = warningColor;
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] [WARNING] [{Path.GetFileName(filePath)}:{lineNumber}] {message}");
        Console.ResetColor();
    }

    public static void Error(string message, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        string fullMessage = $"[{DateTime.Now:HH:mm:ss}] [ERROR] - {Path.GetFileName(filePath)}:{lineNumber} - {message}";
        Console.ForegroundColor = errorColor;
        Console.WriteLine(fullMessage);
        Console.ResetColor();
        File.AppendAllText(LogFilePath, Environment.NewLine + fullMessage);
    }

    public static void Error(string message, bool condition, [CallerLineNumber] int lineNumber = 0, [CallerFilePath] string filePath = "")
    {
        if (!condition)
        {
            return;
        }

        Console.ForegroundColor = errorColor;
        Console.WriteLine($"[{DateTime.Now:HH:mm:ss}] [ERROR] - [{Path.GetFileName(filePath)}:{lineNumber}] - {message}");
        Console.ResetColor();
    }
}
</file>

<file path="Source\MainAppWindow.cs">
namespace Cherris;

public class MainAppWindow : Direct2DAppWindow
{
    public event Action? Closed;
    private bool _firstDrawLogged = false;
    private Vector2 _mainCurrentMousePosition = Vector2.Zero;

    public MainAppWindow(string title = "My DirectUI App", int width = 800, int height = 600)
        : base(title, width, height)
    {
        Input.SetupDefaultActions();
    }

    public Vector2 GetLocalMousePosition() => _mainCurrentMousePosition;

    protected override void DrawUIContent(DrawingContext context)
    {
        if (!_firstDrawLogged)
        {
            Log.Info($"MainAppWindow.DrawUIContent called for '{Title}'. Rendering SceneTree.");
            _firstDrawLogged = true;
        }

        SceneTree.Instance.RenderScene(context);
    }

    protected override bool OnClose()
    {
        Log.Info("MainAppWindow OnClose called.");
        Closed?.Invoke();
        return base.OnClose();
    }

    protected override void Cleanup()
    {
        Log.Info("MainAppWindow Cleanup starting.");
        base.Cleanup();
        Log.Info("MainAppWindow Cleanup finished.");
    }

    protected override IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        // Note: xPos, yPos, mousePos are now fetched inside specific message cases if needed,
        // or handled by the base class after _mainCurrentMousePosition is set.

        switch (msg)
        {
            case NativeMethods.WM_MOUSEMOVE:
                int x = NativeMethods.GET_X_LPARAM(lParam);
                int y = NativeMethods.GET_Y_LPARAM(lParam);
                _mainCurrentMousePosition = new Vector2(x, y);
                Input.UpdateMousePosition(_mainCurrentMousePosition); // Update global input state
                // Allow base.HandleMessage to call OnMouseMove and other logic
                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_LBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Left, true);
                // Allow base class to handle focus and other default behaviors.
                // If we return IntPtr.Zero, some default behaviors like setting focus on click might be bypassed.
                // Let base class handle it unless we specifically want to override.
                break;
            case NativeMethods.WM_LBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Left, false);
                break;

            case NativeMethods.WM_RBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Right, true);
                break;
            case NativeMethods.WM_RBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Right, false);
                break;

            case NativeMethods.WM_MBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Middle, true);
                break;
            case NativeMethods.WM_MBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Middle, false);
                break;

            case NativeMethods.WM_XBUTTONDOWN:
                int xButton1 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton1 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, true);
                if (xButton1 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, true);
                break;
            case NativeMethods.WM_XBUTTONUP:
                int xButton2 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton2 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, false);
                if (xButton2 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, false);
                break;

            case NativeMethods.WM_MOUSEWHEEL:
                short wheelDelta = NativeMethods.GET_WHEEL_DELTA_WPARAM(wParam);
                Input.UpdateMouseWheel((float)wheelDelta / NativeMethods.WHEEL_DELTA);
                // Let base handle if it needs to (e.g. for scrolling non-client areas or accessibility)
                break;

            case NativeMethods.WM_KEYDOWN:
            case NativeMethods.WM_SYSKEYDOWN:
                int vkCodeDown = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeDown))
                {
                    Input.UpdateKey((KeyCode)vkCodeDown, true);
                }
                // Allow base.HandleMessage for default key processing (e.g., Escape key for close, Tab navigation)
                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_KEYUP:
            case NativeMethods.WM_SYSKEYUP:
                int vkCodeUp = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeUp))
                {
                    Input.UpdateKey((KeyCode)vkCodeUp, false);
                }
                // Often, KeyUp doesn't need further default processing if KeyDown handled it.
                // However, if base class might use it (e.g. for accessibility), let it pass.
                // Returning IntPtr.Zero might be too aggressive.
                break;

            case NativeMethods.WM_CHAR:
                char typedChar = (char)wParam;
                Input.AddTypedCharacter(typedChar);
                return IntPtr.Zero; // Character processed
        }

        return base.HandleMessage(hWnd, msg, wParam, lParam);
    }
}
</file>

<file path="Source\ModalSecondaryWindow.cs">
namespace Cherris;

public class ModalSecondaryWindow : SecondaryWindow
{
    private readonly IntPtr ownerHwnd;

    public ModalSecondaryWindow(string title, int width, int height, WindowNode ownerNode, IntPtr ownerHandle)
        : base(title, width, height, ownerNode)
    {
        ownerHwnd = ownerHandle;
    }


    public override bool TryCreateWindow(IntPtr ownerHwndOverride = default, uint? styleOverride = null)
    {

        uint defaultModalStyle = NativeMethods.WS_POPUP
                               | NativeMethods.WS_CAPTION
                               | NativeMethods.WS_SYSMENU
                               | NativeMethods.WS_VISIBLE
                               | NativeMethods.WS_THICKFRAME;


        return base.TryCreateWindow(ownerHwnd, styleOverride ?? defaultModalStyle);
    }

    public override void ShowWindow()
    {

        if (ownerHwnd != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(ownerHwnd, false);
        }
        base.ShowWindow();
    }

    protected override void OnDestroy()
    {

        if (ownerHwnd != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(ownerHwnd, true);
        }
        base.OnDestroy();
    }


    protected override bool OnClose()
    {
        Log.Info($"ModalSecondaryWindow '{Title}' OnClose called.");

        if (ownerHwnd != IntPtr.Zero)
        {
            NativeMethods.EnableWindow(ownerHwnd, true);
        }


        return base.OnClose();
    }
}
</file>

<file path="Source\ModalWindowNode.cs">
namespace Cherris;

public class ModalWindowNode : WindowNode
{
    private ModalSecondaryWindow? modalWindow;

    public override void Make()
    {
        InitializeModalWindow();
    }

    private void InitializeModalWindow()
    {
        if (modalWindow is not null)
        {
            Log.Warning($"ModalWindowNode '{Name}' already has an associated window. Skipping creation.");
            return;
        }

        var ownerHandle = ApplicationServer.Instance.GetMainWindowHandle();
        if (ownerHandle == IntPtr.Zero)
        {
            Log.Error($"ModalWindowNode '{Name}' could not get the main window handle. Cannot create modal window.");
            return;
        }

        try
        {
            modalWindow = new ModalSecondaryWindow(Title, Width, Height, this, ownerHandle);
            this.secondaryWindow = modalWindow;

            if (!modalWindow.TryCreateWindow())
            {
                Log.Error($"ModalWindowNode '{Name}' failed to create its modal window.");
                modalWindow = null;
                this.secondaryWindow = null;
                return;
            }

            modalWindow.BackdropType = this.BackdropType;

            if (!modalWindow.InitializeWindowAndGraphics())
            {
                Log.Error($"ModalWindowNode '{Name}' failed to initialize modal window graphics.");
                modalWindow.Dispose();
                modalWindow = null;
                this.secondaryWindow = null;
                return;
            }

            modalWindow.ShowWindow();
            Log.Info($"ModalWindowNode '{Name}' successfully created and initialized its modal window.");
        }
        catch (Exception ex)
        {
            Log.Error($"Error during ModalWindowNode '{Name}' initialization: {ex.Message}");
            modalWindow?.Dispose();
            modalWindow = null;
            this.secondaryWindow = null;
        }
    }

    protected override void FreeInternal()
    {
        Log.Info($"Freeing ModalWindowNode '{Name}' and its associated modal window.");

        modalWindow?.Close();
        modalWindow = null;

        this.secondaryWindow = null;

        base.FreeInternal();
    }

    public override void Process()
    {
        if (this.isQueuedForFree)
        {
            this.FreeInternal();
        }
        else
        {
            base.Process();
        }
    }
}
</file>

<file path="Source\MouseButtonCode.cs">
namespace Cherris;

public enum MouseButtonCode
{
    Left = 0,
    Right = 1,
    Middle = 2, // Added Middle for completeness if needed
    Side = 3,   // Often corresponds to XButton1
    Extra = 4,  // Often corresponds to XButton2
    Forward = 5,
    Back = 6
}
</file>

<file path="Source\NativeMethods.cs">
using System.Runtime.InteropServices;

namespace Cherris;

public static class NativeMethods
{
    public const uint CS_HREDRAW = 0x0002;
    public const uint CS_VREDRAW = 0x0001;
    public const uint CS_OWNDC = 0x0020;

    public const uint WS_OVERLAPPED = 0x00000000;
    public const uint WS_CAPTION = 0x00C00000;
    public const uint WS_SYSMENU = 0x00080000;
    public const uint WS_THICKFRAME = 0x00040000;
    public const uint WS_MINIMIZEBOX = 0x00020000;
    public const uint WS_MAXIMIZEBOX = 0x00010000;
    public const uint WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    public const uint WS_VISIBLE = 0x10000000;
    public const uint WS_POPUP = 0x80000000;
    public const uint WS_BORDER = 0x00800000;
    public const uint WS_DLGFRAME = 0x00400000;

    public const int WM_NCCREATE = 0x0081;
    public const int WM_CREATE = 0x0001;
    public const int WM_NCDESTROY = 0x0082;
    public const int WM_PAINT = 0x000F;
    public const int WM_DESTROY = 0x0002;
    public const int WM_SIZE = 0x0005;
    public const int WM_CLOSE = 0x0010;
    public const int WM_KEYDOWN = 0x0100;
    public const int WM_KEYUP = 0x0101;
    public const int WM_SYSKEYDOWN = 0x0104;
    public const int WM_SYSKEYUP = 0x0105;
    public const int WM_CHAR = 0x0102; // Added for character input
    public const int WM_LBUTTONDOWN = 0x0201;
    public const int WM_LBUTTONUP = 0x0202;
    public const int WM_RBUTTONDOWN = 0x0204;
    public const int WM_RBUTTONUP = 0x0205;
    public const int WM_MBUTTONDOWN = 0x0207;
    public const int WM_MBUTTONUP = 0x0208;
    public const int WM_XBUTTONDOWN = 0x020B;
    public const int WM_XBUTTONUP = 0x020C;
    public const int WM_MOUSEMOVE = 0x0200;
    public const int WM_MOUSEWHEEL = 0x020A;
    public const int WM_QUIT = 0x0012;
    public const int WM_PARENTNOTIFY = 0x0210;
    public const int WM_ENTERIDLE = 0x0121;
    public const int WM_DWMCOMPOSITIONCHANGED = 0x031E;

    public const int CW_USEDEFAULT = unchecked((int)0x80000000);
    public const int SW_SHOWNORMAL = 1;
    public const int VK_ESCAPE = 0x1B;
    public const int GWLP_USERDATA = -21;
    public const int GCLP_HBRBACKGROUND = -10;
    public const int GWL_STYLE = -16;

    public const int IDI_APPLICATION = 32512;
    public const int IDC_ARROW = 32512;

    public const int WHEEL_DELTA = 120;
    public const int XBUTTON1 = 0x0001;
    public const int XBUTTON2 = 0x0002;

    public const uint PM_REMOVE = 0x0001;

    public enum DWMWINDOWATTRIBUTE
    {
        DWMWA_USE_IMMERSIVE_DARK_MODE = 20,
        DWMWA_SYSTEMBACKDROP_TYPE = 38,
        DWMWA_MICA_EFFECT = 1029
    }

    public enum DWMSBT
    {
        DWMSBT_AUTO = 0,
        DWMSBT_NONE = 1,
        DWMSBT_MAINWINDOW = 2,
        DWMSBT_TRANSIENTWINDOW = 3,
        DWMSBT_TABBEDWINDOW = 4
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct WNDCLASSEX
    {
        public int cbSize;
        public uint style;
        public WndProc lpfnWndProc;
        public int cbClsExtra;
        public int cbWndExtra;
        public IntPtr hInstance;
        public IntPtr hIcon;
        public IntPtr hCursor;
        public IntPtr hbrBackground;
        [MarshalAs(UnmanagedType.LPTStr)]
        public string lpszMenuName;
        [MarshalAs(UnmanagedType.LPTStr)]
        public string lpszClassName;
        public IntPtr hIconSm;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct MSG
    {
        public IntPtr hwnd;
        public uint message;
        public IntPtr wParam;
        public IntPtr lParam;
        public uint time;
        public POINT pt;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct POINT
    {
        public int X;
        public int Y;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct RECT
    {
        public int left;
        public int top;
        public int right;
        public int bottom;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    public struct CREATESTRUCT
    {
        public IntPtr lpCreateParams;
        public IntPtr hInstance;
        public IntPtr hMenu;
        public IntPtr hwndParent;
        public int cy;
        public int cx;
        public int y;
        public int x;
        public int style;
        public string lpszName;
        public string lpszClass;
        public uint dwExStyle;
    }

    public delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern ushort RegisterClassEx([In] ref WNDCLASSEX lpwcx);

    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern IntPtr CreateWindowEx(
       uint dwExStyle,
       string lpClassName,
       string lpWindowName,
       uint dwStyle,
       int x,
       int y,
       int nWidth,
       int nHeight,
       IntPtr hWndParent,
       IntPtr hMenu,
       IntPtr hInstance,
       IntPtr lpParam);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool UpdateWindow(IntPtr hWnd);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool DestroyWindow(IntPtr hWnd);

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll")]
    public static extern void PostQuitMessage(int nExitCode);

    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool GetMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);

    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool PeekMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);

    [DllImport("user32.dll")]
    public static extern bool TranslateMessage([In] ref MSG lpMsg);

    [DllImport("user32.dll")]
    public static extern IntPtr DispatchMessage([In] ref MSG lpmsg);

    [DllImport("user32.dll")]
    public static extern bool GetClientRect(IntPtr hWnd, out RECT lpRect);

    [DllImport("user32.dll")]
    public static extern bool ValidateRect(IntPtr hWnd, IntPtr lpRect);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);

    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool InvalidateRect(IntPtr hWnd, IntPtr lpRect, bool bErase);

    [DllImport("user32.dll")]
    public static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);

    [DllImport("user32.dll")]
    public static extern IntPtr LoadIcon(IntPtr hInstance, IntPtr lpIconName);

    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool EnableWindow(IntPtr hWnd, bool bEnable);

    [DllImport("user32.dll")]
    public static extern IntPtr GetParent(IntPtr hWnd);

    // Corrected signature: Takes ref int for enum/bool attributes
    [DllImport("dwmapi.dll", SetLastError = true)]
    public static extern int DwmSetWindowAttribute(IntPtr hwnd, DWMWINDOWATTRIBUTE dwAttribute, ref int pvAttribute, int cbAttribute);

    // Removed the incorrect overload taking ref DWMSBT
    // [DllImport("dwmapi.dll", SetLastError = true)]
    // public static extern int DwmSetWindowAttribute(IntPtr hwnd, DWMWINDOWATTRIBUTE dwAttribute, ref DWMSBT pvAttribute, int cbAttribute);

    [DllImport("user32.dll", EntryPoint = "SetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr SetWindowLongPtr64(IntPtr hWnd, int nIndex, IntPtr dwNewLong);

    [DllImport("user32.dll", EntryPoint = "SetWindowLongW", SetLastError = true)]
    private static extern IntPtr SetWindowLong32(IntPtr hWnd, int nIndex, IntPtr dwNewLong);

    [DllImport("user32.dll", EntryPoint = "GetWindowLongPtrW", SetLastError = true)]
    private static extern IntPtr GetWindowLongPtr64(IntPtr hWnd, int nIndex);

    [DllImport("user32.dll", EntryPoint = "GetWindowLongW", SetLastError = true)]
    private static extern IntPtr GetWindowLong32(IntPtr hWnd, int nIndex);

    public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong)
    {
        if (IntPtr.Size == 8)
            return SetWindowLongPtr64(hWnd, nIndex, dwNewLong);
        else
            return SetWindowLong32(hWnd, nIndex, dwNewLong);
    }

    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex)
    {
        if (IntPtr.Size == 8)
            return GetWindowLongPtr64(hWnd, nIndex);
        else
            return GetWindowLong32(hWnd, nIndex);
    }

    public static int GET_X_LPARAM(IntPtr lParam) => LOWORD(lParam);
    public static int GET_Y_LPARAM(IntPtr lParam) => HIWORD(lParam);
    public static short GET_WHEEL_DELTA_WPARAM(IntPtr wParam) => HIWORD(wParam);
    public static short GET_XBUTTON_WPARAM(IntPtr wParam) => HIWORD(wParam);

    public static int LOWORD(IntPtr ptr) => unchecked((short)(long)ptr);
    public static short HIWORD(IntPtr ptr) => unchecked((short)((long)ptr >> 16));
}
</file>

<file path="Source\Node.cs">
using Spectre.Console;

namespace Cherris;

public class Node
{
    public enum ProcessMode
    {
        Inherit,
        Pausable,
        WhenPaused,
        Disabled,
        Always
    }

    public static Node RootNode => SceneTree.Instance.RootNode!;
    public static SceneTree Tree => SceneTree.Instance;

    public string Name { get; set; } = "";
    public Node? Parent { get; set; } = null;
    public List<Node> Children { get; set; } = [];
    public ProcessMode ProcessingMode = ProcessMode.Inherit;

    private bool fieldActive = true;

    public bool Active
    {
        get => fieldActive;

        set
        {
            if (fieldActive == value)
            {
                return;
            }

            fieldActive = value;
            ActiveChanged?.Invoke(this, fieldActive);
        }
    }

    public string AbsolutePath
    {
        get
        {
            if (Parent is null)
            {

                return "/root/";
            }

            Stack<string> pathStack = new();
            Node? current = this;


            while (current is not null && current.Parent is not null)
            {

                pathStack.Push(current.Name);
                current = current.Parent;
            }


            return $"/root/{string.Join("/", pathStack)}";
        }
    }


    public delegate void ActiveEvent(Node sender, bool active);
    public delegate void ChildEvent(Node sender, Node child);
    public event ActiveEvent? ActiveChanged;
    public event ChildEvent? ChildAdded;


    public virtual void Make() { }

    public virtual void Start() { }

    public virtual void Ready() { }

    public virtual void Free()
    {
        List<Node> childrenToDestroy = new(Children);

        foreach (Node child in childrenToDestroy)
        {
            child.Free();
        }

        Parent?.Children.Remove(this);
    }


    public virtual void ProcessBegin() { }

    public virtual void Process() { }

    public virtual void ProcessEnd() { }


    public void PrintChildren()
    {
        Console.OutputEncoding = System.Text.Encoding.UTF8;

        string rootEmoji = NodeEmoji.GetEmojiForNodeType(this);
        Tree root = new($"{rootEmoji} [green]{Name}[/]");

        AddChildrenToTree(this, root);

        AnsiConsole.Write(root);
    }

    private static void AddChildrenToTree(Node node, IHasTreeNodes parentNode)
    {
        foreach (Node child in node.Children)
        {
            string childEmoji = NodeEmoji.GetEmojiForNodeType(child);
            TreeNode childNode = parentNode.AddNode($"{childEmoji} [blue]{child.Name}[/]");
            AddChildrenToTree(child, childNode);
        }
    }


    public virtual void Activate()
    {
        Active = true;

        foreach (Node child in Children)
        {
            child.Activate();
        }
    }

    public virtual void Deactivate()
    {
        Active = false;

        foreach (Node child in Children)
        {
            child.Deactivate();
        }
    }


    public T GetParent<T>() where T : Node
    {
        if (Parent is not null)
        {
            return (T)Parent;
        }

        return (T)this;
    }

    public T GetNode<T>(string path) where T : Node
    {
        if (string.IsNullOrEmpty(path))
        {
            throw new ArgumentException("Path cannot be null or empty.", nameof(path));
        }

        Node? currentNode;

        if (path.StartsWith("/root"))
        {
            path = path["/root".Length..];
            currentNode = SceneTree.Instance.RootNode;

            if (path.StartsWith('/'))
            {
                path = path.Substring(1);
            }

            if (!string.IsNullOrEmpty(path))
            {
                string[] nodeNames = path.Split('/');
                foreach (var name in nodeNames)
                {
                    if (name == "..")
                    {

                        currentNode = currentNode?.Parent;
                    }
                    else
                    {
                        currentNode = currentNode?.GetChild(name);
                    }

                    if (currentNode == null)
                    {
                        throw new InvalidOperationException($"Node '{name}' not found in the scene tree.");
                    }
                }
            }
        }
        else
        {
            currentNode = this;
            string[] nodeNames = path.Split('/');
            foreach (var name in nodeNames)
            {
                if (name == "..")
                {

                    currentNode = currentNode?.Parent;
                }
                else if (name != "")
                {
                    currentNode = currentNode?.GetChild(name);
                }

                if (currentNode == null)
                {
                    throw new InvalidOperationException($"Node '{name}' not found in the scene tree.");
                }
            }
        }

        return currentNode as T ?? throw new InvalidOperationException("Node is not of the expected type.");
    }

    public T? GetNodeOrNull<T>(string path) where T : Node
    {
        if (string.IsNullOrEmpty(path))
        {
            return null;
        }

        Node? currentNode;

        if (path.StartsWith("/root"))
        {
            path = path.Substring("/root".Length);
            currentNode = SceneTree.Instance.RootNode;

            if (path.StartsWith("/"))
            {
                path = path.Substring(1);
            }

            if (!string.IsNullOrEmpty(path))
            {
                string[] nodeNames = path.Split('/');
                foreach (var name in nodeNames)
                {
                    if (name == "..")
                    {

                        currentNode = currentNode?.Parent;
                    }
                    else
                    {
                        currentNode = currentNode?.GetChildOrNull(name);
                    }

                    if (currentNode == null)
                    {
                        return null;
                    }
                }
            }
        }
        else
        {
            currentNode = this;
            string[] nodeNames = path.Split('/');
            foreach (var name in nodeNames)
            {
                if (name == "..")
                {

                    currentNode = currentNode?.Parent;
                }
                else if (name != "")
                {
                    currentNode = currentNode?.GetChildOrNull(name);
                }

                if (currentNode == null)
                {
                    return null;
                }
            }
        }

        return currentNode as T;
    }


    public T? GetChild<T>(string name) where T : Node
    {
        foreach (Node child in Children)
        {
            if (child.Name == name)
            {
                return (T)child;
            }
        }

        return null;
    }

    public T? GetChild<T>() where T : Node
    {
        foreach (Node child in Children)
        {
            if (child.GetType() == typeof(T))
            {
                return (T)child;
            }
        }

        return null;
    }

    public Node GetChild(string name)
    {
        foreach (Node child in Children)
        {
            if (child.Name == name)
            {
                return child;
            }
        }

        SceneTree.Instance.RootNode?.PrintChildren();

        throw new InvalidOperationException($"Child node with name '{name}' not found.");
    }

    public Node? GetChildOrNull(string name)
    {
        foreach (Node child in Children)
        {
            if (child.Name == name)
            {
                return child;
            }
        }

        return null;
    }


    public Node AddChild(Node node)
    {
        node.Parent = this;

        node.Make();

        Children.Add(node);
        ChildAdded?.Invoke(this, node);

        return node;
    }

    public Node AddChild(Node node, string name)
    {
        node.Parent = this;
        node.Name = name;

        node.Make();

        Children.Add(node);
        ChildAdded?.Invoke(this, node);

        return node;
    }

    public WindowNode? GetOwningWindowNode()
    {
        Node? current = this;
        while (current != null)
        {
            if (current is WindowNode windowNode)
            {
                return windowNode;
            }
            current = current.Parent;
        }
        return null;
    }

    public Win32Window? GetOwningWindow()
    {
        Node? current = this;
        while (current != null)
        {
            if (current is WindowNode windowNode)
            {
                return windowNode.GetWindowHandle();
            }
            current = current.Parent;
        }
        return ApplicationServer.Instance.GetMainAppWindow();
    }

    public Vector2 GetWindowSizeV2()
    {
        var window = GetOwningWindow();
        if (window != null)
        {
            // Width and Height on Win32Window reflect the client area size updated by OnSize
            return new Vector2(window.Width, window.Height);
        }
        // Fallback default if no window context, e.g., during very early initialization
        return new Vector2(800, 600);
    }
}
</file>

<file path="Source\Node2D.cs">
namespace Cherris;

public class Node2D : VisualItem
{
    public Vector2 Position { get; set; } = Vector2.Zero;
    public virtual float Rotation { get; set; } = 0;
    public OriginPreset OriginPreset { get; set; } = OriginPreset.Center; // Note: OriginPreset is currently not used by Origin getter.
    public bool InheritScale { get; set; } = true;
    public HAlignment HAlignment { get; set; } = HAlignment.Center;
    public VAlignment VAlignment { get; set; } = VAlignment.Center;
    public AnchorPreset AnchorPreset { get; set; } = AnchorPreset.None;

    public float MarginLeft { get; set; } = 0f;
    public float MarginTop { get; set; } = 0f;
    public float MarginRight { get; set; } = 0f;
    public float MarginBottom { get; set; } = 0f;

    public float RelativeWidth { get; set; } = 0f; // 0 to 1. If > 0, overrides explicit width.
    public float RelativeHeight { get; set; } = 0f; // 0 to 1. If > 0, overrides explicit height.

    public Vector2 ScaledSize => Size * Scale;

    public virtual Vector2 Size
    {
        get
        {
            float finalWidth;
            float finalHeight;
            Vector2 parentSizeForRelative = Vector2.Zero;

            // Determine width
            if (RelativeWidth > 0f && RelativeWidth <= 1f)
            {
                if (parentSizeForRelative == Vector2.Zero)
                    parentSizeForRelative = (Parent is Node2D p) ? p.Size : GetWindowSizeV2();
                finalWidth = parentSizeForRelative.X * RelativeWidth;
            }
            else if (_explicitSize.X != 0f)
            {
                finalWidth = _explicitSize.X;
            }
            else
            {
                finalWidth = ComputeAutoSize().X;
            }

            // Determine height
            if (RelativeHeight > 0f && RelativeHeight <= 1f)
            {
                if (parentSizeForRelative == Vector2.Zero)
                    parentSizeForRelative = (Parent is Node2D p) ? p.Size : GetWindowSizeV2();
                finalHeight = parentSizeForRelative.Y * RelativeHeight;
            }
            else if (_explicitSize.Y != 0f)
            {
                finalHeight = _explicitSize.Y;
            }
            else
            {
                finalHeight = ComputeAutoSize().Y;
            }

            return new Vector2(finalWidth, finalHeight);
        }
        set
        {
            if (_explicitSize == value) return;
            _explicitSize = value;
            SizeChanged?.Invoke(this, Size);
        }
    }

    public virtual Vector2 Scale
    {
        get => InheritScale && Parent is Node2D node2DParent ? node2DParent.Scale : fieldScale; // Changed 'field' to 'fieldScale'
        set; // Changed 'field' to 'fieldScale'
    } = new(1, 1);

    public virtual Vector2 GlobalPosition
    {
        get
        {
            Vector2 parentGlobalTopLeft;
            Vector2 parentSize;

            if (Parent is Node2D parentNode)
            {
                parentGlobalTopLeft = parentNode.GlobalPosition - parentNode.Origin;
                parentSize = parentNode.Size;
            }
            else
            {
                parentGlobalTopLeft = Vector2.Zero;
                parentSize = GetWindowSizeV2();
            }

            float calculatedGlobalOriginX;
            float calculatedGlobalOriginY;

            if (AnchorPreset == AnchorPreset.None)
            {
                Vector2 parentOriginGlobal = (Parent is Node2D pNode) ? pNode.GlobalPosition : Vector2.Zero;
                calculatedGlobalOriginX = parentOriginGlobal.X + Position.X;
                calculatedGlobalOriginY = parentOriginGlobal.Y + Position.Y;
            }
            else
            {
                float targetGlobalAnchorX = AnchorPreset switch
                {
                    AnchorPreset.TopLeft or AnchorPreset.CenterLeft or AnchorPreset.BottomLeft
                        => parentGlobalTopLeft.X + MarginLeft,
                    AnchorPreset.TopCenter or AnchorPreset.Center or AnchorPreset.BottomCenter
                        => parentGlobalTopLeft.X + (parentSize.X * 0.5f) + MarginLeft - MarginRight,
                    _
                        => parentGlobalTopLeft.X + parentSize.X - MarginRight,
                };

                float targetGlobalAnchorY = AnchorPreset switch
                {
                    AnchorPreset.TopLeft or AnchorPreset.TopCenter or AnchorPreset.TopRight
                        => parentGlobalTopLeft.Y + MarginTop,
                    AnchorPreset.CenterLeft or AnchorPreset.Center or AnchorPreset.CenterRight
                        => parentGlobalTopLeft.Y + (parentSize.Y * 0.5f) + MarginTop - MarginBottom,
                    _
                        => parentGlobalTopLeft.Y + parentSize.Y - MarginBottom,
                };

                calculatedGlobalOriginX = targetGlobalAnchorX;
                calculatedGlobalOriginY = targetGlobalAnchorY;

                calculatedGlobalOriginX += Position.X;
                calculatedGlobalOriginY += Position.Y;
            }

            return new(calculatedGlobalOriginX, calculatedGlobalOriginY);
        }
    }

    public Vector2 Offset { get; set; }

    public Vector2 Origin
    {
        get
        {
            float x = HAlignment switch
            {
                HAlignment.Center => Size.X / 2f,
                HAlignment.Left => 0,
                HAlignment.Right => Size.X,
                HAlignment.None => 0,
                _ => 0
            };

            float y = VAlignment switch
            {
                VAlignment.Center => Size.Y / 2f,
                VAlignment.Top => 0,
                VAlignment.Bottom => Size.Y,
                VAlignment.None => 0,
                _ => 0
            };

            Vector2 alignmentOffset = new(x, y);
            return alignmentOffset + Offset;
        }
    }

    protected Vector2 _explicitSize = Vector2.Zero;
    private Vector2 fieldScale = new(1, 1);

    public event EventHandler<Vector2>? SizeChanged;

    protected virtual Vector2 ComputeAutoSize()
    {
        return Vector2.Zero; // Default behavior: no auto-size, relies on explicit or relative.
    }

    public void LookAt(Vector2 targetPosition)
    {
        Vector2 originPoint = GlobalPosition;
        Vector2 direction = targetPosition - originPoint;
        var angle = float.Atan2(direction.Y, direction.X) * 57.29578f;
        Rotation = angle;
    }
}
</file>

<file path="Source\NodeEmoji.cs">
namespace Cherris;

public static class NodeEmoji
{
    public static string GetEmojiForNodeType(Node node)
    {
        return node switch
        {
            //ParticleEmitter => "",
            //Slider => "",
            //Label => "",
            //Camera => "",
            //RayCast => "",
            //Timer => "",
            //NavigationRegion => "",
            //NavigationAgent => "",
            //AudioPlayer => "",
            //Collider => "",
            //Sprite => "",
            //Button => "",
            //ColorRectangle => "",
            //Node2D => "",
            _ => "",
        };
    }
}
</file>

<file path="Source\RenderServer.cs">
using Raylib_cs;

namespace Cherris;

public sealed class RenderServer
{
    private static RenderServer? _instance;
    public static RenderServer Instance => _instance ??= new();

    public Camera? Camera;
    public Shader? PostProcessingShader { get; set; }

    private readonly List<DrawCommand> drawCommands = [];
    private RenderTexture2D renderTexture;

    // Main

    private RenderServer()
    {
        var mainWin = ApplicationServer.Instance.GetMainAppWindow();
        Vector2 windowSize = mainWin != null ? new Vector2(mainWin.Width, mainWin.Height) : new Vector2(800, 600); // Default fallback
        renderTexture = Raylib.LoadRenderTexture((int)windowSize.X, (int)windowSize.Y);

        // DisplayServer.Instance.WindowSizeChanged -= WindowSizeChanged; // Event is removed from DisplayServer
        // The logic for resizing renderTexture needs a new mechanism if used with multiple/dynamic window sizes.
        // For now, it's initialized with main window size and won't resize automatically based on DisplayServer events.

        //PostProcessingShader = Shader.Load(null, "Res/Shaders/Bloom.fs");
    }

    // This method is no longer automatically called by DisplayServer event.
    // If renderTexture needs to resize, another mechanism is required.
    private void WindowSizeChanged(Vector2 newSize)
    {
        Raylib.UnloadRenderTexture(renderTexture); // Unload old texture
        renderTexture = Raylib.LoadRenderTexture(
            (int)newSize.X,
            (int)newSize.Y);
    }

    public void Process()
    {
        Raylib.BeginTextureMode(renderTexture);
        //Raylib.ClearBackground(Color.DarkGray);
        BeginCameraMode();
        ProcessDrawCommands();
        EndCameraMode();
        Raylib.EndTextureMode();

        BeginShaderMode(PostProcessingShader);
        //Rectangle source = new(0, 0, renderTexture.Texture.Width, -renderTexture.Texture.Height);
        //Raylib.DrawTextureRec(renderTexture.Texture, source, Vector2.Zero, Color.White);
        EndShaderMode();
    }

    public void Process2()
    {
        //Raylib.ClearBackground(Color.DarkGray);
        //BeginShaderMode(PostProcessingShader);
        //    BeginCameraMode();
        //        ProcessDrawCommands();
        //    EndCameraMode();
        //EndShaderMode();
    }

    public void Submit(Action drawAction, int layer)
    {
        drawCommands.Add(new(drawAction, layer));
    }

    public Vector2 GetScreenToWorld(Vector2 position)
    {
        return Camera is null
            ? position
            : Raylib.GetScreenToWorld2D(position, Camera);
    }

    public Vector2 GetWorldToScreen(Vector2 position)
    {
        return Camera is null
            ? position
            : Raylib.GetWorldToScreen2D(position, Camera);
    }

    // Scissor mode

    public static void BeginScissorMode(Vector2 position, Vector2 size)
    {
        Raylib.BeginScissorMode(
            (int)position.X,
            (int)position.Y,
            (int)size.X,
            (int)size.Y);
    }

    public static void EndScissorMode()
    {
        Raylib.EndScissorMode();
    }

    // Camera

    public void SetCamera(Camera camera)
    {
        Camera = camera;
    }

    private void BeginCameraMode()
    {
        if (Camera is null)
        {
            return;
        }

        // Use the Camera's owning window size for offset
        Vector2 windowSize = Camera.GetWindowSizeV2();

        Camera2D cam = new()
        {
            Target = Camera.GlobalPosition,
            Offset = windowSize / 2,
            Zoom = Camera.Zoom,
        };

        Raylib.BeginMode2D(cam);
    }

    private void EndCameraMode()
    {
        if (Camera is null)
        {
            return;
        }

        Raylib.EndMode2D();
    }

    // Shader mode

    public static void BeginShaderMode(Shader? shader)
    {
        if (shader is null)
        {
            return;
        }

        Raylib.BeginShaderMode(shader);
    }

    public static void EndShaderMode()
    {
        Raylib.EndShaderMode();
    }

    // Other

    private void ProcessDrawCommands()
    {
        foreach (DrawCommand command in drawCommands.OrderBy(c => c.Layer))
        {
            command.DrawAction.Invoke();
        }

        drawCommands.Clear();
    }

    private class DrawCommand(Action drawAction, int layer)
    {
        public Action DrawAction { get; } = drawAction;
        public int Layer { get; } = layer;
    }
}
</file>

<file path="Source\ResourceLoader.cs">
namespace Cherris;

public sealed class ResourceLoader
{
    public static T? Load<T>(string path)
    {
        return typeof(T) switch
        {
            var t when t == typeof(AudioStream) => (T)(object)AudioStreamCache.Instance.Get(path)!,
            var t when t == typeof(Texture) => (T)(object)TextureCache.Instance.Get(path),
            var t when t == typeof(Font) => (T)(object)FontCache.Instance.Get(path),
            var t when t == typeof(Sound) => (T)(object)SoundCache.Instance.Get(path),
            var t when t == typeof(Animation) => (T)(object)AnimationCache.Instance.Get(path),
            _ => throw new InvalidOperationException($"Unsupported resource type: {typeof(T)}")
        };
    }
}
</file>

<file path="Source\SecondaryWindow.cs">
namespace Cherris;

public class SecondaryWindow : Direct2DAppWindow
{
    private readonly WindowNode ownerNode;
    private Vector2 currentMousePosition = Vector2.Zero;

    public SecondaryWindow(string title, int width, int height, WindowNode owner)
        : base(title, width, height)
    {
        ownerNode = owner ?? throw new ArgumentNullException(nameof(owner));
        ApplicationServer.Instance.RegisterSecondaryWindow(this);
    }

    protected override void DrawUIContent(DrawingContext context)
    {
        ownerNode?.RenderChildren(context);
    }

    protected override bool OnClose()
    {
        Log.Info($"SecondaryWindow '{Title}' OnClose called.");
        ownerNode?.QueueFree();
        return base.OnClose();
    }

    protected override void Cleanup()
    {
        Log.Info($"SecondaryWindow '{Title}' Cleanup starting.");
        base.Cleanup();
        Log.Info($"SecondaryWindow '{Title}' Cleanup finished.");
    }

    protected override IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        int xPos = NativeMethods.GET_X_LPARAM(lParam);
        int yPos = NativeMethods.GET_Y_LPARAM(lParam);
        Vector2 mousePos = new Vector2(xPos, yPos);

        currentMousePosition = mousePos; // Update local mouse position for this window

        switch (msg)
        {
            case NativeMethods.WM_MOUSEMOVE:
                Input.UpdateMousePosition(currentMousePosition); // Update global Input state
                // Allow base.HandleMessage to call OnMouseMove and other logic
                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_LBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Left, true);
                break;
            case NativeMethods.WM_LBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Left, false);
                break;

            case NativeMethods.WM_RBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Right, true);
                break;
            case NativeMethods.WM_RBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Right, false);
                break;

            case NativeMethods.WM_MBUTTONDOWN:
                Input.UpdateMouseButton(MouseButtonCode.Middle, true);
                break;
            case NativeMethods.WM_MBUTTONUP:
                Input.UpdateMouseButton(MouseButtonCode.Middle, false);
                break;

            case NativeMethods.WM_XBUTTONDOWN:
                int xButton1 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton1 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, true);
                if (xButton1 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, true);
                break;
            case NativeMethods.WM_XBUTTONUP:
                int xButton2 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                if (xButton2 == NativeMethods.XBUTTON1) Input.UpdateMouseButton(MouseButtonCode.Side, false);
                if (xButton2 == NativeMethods.XBUTTON2) Input.UpdateMouseButton(MouseButtonCode.Extra, false);
                break;

            case NativeMethods.WM_MOUSEWHEEL:
                short wheelDelta = NativeMethods.GET_WHEEL_DELTA_WPARAM(wParam);
                Input.UpdateMouseWheel((float)wheelDelta / NativeMethods.WHEEL_DELTA);
                break;

            case NativeMethods.WM_KEYDOWN:
            case NativeMethods.WM_SYSKEYDOWN:
                int vkCodeDown = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeDown))
                {
                    Input.UpdateKey((KeyCode)vkCodeDown, true);
                }
                // Allow base.HandleMessage for default key processing
                return base.HandleMessage(hWnd, msg, wParam, lParam);

            case NativeMethods.WM_KEYUP:
            case NativeMethods.WM_SYSKEYUP:
                int vkCodeUp = (int)wParam;
                if (Enum.IsDefined(typeof(KeyCode), vkCodeUp))
                {
                    Input.UpdateKey((KeyCode)vkCodeUp, false);
                }
                // KeyUp often doesn't need default processing if KeyDown handled it
                return IntPtr.Zero;
        }

        return base.HandleMessage(hWnd, msg, wParam, lParam);
    }

    public Vector2 GetLocalMousePosition() => currentMousePosition;
}
</file>

<file path="Source\SystemBackdropType.cs">
namespace Cherris;

public enum SystemBackdropType
{
    None,
    Mica,
    Acrylic,
    MicaAlt
}
</file>

<file path="Source\Time.cs">
namespace Cherris;

public class Time
{
    public static float Delta { get; internal set; } = 1f / 60f; // Default to 60 FPS
}
</file>

<file path="Source\Tween.cs">
using System.Reflection;

namespace Cherris;

public class Tween(Node creatorNode, Node.ProcessMode processMode = Node.ProcessMode.Inherit)
{
    public bool Active = true;

    private readonly List<TweenStep> steps = [];
    private readonly Node creatorNode = creatorNode;
    private readonly Node.ProcessMode processMode = processMode;

    private static readonly bool debug = false;

    public bool Stopped { get; private set; }

    public void Stop()
    {
        Stopped = true;
        Active = false;
    }

    public void TweenProperty(Node node, string propertyPath, float targetValue, float duration)
    {
        try
        {
            ArgumentNullException.ThrowIfNull(node);

            if (string.IsNullOrEmpty(propertyPath))
            {
                throw new ArgumentException("Property path cannot be null or empty.", nameof(propertyPath));
            }

            Log.Info($"[Tween] Starting tween on {node.Name} for {propertyPath}", debug);

            float startValue = GetFloatValue(node, propertyPath);

            Log.Info($"[Tween] Start value: {startValue}  Target: {targetValue} ({duration}s)", debug);

            steps.Add(new TweenStep(node, propertyPath, startValue, targetValue, duration));
        }
        catch (Exception ex)
        {
            Log.Error($"[Tween] Error starting tween: {ex}");
            Active = false;
        }
    }

    public void Update(float delta)
    {
        if (!Active || Stopped)
        {
            return;
        }

        foreach (TweenStep step in steps.ToList())
        {
            step.Elapsed += delta;
            float t = Math.Clamp(step.Elapsed / step.Duration, 0, 1);
            float currentValue = step.StartValue + (step.EndValue - step.StartValue) * t;

            Log.Info($"[Tween] Updating {step.Node.Name}.{step.PropertyPath} {currentValue:0.00} ({t:P0})", debug);

            SetFloatValueDirect(step.Node, step.PropertyPath, currentValue);

            if (step.Elapsed >= step.Duration)
            {
                Log.Info($"[Tween] Completed {step.Node.Name}.{step.PropertyPath}", debug);
                steps.Remove(step);
            }
        }

        if (steps.Count == 0)
        {
            Log.Info("[Tween] All steps completed", debug);
            Active = false;
        }
    }

    public bool ShouldProcess(bool treePaused)
    {
        var effectiveMode = processMode == Node.ProcessMode.Inherit
            ? GetEffectiveProcessMode(creatorNode)
            : processMode;

        return effectiveMode switch
        {
            Node.ProcessMode.Disabled => false,
            Node.ProcessMode.Always => true,
            Node.ProcessMode.Pausable => !treePaused,
            Node.ProcessMode.WhenPaused => treePaused,
            _ => false
        };
    }

    private static Node.ProcessMode GetEffectiveProcessMode(Node node)
    {
        Node? current = node;

        while (current != null)
        {
            if (current.ProcessingMode != Node.ProcessMode.Inherit)
            {
                return current.ProcessingMode;
            }

            current = current.Parent;
        }

        return Node.ProcessMode.Pausable;
    }

    private static float GetFloatValue(Node node, string propertyPath)
    {
        object? current = node;

        foreach (string part in propertyPath.Split('/'))
        {
            if (current is null)
            {
                throw new InvalidOperationException(
                    $"Intermediate value is null in path '{propertyPath}' on node {node.Name}");
            }

            Type type = current.GetType();
            PropertyInfo? property = type.GetProperty(part);
            FieldInfo? field = type.GetField(part);

            MemberInfo? member = property ?? (MemberInfo?)field
                ?? throw new ArgumentException($"Property or field '{part}' not found in {type.Name}");

            current = member is PropertyInfo prop
                ? prop.GetValue(current)
                : ((FieldInfo)member).GetValue(current);
        }

        return current is not null
            ? (float)current
            : throw new InvalidOperationException($"Value for path '{propertyPath}' is null on node {node.Name}");
    }

    private static void SetFloatValueDirect(Node node, string propertyPath, float value)
    {
        string[] parts = propertyPath.Split('/');
        object? current = node;

        for (int i = 0; i < parts.Length - 1; i++)
        {
            if (current is null)
            {
                throw new InvalidOperationException(
                    $"Intermediate value is null in path '{propertyPath}' on node {node.Name}");
            }

            Type type = current.GetType();
            PropertyInfo? property = type.GetProperty(parts[i]);
            FieldInfo? field = type.GetField(parts[i]);

            MemberInfo? member = property ?? (MemberInfo?)field
                ?? throw new ArgumentException($"Property or field '{parts[i]}' not found in {type.Name}");

            current = member is PropertyInfo prop
                ? prop.GetValue(current)
                : ((FieldInfo)member).GetValue(current);
        }

        if (current is null)
        {
            throw new InvalidOperationException(
                $"Final target is null in path '{propertyPath}' on node {node.Name}");
        }

        Type finalType = current.GetType();
        string finalPart = parts[^1];
        PropertyInfo? finalProperty = finalType.GetProperty(finalPart);
        FieldInfo? finalField = finalType.GetField(finalPart);

        MemberInfo finalMember = finalProperty ?? (MemberInfo?)finalField
            ?? throw new ArgumentException($"Property or field '{finalPart}' not found in {finalType.Name}");

        if (finalMember is PropertyInfo targetProp)
        {
            targetProp.SetValue(current, value);
        }
        else if (finalMember is FieldInfo targetField)
        {
            targetField.SetValue(current, value);
        }
    }

    private record TweenStep(Node Node, string PropertyPath, float StartValue, float EndValue, float Duration)
    {
        public float Elapsed { get; set; }
    }
}
</file>

<file path="Source\VerticalAlignment.cs">
namespace Cherris;

public enum VAlignment
{
    Top,
    Center,
    Bottom,
    None
}
</file>

<file path="Source\VisualItem.cs">
using SharpGen.Runtime;
using Vortice.Direct2D1;
using Vortice.DirectWrite;
using Vortice.Mathematics;
using D2D = Vortice.Direct2D1;
using DW = Vortice.DirectWrite;

namespace Cherris;

public abstract class VisualItem : Node
{
    private bool fieldVisible = true;
    private int fieldLayer = 0;


    public bool Visible
    {
        get => fieldVisible;
        set
        {
            if (fieldVisible == value)
            {
                return;
            }

            fieldVisible = value;
            VisibleChanged?.Invoke(this, fieldVisible);
        }
    }

    public int Layer
    {
        get => fieldLayer;
        set
        {
            if (fieldLayer == value)
            {
                return;
            }

            fieldLayer = value;
            LayerChanged?.Invoke(this, fieldLayer);
        }
    }

    public delegate void VisibleEvent(VisualItem sender, bool visible);
    public delegate void LayerEvent(VisualItem sender, int layer);

    public event VisibleEvent? VisibleChanged;
    public event LayerEvent? LayerChanged;

    public virtual void Draw(DrawingContext context) { }


    protected void DrawStyledRectangle(DrawingContext context, Rect bounds, BoxStyle style)
    {
        if (context.OwnerWindow is null || context.RenderTarget is null || style is null || bounds.Width <= 0 || bounds.Height <= 0)
        {
            return;
        }

        try
        {
            DrawBoxStyleHelper(context, bounds, style);
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Warning("Recreate target detected in DrawStyledRectangle.");
        }
        catch (Exception ex)
        {
            Log.Error($"Error drawing styled rectangle: {ex.Message}");
        }
    }

    protected void DrawFormattedText(DrawingContext context, string text, Rect layoutRect, ButtonStyle style, HAlignment hAlignment, VAlignment vAlignment)
    {
        if (string.IsNullOrEmpty(text) || context.OwnerWindow is null || context.RenderTarget is null || style is null || layoutRect.Width <= 0 || layoutRect.Height <= 0)
        {
            return;
        }

        ID2D1SolidColorBrush? textBrush = context.OwnerWindow.GetOrCreateBrush(style.FontColor);
        IDWriteTextFormat? textFormat = context.OwnerWindow.GetOrCreateTextFormat(style);

        if (textBrush is null || textFormat is null)
        {

            return;
        }

        try
        {
            textFormat.TextAlignment = hAlignment switch
            {
                HAlignment.Left => DW.TextAlignment.Leading,
                HAlignment.Center => DW.TextAlignment.Center,
                HAlignment.Right => DW.TextAlignment.Trailing,
                _ => DW.TextAlignment.Leading
            };
            textFormat.ParagraphAlignment = vAlignment switch
            {
                VAlignment.Top => DW.ParagraphAlignment.Near,
                VAlignment.Center => DW.ParagraphAlignment.Center,
                VAlignment.Bottom => DW.ParagraphAlignment.Far,
                _ => DW.ParagraphAlignment.Near
            };

            context.RenderTarget.DrawText(
                text,
                textFormat,
                layoutRect,
                textBrush,
                D2D.DrawTextOptions.Clip
            );
        }
        catch (SharpGenException ex) when (ex.ResultCode.Code == D2D.ResultCode.RecreateTarget.Code)
        {
            Log.Warning("Recreate target detected in DrawFormattedText.");


        }
        catch (Exception ex)
        {
            Log.Error($"Error drawing formatted text '{text}': {ex.Message}");
        }
    }


    private static void DrawBoxStyleHelper(DrawingContext context, Rect bounds, BoxStyle style)
    {
        ID2D1HwndRenderTarget? renderTarget = context.RenderTarget;
        Direct2DAppWindow? ownerWindow = context.OwnerWindow;
        if (renderTarget is null || ownerWindow is null || style is null || bounds.Width <= 0 || bounds.Height <= 0)
        {
            return;
        }

        ID2D1SolidColorBrush? fillBrush = ownerWindow.GetOrCreateBrush(style.FillColor);
        ID2D1SolidColorBrush? borderBrush = ownerWindow.GetOrCreateBrush(style.BorderColor);

        float borderTop = Math.Max(0f, style.BorderLengthTop);
        float borderRight = Math.Max(0f, style.BorderLengthRight);
        float borderBottom = Math.Max(0f, style.BorderLengthBottom);
        float borderLeft = Math.Max(0f, style.BorderLengthLeft);

        bool hasVisibleFill = style.FillColor.A > 0 && fillBrush is not null;
        bool hasVisibleBorder = style.BorderColor.A > 0 && borderBrush is not null && (borderTop > 0 || borderRight > 0 || borderBottom > 0 || borderLeft > 0);

        if (!hasVisibleFill && !hasVisibleBorder) return;

        if (style.Roundness > 0.0f)
        {
            float maxRadius = Math.Min(bounds.Width * 0.5f, bounds.Height * 0.5f);
            float radius = Math.Max(0f, maxRadius * float.Clamp(style.Roundness, 0.0f, 1.0f));

            if (float.IsFinite(radius) && radius >= 0)
            {
                if (hasVisibleBorder && borderBrush is not null)
                {
                    System.Drawing.RectangleF outerRectF = new(bounds.X, bounds.Y, bounds.Width, bounds.Height);
                    RoundedRectangle outerRoundedRect = new(outerRectF, radius, radius);
                    renderTarget.FillRoundedRectangle(outerRoundedRect, borderBrush);
                }

                if (hasVisibleFill && fillBrush is not null)
                {
                    float fillX = bounds.X + borderLeft;
                    float fillY = bounds.Y + borderTop;
                    float fillWidth = Math.Max(0f, bounds.Width - borderLeft - borderRight);
                    float fillHeight = Math.Max(0f, bounds.Height - borderTop - borderBottom);

                    if (fillWidth > 0 && fillHeight > 0)
                    {
                        float avgBorderX = (borderLeft + borderRight) * 0.5f;
                        float avgBorderY = (borderTop + borderBottom) * 0.5f;
                        float innerRadiusX = Math.Max(0f, radius - avgBorderX);
                        float innerRadiusY = Math.Max(0f, radius - avgBorderY);

                        System.Drawing.RectangleF fillRectF = new(fillX, fillY, fillWidth, fillHeight);
                        RoundedRectangle fillRoundedRect = new(fillRectF, innerRadiusX, innerRadiusY);
                        renderTarget.FillRoundedRectangle(fillRoundedRect, fillBrush);
                    }
                    else if (!hasVisibleBorder)
                    {
                        System.Drawing.RectangleF outerRectF = new(bounds.X, bounds.Y, bounds.Width, bounds.Height);
                        RoundedRectangle outerRoundedRect = new(outerRectF, radius, radius);
                        renderTarget.FillRoundedRectangle(outerRoundedRect, fillBrush);
                    }
                }
                return;
            }
        }

        if (hasVisibleBorder && borderBrush is not null)
        {
            renderTarget.FillRectangle(bounds, borderBrush);
        }

        if (hasVisibleFill && fillBrush is not null)
        {
            float fillX = bounds.X + borderLeft;
            float fillY = bounds.Y + borderTop;
            float fillWidth = Math.Max(0f, bounds.Width - borderLeft - borderRight);
            float fillHeight = Math.Max(0f, bounds.Height - borderTop - borderBottom);

            if (fillWidth > 0 && fillHeight > 0)
            {
                renderTarget.FillRectangle(new Rect(fillX, fillY, fillWidth, fillHeight), fillBrush);
            }
            else if (!hasVisibleBorder)
            {

                renderTarget.FillRectangle(bounds, fillBrush);
            }
        }
    }
}
</file>

<file path="Source\Win32Window.cs">
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Cherris;

public abstract class Win32Window : IDisposable
{
    private readonly string _windowClassName;
    private readonly string _windowTitle;
    private readonly int _initialWidth;
    private readonly int _initialHeight;
    private IntPtr _hwnd = IntPtr.Zero;
    private IntPtr _hInstance = IntPtr.Zero;
    private NativeMethods.WndProc _wndProcDelegate;
    private bool _isDisposed = false;
    private static readonly HashSet<string> RegisteredClassNames = new HashSet<string>();
    private GCHandle _gcHandle;

    public IntPtr Handle => _hwnd;
    public string Title => _windowTitle;
    public int Width { get; protected set; }
    public int Height { get; protected set; }
    public bool IsOpen { get; private set; } = false;
    public SystemBackdropType BackdropType { get; set; } = SystemBackdropType.None;
    public bool VSyncEnabled { get; set; } = true;

    protected Win32Window(string title, int width, int height, string className = null)
    {
        _windowTitle = title ?? "Win32 Window";
        _initialWidth = width > 0 ? width : 800;
        _initialHeight = height > 0 ? height : 600;
        Width = _initialWidth;
        Height = _initialHeight;
        _windowClassName = className ?? ("Win32Window_" + Guid.NewGuid().ToString("N"));
        _wndProcDelegate = WindowProcedure;
    }

    public virtual bool TryCreateWindow(IntPtr ownerHwnd = default, uint? styleOverride = null)
    {
        if (_hwnd != IntPtr.Zero)
        {
            Log.Warning("Window handle already exists. Creation skipped.");
            return true;
        }

        _hInstance = NativeMethods.GetModuleHandle(null);
        if (_hInstance == IntPtr.Zero)
        {
            _hInstance = Process.GetCurrentProcess().Handle;
        }

        lock (RegisteredClassNames)
        {
            if (!RegisteredClassNames.Contains(_windowClassName))
            {
                var wndClass = new NativeMethods.WNDCLASSEX
                {
                    cbSize = Marshal.SizeOf(typeof(NativeMethods.WNDCLASSEX)),
                    style = NativeMethods.CS_HREDRAW | NativeMethods.CS_VREDRAW | NativeMethods.CS_OWNDC,
                    lpfnWndProc = _wndProcDelegate,
                    cbClsExtra = 0,
                    cbWndExtra = 0,
                    hInstance = _hInstance,
                    hIcon = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)NativeMethods.IDI_APPLICATION),
                    hCursor = NativeMethods.LoadCursor(IntPtr.Zero, NativeMethods.IDC_ARROW),
                    hbrBackground = IntPtr.Zero,
                    lpszMenuName = null,
                    lpszClassName = _windowClassName,
                    hIconSm = NativeMethods.LoadIcon(IntPtr.Zero, (IntPtr)NativeMethods.IDI_APPLICATION)
                };

                if (NativeMethods.RegisterClassEx(ref wndClass) == 0)
                {
                    Log.Error($"RegisterClassEx failed: {Marshal.GetLastWin32Error()}");
                    return false;
                }
                RegisteredClassNames.Add(_windowClassName);
                Log.Info($"Class '{_windowClassName}' registered.");
            }
        }

        _gcHandle = GCHandle.Alloc(this);

        uint windowStyle = styleOverride ?? NativeMethods.WS_OVERLAPPEDWINDOW;

        _hwnd = NativeMethods.CreateWindowEx(
            0,
            _windowClassName,
            _windowTitle,
            windowStyle,
            NativeMethods.CW_USEDEFAULT, NativeMethods.CW_USEDEFAULT,
            _initialWidth, _initialHeight,
            ownerHwnd,
            IntPtr.Zero,
            _hInstance,
            GCHandle.ToIntPtr(_gcHandle));

        if (_hwnd == IntPtr.Zero)
        {
            Log.Error($"CreateWindowEx failed: {Marshal.GetLastWin32Error()}");
            if (_gcHandle.IsAllocated) _gcHandle.Free();
            return false;
        }

        Log.Info($"Window '{_windowTitle}' created with HWND: {_hwnd}");
        IsOpen = true;

        return true;
    }

    protected virtual NativeMethods.DWMSBT GetSystemBackdropType()
    {
        return BackdropType switch
        {
            SystemBackdropType.Mica => NativeMethods.DWMSBT.DWMSBT_MAINWINDOW,
            SystemBackdropType.Acrylic => NativeMethods.DWMSBT.DWMSBT_TRANSIENTWINDOW,
            SystemBackdropType.MicaAlt => NativeMethods.DWMSBT.DWMSBT_TABBEDWINDOW,
            SystemBackdropType.None => NativeMethods.DWMSBT.DWMSBT_NONE,
            _ => NativeMethods.DWMSBT.DWMSBT_AUTO
        };
    }

    public void ApplySystemBackdrop()
    {
        if (_hwnd == IntPtr.Zero || !IsOpen) return;

        var backdropTypeEnum = GetSystemBackdropType();
        if (backdropTypeEnum == NativeMethods.DWMSBT.DWMSBT_NONE)
        {
            Log.Info($"Skipping backdrop application for '{Title}' (Type: None).");
            return;
        }

        var osVersion = Environment.OSVersion.Version;
        int requiredBuild = 22621;

        if (osVersion.Major < 10 || (osVersion.Major == 10 && osVersion.Build < requiredBuild))
        {
            Log.Warning($"System backdrop type {BackdropType} ({backdropTypeEnum}) requires Windows 11 Build {requiredBuild} or later. Current: {osVersion}");
            return;
        }

        try
        {
            int backdropTypeValue = (int)backdropTypeEnum;
            int result = NativeMethods.DwmSetWindowAttribute(
                _hwnd,
                NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_SYSTEMBACKDROP_TYPE,
                ref backdropTypeValue,
                sizeof(int));

            if (result != 0)
            {
                Log.Error($"DwmSetWindowAttribute failed for {NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_SYSTEMBACKDROP_TYPE} with HRESULT: 0x{result:X8} on HWND {_hwnd} ('{_windowTitle}').");
                return;
            }
            Log.Info($"Applied system backdrop type {BackdropType} ({backdropTypeEnum}) to HWND {_hwnd} ('{_windowTitle}').");

            int useDarkMode = 1;
            result = NativeMethods.DwmSetWindowAttribute(
                _hwnd,
                NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE,
                ref useDarkMode,
                sizeof(int));

            if (result != 0)
            {
                Log.Warning($"DwmSetWindowAttribute failed for {NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE} with HRESULT: 0x{result:X8} on HWND {_hwnd} ('{_windowTitle}'). This might be expected on some builds.");
            }
            else
            {
                Log.Info($"Applied {NativeMethods.DWMWINDOWATTRIBUTE.DWMWA_USE_IMMERSIVE_DARK_MODE}=TRUE to HWND {_hwnd} ('{_windowTitle}').");
            }
        }
        catch (Exception ex)
        {
            Log.Error($"Exception applying system backdrop/theme attributes to HWND {_hwnd} ('{_windowTitle}'): {ex.Message}");
        }
    }

    public virtual void ShowWindow()
    {
        if (_hwnd != IntPtr.Zero && IsOpen)
        {
            NativeMethods.ShowWindow(_hwnd, NativeMethods.SW_SHOWNORMAL);
            NativeMethods.UpdateWindow(_hwnd);
        }
        else
        {
            Log.Warning($"Cannot show window '{Title}': Handle is zero or window is not open.");
        }
    }

    public bool InitializeWindowAndGraphics()
    {
        if (_hwnd == IntPtr.Zero || !IsOpen)
        {
            Log.Error($"Cannot initialize '{Title}': Window handle is invalid or window is closed.");
            return false;
        }

        ApplySystemBackdrop();

        if (!Initialize())
        {
            Log.Error($"Custom initialization failed for '{Title}'.");
            return false;
        }

        return true;
    }

    private static IntPtr WindowProcedure(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        Win32Window? window = null;

        if (msg == NativeMethods.WM_NCCREATE)
        {
            try
            {
                var cs = Marshal.PtrToStructure<NativeMethods.CREATESTRUCT>(lParam);
                var handle = GCHandle.FromIntPtr(cs.lpCreateParams);
                window = handle.Target as Win32Window;
                if (window != null)
                {
                    NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, GCHandle.ToIntPtr(handle));
                }
                else
                {
                    Log.Warning($"WM_NCCREATE: Failed to get window instance from GCHandle for HWND {hWnd}");
                }
            }
            catch (Exception ex)
            {
                Log.Error($"Error during WM_NCCREATE: {ex}");
            }
        }
        else
        {
            IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);
            if (ptr != IntPtr.Zero)
            {
                try
                {
                    var handle = GCHandle.FromIntPtr(ptr);
                    if (handle.IsAllocated && handle.Target != null)
                    {
                        window = handle.Target as Win32Window;
                    }
                }
                catch (InvalidOperationException)
                {
                    NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero);
                }
                catch (Exception ex)
                {
                    Log.Error($"Error retrieving GCHandle: {ex}");
                }
            }
        }

        if (window != null)
        {
            try
            {
                return window.HandleMessage(hWnd, msg, wParam, lParam);
            }
            catch (Exception ex)
            {
                Log.Error($"Error handling message {msg} for HWND {hWnd} ('{window.Title}'): {ex}");
            }
        }

        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    protected virtual IntPtr HandleMessage(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)
    {
        int xPos = NativeMethods.GET_X_LPARAM(lParam);
        int yPos = NativeMethods.GET_Y_LPARAM(lParam);

        switch (msg)
        {
            case NativeMethods.WM_PAINT:
                RenderFrame();
                NativeMethods.ValidateRect(hWnd, IntPtr.Zero);
                return IntPtr.Zero;

            case NativeMethods.WM_SIZE:
                Width = NativeMethods.LOWORD(lParam);
                Height = NativeMethods.HIWORD(lParam);
                OnSize(Width, Height);
                return IntPtr.Zero;

            case NativeMethods.WM_MOUSEMOVE:
                OnMouseMove(xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_LBUTTONDOWN:
                OnMouseDown(MouseButton.Left, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_LBUTTONUP:
                OnMouseUp(MouseButton.Left, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_RBUTTONDOWN:
                OnMouseDown(MouseButton.Right, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_RBUTTONUP:
                OnMouseUp(MouseButton.Right, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_MBUTTONDOWN:
                OnMouseDown(MouseButton.Middle, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_MBUTTONUP:
                OnMouseUp(MouseButton.Middle, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_XBUTTONDOWN:
                int xButton1 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                OnMouseDown(xButton1 == NativeMethods.XBUTTON1 ? MouseButton.XButton1 : MouseButton.XButton2, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_XBUTTONUP:
                int xButton2 = NativeMethods.GET_XBUTTON_WPARAM(wParam);
                OnMouseUp(xButton2 == NativeMethods.XBUTTON1 ? MouseButton.XButton1 : MouseButton.XButton2, xPos, yPos);
                return IntPtr.Zero;

            case NativeMethods.WM_MOUSEWHEEL:
                short wheelDelta = NativeMethods.GET_WHEEL_DELTA_WPARAM(wParam);
                OnMouseWheel(wheelDelta);
                return IntPtr.Zero;

            case NativeMethods.WM_KEYDOWN:
            case NativeMethods.WM_SYSKEYDOWN:
                int vkCodeDown = (int)wParam;
                OnKeyDown(vkCodeDown);

                if (vkCodeDown == NativeMethods.VK_ESCAPE && !IsKeyDownHandled(vkCodeDown))
                {
                    Close();
                }
                return IntPtr.Zero;

            case NativeMethods.WM_KEYUP:
            case NativeMethods.WM_SYSKEYUP:
                int vkCodeUp = (int)wParam;
                OnKeyUp(vkCodeUp);
                return IntPtr.Zero;

            case NativeMethods.WM_DWMCOMPOSITIONCHANGED:
                Log.Info($"WM_DWMCOMPOSITIONCHANGED received for {hWnd} ('{Title}'). Reapplying backdrop.");
                ApplySystemBackdrop();
                break;

            case NativeMethods.WM_CLOSE:
                if (OnClose())
                {
                    NativeMethods.DestroyWindow(hWnd);
                }
                return IntPtr.Zero;

            case NativeMethods.WM_DESTROY:
                Log.Info($"WM_DESTROY for {hWnd} ('{Title}').");
                OnDestroy();

                if (this is MainAppWindow)
                {
                    Log.Info("Main window destroyed, posting quit message.");
                    NativeMethods.PostQuitMessage(0);
                }
                else if (this is SecondaryWindow secWin)
                {
                    ApplicationServer.Instance.UnregisterSecondaryWindow(secWin);
                }
                return IntPtr.Zero;

            case NativeMethods.WM_NCDESTROY:
                Log.Info($"WM_NCDESTROY: Releasing GCHandle for {hWnd} ('{Title}').");
                IntPtr ptr = NativeMethods.GetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA);
                if (ptr != IntPtr.Zero)
                {
                    try
                    {
                        var handle = GCHandle.FromIntPtr(ptr);
                        if (handle.IsAllocated)
                        {
                            handle.Free();
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Error($"Error freeing GCHandle on NCDESTROY: {ex.Message}");
                    }
                    NativeMethods.SetWindowLongPtr(hWnd, NativeMethods.GWLP_USERDATA, IntPtr.Zero);
                }

                if (_gcHandle.IsAllocated && GCHandle.ToIntPtr(_gcHandle) == ptr)
                {
                    _gcHandle = default;
                }
                _hwnd = IntPtr.Zero;
                IsOpen = false;
                break;
        }

        return NativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
    }

    public void Close()
    {
        if (_hwnd != IntPtr.Zero && IsOpen)
        {
            Log.Info($"Programmatically closing window {_hwnd} ('{Title}').");
            NativeMethods.PostMessage(_hwnd, NativeMethods.WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
        }
    }

    public void Invalidate()
    {
        if (_hwnd != IntPtr.Zero && IsOpen)
        {
            NativeMethods.InvalidateRect(_hwnd, IntPtr.Zero, false);
        }
    }

    protected abstract bool Initialize();
    public abstract void RenderFrame();
    protected virtual void OnSize(int width, int height) { }
    protected virtual void OnMouseDown(MouseButton button, int x, int y) { }
    protected virtual void OnMouseUp(MouseButton button, int x, int y) { }
    protected virtual void OnMouseMove(int x, int y) { }
    protected virtual void OnKeyDown(int virtualKeyCode) { }
    protected virtual void OnKeyUp(int virtualKeyCode) { }
    protected virtual void OnMouseWheel(short delta) { }
    protected virtual bool IsKeyDownHandled(int virtualKeyCode) { return false; }
    protected virtual bool OnClose() { return true; }
    protected virtual void OnDestroy() { }
    protected abstract void Cleanup();

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_isDisposed)
        {
            if (disposing)
            {
                Log.Info($"Disposing Win32Window '{Title}' (managed)...");
                Cleanup();
            }

            Log.Info($"Disposing Win32Window '{Title}' (unmanaged)...");
            if (_hwnd != IntPtr.Zero)
            {
                Log.Info($"Requesting destroy for window {_hwnd} ('{Title}') during Dispose...");
                NativeMethods.DestroyWindow(_hwnd);
            }
            else
            {
                if (_gcHandle.IsAllocated)
                {
                    Log.Warning($"Freeing potentially dangling GCHandle for '{Title}' during Dispose (window handle was already zero)...");
                    try { _gcHandle.Free(); } catch (Exception ex) { Log.Error($"Error freeing GCHandle: {ex.Message}"); }
                }
            }

            _isDisposed = true;
            IsOpen = false;
            Log.Info($"Win32Window '{Title}' dispose initiated.");
        }
    }

    ~Win32Window()
    {
        Log.Warning($"Win32Window Finalizer called for '{Title}'! Ensure Dispose() was called.");
        Dispose(disposing: false);
    }
}

public enum MouseButton { Left, Right, Middle, XButton1, XButton2 }
</file>

<file path="Res\Cherris\Config.yaml">
Width: 1280
Height: 720
MinWidth: 1280
MinHeight: 720
MaxWidth: -1
MaxHeight: -1
Title: Cheris
ResizableWindow: true
AntiAliasing: true
MainScenePath: Res/Main.yaml
Backend: Raylib
BackdropType: MicaAlt
VSync: false
</file>

<file path="Source\Nodes\Camera.cs">
using Raylib_cs;

namespace Cherris;

public class Camera : Node2D
{
    public float Zoom { get; set; } = 1;

    public void SetAsActive()
    {
        RenderServer.Instance.SetCamera(this);
    }

    public static implicit operator Camera2D(Camera camera)
    {
        // Use the camera's actual owning window size for the offset
        Vector2 windowSize = camera.GetWindowSizeV2();

        return new()
        {
            Target = camera.GlobalPosition,
            Offset = windowSize / 2,
            Zoom = camera.Zoom,
        };
    }
}
</file>

<file path="Source\Nodes\Clickable.cs">
namespace Cherris;

public abstract class Clickable : Node2D
{
    public bool OnTopLeft = false;
    public bool OnTopRight = false;

    public Clickable()
    {
        ClickServer.Instance.Register(this);
    }

    public override void Free()
    {
        ClickServer.Instance.Unregister(this);
        base.Free();
    }

    public abstract bool IsMouseOver();
}
</file>

<file path="Source\Nodes\ClickableRectangle.cs">
namespace Cherris;

public abstract class ClickableRectangle : Clickable
{
    public override bool IsMouseOver()
    {
        var owningWindowNode = GetOwningWindowNode();
        Vector2 mousePosition;

        if (owningWindowNode != null)
        {
            // If part of a WindowNode, use its local mouse position
            mousePosition = owningWindowNode.LocalMousePosition;
        }
        else
        {
            // Otherwise, assume it's in the MainAppWindow
            var mainAppWindow = ApplicationServer.Instance.GetMainAppWindow();
            if (mainAppWindow != null)
            {
                mousePosition = mainAppWindow.GetLocalMousePosition();
            }
            else
            {
                // Fallback if main window isn't available (should not happen in normal operation)
                Log.Warning($"ClickableRectangle '{Name}': MainAppWindow not found for mouse position query. Using global Input.MousePosition as fallback.");
                mousePosition = Input.MousePosition;
            }
        }

        var globalPos = GlobalPosition;
        var origin = Origin;
        var size = ScaledSize;

        float left = globalPos.X - origin.X;
        float top = globalPos.Y - origin.Y;
        float right = left + size.X;
        float bottom = top + size.Y;

        bool isMouseOver =
            mousePosition.X >= left &&
            mousePosition.X < right &&
            mousePosition.Y >= top &&
            mousePosition.Y < bottom;

        return isMouseOver;
    }
}
</file>

<file path="Source\Nodes\Control.cs">
namespace Cherris;

public class Control : ClickableRectangle
{
    public bool Focusable { get; set; } = true;
    public bool Navigable { get; set; } = true;
    public bool RapidNavigation { get; set; } = true;
    public string? FocusNeighborTop { get; set; }
    public string? FocusNeighborBottom { get; set; }
    public string? FocusNeighborLeft { get; set; }
    public string? FocusNeighborRight { get; set; }
    public string? FocusNeighborNext { get; set; }
    public string? FocusNeighborPrevious { get; set; }
    public string AudioBus { get; set; } = "Master";
    public Sound? FocusGainedSound { get; set; }

    private bool wasFocusedLastFrame = false;
    private readonly Dictionary<string, float> actionHoldTimes = [];
    private const float InitialDelay = 0.5f;
    private const float RepeatInterval = 0.1f;

    public bool Disabled
    {
        get;
        set
        {
            if (value == field)
            {
                return;
            }

            field = value;
            WasDisabled?.Invoke(this);
        }
    } = false;

    public bool Focused
    {
        get;
        set
        {
            if (field == value)
            {
                return;
            }
            field = value;
            FocusChanged?.Invoke(this);

            if (field)
            {
                FocusGained?.Invoke(this);

                if (FocusGainedSound is not null)
                {
                    FocusGainedSound?.Play(AudioBus);
                }
            }
        }
    } = false;

    public string ThemeFile
    {
        set
        {
            OnThemeFileChanged(value);
        }
    }

    // Events

    public delegate void Event(Control control);
    public event Event? FocusChanged;
    public event Event? FocusGained;
    public event Event? WasDisabled;
    public event Event? ClickedOutside;

    // Main

    public override void Process()
    {
        base.Process();

        if (Navigable && Focused && wasFocusedLastFrame)
        {
            HandleArrowNavigation();
        }

        UpdateFocusOnOutsideClicked();
        wasFocusedLastFrame = Focused;
    }

    // Navigation

    private void HandleArrowNavigation()
    {
        var actions = new (string Action, string? Path)[]
        {
            ("UiLeft", FocusNeighborLeft),
            ("UiUp", FocusNeighborTop),
            ("UiRight", FocusNeighborRight),
            ("UiDown", FocusNeighborBottom),
            ("UiNext", FocusNeighborNext),
            ("UiPrevious", FocusNeighborPrevious)
        };

        foreach (var entry in actions)
        {
            if (string.IsNullOrEmpty(entry.Path)) continue;

            if (RapidNavigation)
            {
                if (Input.IsActionDown(entry.Action))
                {
                    if (!actionHoldTimes.ContainsKey(entry.Action))
                    {
                        actionHoldTimes[entry.Action] = 0f;
                    }

                    actionHoldTimes[entry.Action] += Time.Delta;
                    float holdTime = actionHoldTimes[entry.Action];

                    bool shouldNavigate = (holdTime <= Time.Delta + float.Epsilon) ||
                        (holdTime >= InitialDelay && (holdTime - InitialDelay) % RepeatInterval < Time.Delta);

                    if (shouldNavigate)
                    {
                        NavigateToControl(entry.Path, entry.Action, holdTime);
                    }
                }
                else
                {
                    actionHoldTimes[entry.Action] = 0f;
                }
            }
            else
            {
                if (Input.IsActionPressed(entry.Action))
                {
                    NavigateToControl(entry.Path, entry.Action, 0f);
                }
            }
        }
    }

    private void NavigateToControl(string controlPath, string action, float holdTime)
    {
        var neighbor = GetNodeOrNull<Control>(controlPath);

        if (neighbor is null)
        {
            Log.Error($"[Control] [{Name}] NavigateToControl: Could not find '{controlPath}'.");
            return;
        }

        if (neighbor.Disabled)
        {
            return;
        }

        if (RapidNavigation)
        {
            neighbor.actionHoldTimes[action] = holdTime;
        }

        neighbor.Focused = true;
        Focused = false;
    }

    // Focus

    private void UpdateFocusOnOutsideClicked()
    {
        if (!IsMouseOver() && Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            Focused = false;
            ClickedOutside?.Invoke(this);
        }
    }

    protected virtual void HandleClickFocus()
    {
        if (Focusable && IsMouseOver())
        {
            Focused = true;
        }
    }

    // Other

    protected virtual void OnThemeFileChanged(string themeFile) { }
}
</file>

<file path="Source\Nodes\VideoPlayer.cs">
using System.Drawing;
using System.Runtime.InteropServices;
using System.Text;
using LibVLCSharp.Shared;
using SharpGen.Runtime;
using Vortice.Direct2D1;
using Vortice.DXGI;
using Vortice.Mathematics;

namespace Cherris;

public class VideoPlayer : Node2D, IDisposable
{
    private static bool _isLibVlcInitialized = false;
    private static readonly object _initLock = new();
    private static readonly object _frameLock = new();

    private LibVLC? _libVLC;
    private MediaPlayer? _mediaPlayer;
    private Media? _media;
    private bool _isDisposed = false;

    private ID2D1Bitmap? _videoBitmap;
    private byte[]? _latestFrameDataRaw;
    private uint _videoWidth = 0;
    private uint _videoHeight = 0;
    private bool _newFrameAvailable = false;
    private bool _formatConfigured = false;

    private uint _receivedChroma = 0;
    private uint _receivedPitch = 0;
    private uint _bufferSize = 0;

    private byte[]? _conversionBufferBGRA32;

    private static readonly uint FourCC_RV32 = CalculateFourCC("RV32");
    private static readonly uint FourCC_RV24 = CalculateFourCC("RV24");

    private MediaPlayer.LibVLCVideoFormatCb? _videoFormatCallbackDelegate;
    private MediaPlayer.LibVLCVideoLockCb? _videoLockCallbackDelegate;
    private MediaPlayer.LibVLCVideoUnlockCb? _videoUnlockCallbackDelegate;
    private MediaPlayer.LibVLCVideoDisplayCb? _videoDisplayCallbackDelegate;
    private MediaPlayer.LibVLCVideoCleanupCb? _videoCleanupCallbackDelegate;
    
    public bool AutoPlay { get; set; } = false;
    public bool IsPlaying => _mediaPlayer?.IsPlaying ?? false;
    public long DurationMilliseconds => _mediaPlayer?.Length ?? 0;
    public bool SuppressPositionRatioChangedEvent { get; set; } = false;

    public override Vector2 Size
    {
        get
        {
            lock (_frameLock)
            {
                // Return actual video size if available, otherwise fallback to base
                return _videoWidth > 0 && _videoHeight > 0
                    ? new(_videoWidth, _videoHeight)
                    : base.Size; // You might want to set a default size here if needed
            }
        }
        set
        {
            base.Size = value;
        }
    }

    private bool _loop = false;
    public bool Loop
    {
        get => _loop;
        set
        {
            if (_loop == value) return;
            _loop = value;
        }
    }

    private float _volume = 100f;
    public float Volume
    {
        get => _volume;
        set
        {
            _volume = Math.Clamp(value, 0f, 100f);

            if (_mediaPlayer != null)
            {
                _mediaPlayer.Volume = (int)_volume;
            }
        }
    }

    public float PositionRatio
    {
        get => _mediaPlayer?.Position ?? 0f;

        set
        {
            if (_mediaPlayer is null)
            {
                return;
            }

            _mediaPlayer.Position = float.Clamp(value, 0f, 1f);
        }
    }

    private string _filePath = "";
    public string FilePath
    {
        get => _filePath;

        set
        {
            if (_filePath == value)
            {
                return;
            }

            _filePath = value;

            if (_mediaPlayer is not null && _libVLC is not null)
            {
                LoadMedia();
            }

            // Invalidate any existing bitmap if path changes
            lock (_frameLock)
            {
                _videoBitmap?.Dispose();
                _videoBitmap = null;
                _videoWidth = 0;
                _videoHeight = 0;
                _receivedChroma = 0; // Reset format info
                _receivedPitch = 0;
                _bufferSize = 0;
                _latestFrameDataRaw = null;
                _conversionBufferBGRA32 = null;
                _newFrameAvailable = false;
                _formatConfigured = false;
            }
        }
    }

    public float PlaybackSpeed
    {
        get;
        set
        {
            // You might want to clamp the value to a reasonable range, e.g., 0.25f to 4.0f
            // float newSpeed = Math.Max(0.1f, Math.Min(value, 16.0f)); // Example clamping
            float newSpeed = float.Clamp(value, 0.25f, 4f); // Using raw value for now
            
            if (float.Abs(field - newSpeed) <= float.Epsilon) // Check for actual change
            {
                return;
            }

            field = newSpeed;
            _mediaPlayer?.SetRate(PlaybackSpeed);
        }
    } = 1.0f;

    // - - - - - - - - - - - - - - -  Events - - - - - - - - - - - - - - - 

    public event EventHandler? PlaybackStarted;
    public event EventHandler? PlaybackPaused;
    public event EventHandler? PlaybackStopped;
    public event EventHandler? PlaybackEnded;
    public event EventHandler<string>? PlaybackError;
    public event Action<float>? PositionRatioChanged;

    // - - - - - - - - - - - - - - - Main - - - - - - - - - - - - - - - 

    public override void Make()
    {
        base.Make();
        InitializeLibVLC();
    }

    public override void Ready()
    {
        base.Ready();

        if (!AutoPlay || _mediaPlayer == null || _media == null || _mediaPlayer.IsPlaying)
        {
            return;
        }

        Play();
    }

    public override void Free()
    {
        Dispose();
        base.Free();
    }

    public override void Draw(DrawingContext context)
    {
        if (!Visible || context.RenderTarget == null || _isDisposed) return;

        bool bitmapNeedsRecreation = false;
        bool frameNeedsProcessing = false; // Flag if new frame needs conversion/copy
        uint currentWidth = 0;
        uint currentHeight = 0;
        uint currentChroma = 0;
        uint currentPitch = 0;
        bool isNewFrameAvailableInLock = false;

        // --- Step 1: Check state under lock ---
        lock (_frameLock)
        {
            currentWidth = _videoWidth;
            currentHeight = _videoHeight;
            currentChroma = _receivedChroma; // Get the format code
            currentPitch = _receivedPitch;   // Get the pitch for the raw data
            isNewFrameAvailableInLock = _newFrameAvailable;

            // Check if D2D BGRA bitmap needs recreation (size changed OR format wasn't configured before)
            // Only attempt recreation if the format IS configured now.
            if ((_videoBitmap == null || _videoBitmap.PixelSize.Width != currentWidth || _videoBitmap.PixelSize.Height != currentHeight)
                && currentWidth > 0 && currentHeight > 0)
            {
                bitmapNeedsRecreation = true;
            }

            // Check if a new frame needs processing (conversion/copy)
            // Can only process if format is configured AND bitmap exists AND raw data exists
            if (isNewFrameAvailableInLock && _formatConfigured && _videoBitmap != null && _latestFrameDataRaw != null && currentChroma != 0)
            {
                // Only process if bitmap dimensions match current video dimensions
                if (_videoBitmap.PixelSize.Width == currentWidth && _videoBitmap.PixelSize.Height == currentHeight)
                {
                    frameNeedsProcessing = true;
                }
                else // Mismatch, force recreation instead
                {
                    Log.Warning($"Draw: Bitmap dimensions ({_videoBitmap?.PixelSize.Width}x{_videoBitmap?.PixelSize.Height}) mismatch current video dimensions ({currentWidth}x{currentHeight}). Forcing recreation.");

                    if (currentWidth > 0 && currentHeight > 0)
                    {
                        bitmapNeedsRecreation = true; // Force recreation
                    }

                    frameNeedsProcessing = false; // Don't process this frame if dims mismatch
                }
            }
        } // --- End Lock for Step 1 ---

        // --- Step 2: Recreate D2D Bitmap if needed (outside lock) ---
        if (bitmapNeedsRecreation)
        {
            ID2D1Bitmap? oldBitmap = null;
            lock (_frameLock) { oldBitmap = _videoBitmap; _videoBitmap = null; }
            oldBitmap?.Dispose();

            // Double-check dimensions and configured status before creating
            lock (_frameLock)
            {
                if (!_formatConfigured || _videoWidth == 0 || _videoHeight == 0)
                {
                    Log.Warning($"Draw: Cannot recreate bitmap. Format Configured: {_formatConfigured}, Dimensions: {_videoWidth}x{_videoHeight}."); return;
                }
            }

            try
            {
                // D2D Bitmap is always BGRA32
                var bitmapProperties = new BitmapProperties(new Vortice.DCommon.PixelFormat(Format.B8G8R8A8_UNorm, Vortice.DCommon.AlphaMode.Ignore));
                var newBitmap = context.RenderTarget.CreateBitmap(new SizeI((int)currentWidth, (int)currentHeight), bitmapProperties);

                lock (_frameLock) { _videoBitmap = newBitmap; }
                Log.Info($"Draw: BGRA32 Bitmap recreated successfully ({currentWidth}x{currentHeight}).");

                // Check if the pending frame can be processed *now* after recreation
                lock (_frameLock)
                {
                    // Re-check all conditions
                    if (_formatConfigured && isNewFrameAvailableInLock && _latestFrameDataRaw != null && currentChroma != 0 &&
                       _videoBitmap != null && _videoBitmap.PixelSize.Width == currentWidth && _videoBitmap.PixelSize.Height == currentHeight)
                    {
                        frameNeedsProcessing = true; // Process frame now
                    }
                    else { frameNeedsProcessing = false; /*Log.Info("Draw: Frame processing not ready after bitmap recreation.");*/ }
                }
            }
            catch (SharpGenException sgex) when (sgex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
            { Log.Warning($"Draw: Render target needs recreation during Bitmap creation."); lock (_frameLock) { _videoBitmap = null; } return; }
            catch (Exception ex) { Log.Error($"Failed to create ID2D1Bitmap: {ex.Message}"); lock (_frameLock) { _videoBitmap = null; } return; }
        }

        // --- Step 3: Process Frame (Convert/Copy) if needed ---
        if (frameNeedsProcessing)
        {
            byte[]? rawData = null;
            byte[]? bgraData = null; // Target for conversion/copy
            ID2D1Bitmap? bitmapForCopy = null;
            uint widthForUpdate = 0;
            uint heightForUpdate = 0;
            uint chromaForUpdate = 0;
            uint pitchForUpdate = 0; // Pitch of the raw data

            // Get data and refs under lock
            lock (_frameLock)
            {
                // Re-check all conditions *inside* the lock
                // Crucially, check _formatConfigured!
                if (_formatConfigured && _videoBitmap != null && _latestFrameDataRaw != null && _newFrameAvailable && _receivedChroma != 0 &&
                    _videoBitmap.PixelSize.Width == currentWidth && _videoBitmap.PixelSize.Height == currentHeight)
                {
                    widthForUpdate = currentWidth;
                    heightForUpdate = currentHeight;
                    // *** IMPORTANT: Use the CHROMA from the raw data buffer, NOT the one we forced (_receivedChroma) ***
                    // This assumes the Lock/Unlock callback gives us the *actual* format being delivered.
                    // If Lock/Unlock doesn't give format info, we might need another way or assume it matches our request.
                    // For now, let's assume we need to handle the format delivered in rawData, whose chroma might be implicitly RV32 or RV24 etc.
                    // We will use the _receivedChroma as the *assumed* format of the locked buffer for now.
                    chromaForUpdate = _receivedChroma; // <-- Revisit this if Lock/Unlock gives explicit format info
                    pitchForUpdate = _receivedPitch;   // Use the pitch associated with the buffer we locked (should match our forced pitch)
                    rawData = _latestFrameDataRaw;
                    bitmapForCopy = _videoBitmap;

                    // Ensure BGRA conversion buffer exists if needed (or for direct copy target)
                    uint bgraSize = widthForUpdate * heightForUpdate * 4;
                    if (_conversionBufferBGRA32 == null || _conversionBufferBGRA32.Length != bgraSize)
                    {
                        try { _conversionBufferBGRA32 = new byte[bgraSize]; }
                        catch (Exception ex) { Log.Error($"Failed to allocate BGRA buffer: {ex.Message}"); _conversionBufferBGRA32 = null; }
                    }
                    bgraData = _conversionBufferBGRA32;
                }
                else { /* Conditions no longer met */ rawData = null; bgraData = null; bitmapForCopy = null; }
            } // --- End Lock ---

            bool processedSuccessfully = false;
            if (rawData != null && bgraData != null && bitmapForCopy != null && widthForUpdate > 0 && heightForUpdate > 0)
            {
                try
                {
                    // *** FORMAT HANDLING ***
                    // Here we process based on 'chromaForUpdate', which currently is assumed to be the RV32 we requested.
                    if (chromaForUpdate == FourCC_RV32) // BGRA32
                    {
                        uint expectedBgraPitch = widthForUpdate * 4;
                        if (pitchForUpdate == expectedBgraPitch)
                        {
                            // Pitches match, direct copy
                            bitmapForCopy.CopyFromMemory(new Rectangle(0, 0, (int)widthForUpdate, (int)heightForUpdate), rawData, pitchForUpdate);
                            processedSuccessfully = true;
                        }
                        else
                        {
                            // This case *shouldn't* happen if we forced RV32 with the correct pitch, but handle defensively.
                            Log.Warning($"RV32 pitch mismatch (Expected {expectedBgraPitch}, Got {pitchForUpdate}). Using intermediate buffer copy.");
                            CopyMemoryWithPitch(rawData, pitchForUpdate, bgraData, expectedBgraPitch, widthForUpdate * 4, heightForUpdate);
                            bitmapForCopy.CopyFromMemory(new Rectangle(0, 0, (int)widthForUpdate, (int)heightForUpdate), bgraData, expectedBgraPitch);
                            processedSuccessfully = true;
                        }
                    }
                    // LibVLC might ignore our RV32 request and send something else like RV24.
                    // We need to be prepared for this possibility if the above doesn't work.
                    // For now, we assume RV32 is delivered if the setup succeeded.
                    // else if (chromaForUpdate == FourCC_RV24) // BGR24 - Keep this conversion just in case
                    // {
                    //     ConvertBGR24ToBGRA32(rawData, bgraData, widthForUpdate, heightForUpdate, pitchForUpdate);
                    //     uint bgraPitch = widthForUpdate * 4;
                    //     bitmapForCopy.CopyFromMemory(new Rectangle(0, 0, (int)widthForUpdate, (int)heightForUpdate), bgraData, bgraPitch);
                    //     processedSuccessfully = true;
                    // }
                    else
                    {
                        // This implies the format delivered doesn't match RV32, which we requested.
                        Log.Error($"Draw: Skipping frame processing. Unexpected video format received in buffer (Expected RV32): {FourCCToString(chromaForUpdate)} (0x{chromaForUpdate:X8})");
                    }

                    if (processedSuccessfully)
                    {
                        lock (_frameLock) { _newFrameAvailable = false; }
                    }

                }
                catch (SharpGenException sgex) when (sgex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
                { Log.Warning($"Draw: Render target needs recreation during CopyFromMemory."); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; _newFrameAvailable = false; } return; }
                catch (Exception ex) { Log.Error($"Failed during frame processing/copy: {ex.Message}"); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; _newFrameAvailable = false; } }
            }
            else if (frameNeedsProcessing) { Log.Warning($"Draw: Skipped frame processing. HasBitmap={bitmapForCopy != null}, HasRawData={rawData != null}, HasBGRAData={bgraData != null}, Chroma={chromaForUpdate}, W={widthForUpdate}, H={heightForUpdate}"); }
        }


        // --- Step 4: Draw D2D Bitmap ---
        ID2D1Bitmap? bitmapToDraw = null;
        lock (_frameLock) { bitmapToDraw = _videoBitmap; } // Get current bitmap ref


        if (bitmapToDraw != null && currentWidth > 0 && currentHeight > 0) // Use originally captured dimensions
        {
            try
            {
                var position = GlobalPosition - Origin;
                var size = ScaledSize;
                var destRect = new RectangleF(position.X, position.Y, size.X, size.Y);
                var sourceRect = new RectangleF(0, 0, bitmapToDraw.PixelSize.Width, bitmapToDraw.PixelSize.Height); // Use bitmap's actual size

                context.RenderTarget.DrawBitmap(bitmapToDraw, destRect, 1.0f, BitmapInterpolationMode.Linear, sourceRect);
            }
            catch (SharpGenException sgex) when (sgex.ResultCode.Code == Vortice.Direct2D1.ResultCode.RecreateTarget.Code)
            { Log.Warning($"Draw: Render target needs recreation during DrawBitmap."); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; } return; }
            catch (ObjectDisposedException) { Log.Warning($"Draw: Bitmap was disposed before DrawBitmap."); lock (_frameLock) { _videoBitmap = null; } }
            catch (Exception ex) { Log.Error($"Failed to draw video bitmap: {ex.Message}"); lock (_frameLock) { _videoBitmap?.Dispose(); _videoBitmap = null; } }
        }
        else if (Visible) { DrawPlaceholder(context, GlobalPosition - Origin, base.Size); } // Draw placeholder if visible but no bitmap
    }

    private void InitializeLibVLC()
    {
        lock (_initLock)
        {
            if (!_isLibVlcInitialized)
            {
                try
                {
                    Core.Initialize();
                    _isLibVlcInitialized = true;
                    Log.Info("LibVLC Core initialized.");
                }
                catch (Exception ex)
                {
                    Log.Error($"Failed to initialize LibVLC Core: {ex.Message}");
                    PlaybackError?.Invoke(this, $"Failed to initialize LibVLC Core: {ex.Message}");
                    return;
                }
            }
        }

        try
        {
            List<string> libvlcOptions =
            [
                "--no-osd",
                "--avcodec-hw=none"
                // "--verbose=2" // Uncomment for more detailed VLC logs if needed
            ];

            _libVLC = new(libvlcOptions.ToArray());

            Log.Info($"LibVLC instance created with options: {string.Join(" ", libvlcOptions)}");

            _mediaPlayer = new MediaPlayer(_libVLC);

            _videoFormatCallbackDelegate = new(VideoFormatCallback);
            _videoCleanupCallbackDelegate = new(VideoCleanupCallback);
            _videoLockCallbackDelegate = new(VideoLockCallback);
            _videoUnlockCallbackDelegate = new(VideoUnlockCallback);
            _videoDisplayCallbackDelegate = new(VideoDisplayCallback);

            _mediaPlayer.SetVideoFormatCallbacks(_videoFormatCallbackDelegate, _videoCleanupCallbackDelegate);
            _mediaPlayer.SetVideoCallbacks(_videoLockCallbackDelegate, _videoUnlockCallbackDelegate, _videoDisplayCallbackDelegate);

            _mediaPlayer.Playing += OnPlaying;
            _mediaPlayer.Paused += OnPaused;
            _mediaPlayer.Stopped += OnStopped;
            _mediaPlayer.EndReached += OnEndReached;
            _mediaPlayer.EncounteredError += OnEncounteredError;
            _mediaPlayer.PositionChanged += OnPositionChanged;

            _mediaPlayer.Volume = (int)Volume;
            // Set initial playback speed if mediaplayer is already created
            // This is mostly redundant if LoadMedia also sets it, but good for safety.
            _mediaPlayer.SetRate(PlaybackSpeed);


            if (!string.IsNullOrEmpty(FilePath))
            {
                LoadMedia();
            }
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to create LibVLC instance or MediaPlayer: {ex.Message}");
            PlaybackError?.Invoke(this, $"Failed to create LibVLC/MediaPlayer: {ex.Message}");
            DisposeVlcResources();
        }
    }

    private static uint CalculateFourCC(string code)
    {
        if (code is null || code.Length != 4)
        {
            throw new ArgumentException("FourCC code must be 4 characters long.", nameof(code));
        }

        byte[] bytes = Encoding.ASCII.GetBytes(code);

        if (BitConverter.IsLittleEndian)
        {
            return BitConverter.ToUInt32(bytes, 0);
        }

        Array.Reverse(bytes);

        return BitConverter.ToUInt32(bytes, 0);
    }

    private static string FourCCToString(uint fourCC)
    {
        byte[] bytes = BitConverter.GetBytes(fourCC);

        if (!BitConverter.IsLittleEndian)
        {
            Array.Reverse(bytes);
        }

        bool isAsciiPrintable = bytes.All(b => b >= 32 && b <= 126);

        return isAsciiPrintable
            ? Encoding.ASCII.GetString(bytes)
            : $"0x{fourCC:X8}";
    }

    private uint VideoFormatCallback(ref nint opaque, nint chroma, ref uint width, ref uint height, ref uint pitches, ref uint lines)
    {
        // This callback might be called multiple times.
        // We need valid width, height, *and* pitches/lines to fully configure.
        uint currentChromaInt = 0;
        try
        {
            if (IntPtr.Size == 4) currentChromaInt = (uint)chroma.ToInt32();
            else currentChromaInt = (uint)chroma.ToInt64();
        }
        catch (OverflowException ex)
        {
            Log.Error($"VideoFormatCallback: Chroma IntPtr value overflows uint32. {ex.Message}");
            return 0; // Cannot process
        }

        string currentChromaStr = FourCCToString(currentChromaInt);

        Log.Info($"VideoFormatCallback: Received Format='{currentChromaStr}' (0x{currentChromaInt:X8}), Dimensions={width}x{height}, Pitch={pitches}, Lines={lines}");

        // *** Reject if dimensions are fundamentally invalid ***
        if (width == 0 || height == 0)
        {
            Log.Error($"VideoFormatCallback: Rejecting format due to invalid dimensions (W:{width}, H:{height}).");
            // Reset state if we previously had valid info
            lock (_frameLock)
            {
                ResetFormatState_Locked();
            }
            return 0; // Indicate failure
        }

        // *** Force BGRA32 (RV32) format for Direct2D compatibility ***
        uint targetChroma = FourCC_RV32;
        uint targetPitch = width * 4; // BGRA = 4 bytes per pixel
        uint targetLines = height;
        string targetChromaStr = FourCCToString(targetChroma);

        lock (_frameLock)
        {
            // Check if anything crucial changed OR if we haven't configured yet
            bool dimensionsChanged = (_videoWidth != width || _videoHeight != height);
            // We are forcing RV32, so we don't check _receivedChroma vs targetChroma for change here

            if (dimensionsChanged || !_formatConfigured)
            {
                Log.Info($"VideoFormatCallback: Configuring/Updating format - Size: {width}x{height}. Forcing Chroma: {targetChromaStr}, Pitch: {targetPitch}, Lines: {targetLines}. Previously Configured: {_formatConfigured}");

                // Clear potentially outdated resources if dimensions changed
                if (dimensionsChanged)
                {
                    _videoBitmap?.Dispose(); _videoBitmap = null;
                    _latestFrameDataRaw = null; _conversionBufferBGRA32 = null;
                    _newFrameAvailable = false;
                }

                // Store the *target* format details
                _receivedChroma = targetChroma; // Store what we requested
                _videoWidth = width;
                _videoHeight = height;
                _receivedPitch = targetPitch; // Store calculated pitch for BGRA32
                _bufferSize = targetPitch * targetLines; // Calculate buffer size for BGRA32

                _formatConfigured = true; // Mark as successfully configured
                Log.Info($"Calculated buffer size for forced BGRA32: {_bufferSize} bytes");
            }
            // Update the parameters passed by reference to tell LibVLC we want RV32
            Marshal.WriteInt32(chroma, (int)targetChroma); // Write the FourCC code
            pitches = targetPitch;
            lines = targetLines;
        }

        return targetLines; // Return the height (number of lines) to indicate success
    }

    private void VideoCleanupCallback(ref nint opaque)
    {
        Log.Info("VideoCleanupCallback called.");
    }

    private nint VideoLockCallback(nint opaque, nint planes)
    {
        lock (_frameLock)
        {
            // Check if format is FULLY configured (valid pitch/lines received)
            if (!_formatConfigured || _bufferSize == 0 || _receivedPitch == 0)
            {
                Log.Warning($"VideoLockCallback: Cannot lock, format not fully configured yet (Configured={_formatConfigured}, Size={_bufferSize}, Pitch={_receivedPitch}).");
                return nint.Zero;
            }

            // Allocate/Reallocate raw frame buffer if needed
            if (_latestFrameDataRaw == null || _latestFrameDataRaw.Length != _bufferSize)
            {
                try
                {
                    _latestFrameDataRaw = new byte[_bufferSize];
                    Log.Info($"Allocated raw frame buffer: {_bufferSize} bytes for format {FourCCToString(_receivedChroma)}");
                }
                catch (Exception ex)
                {
                    Log.Error($"VideoLockCallback: Exception allocating raw buffer of size {_bufferSize}. {ex.Message}");
                    _latestFrameDataRaw = null;
                    ResetFormatState_Locked(); // Mark format as unconfigured
                    return nint.Zero;
                }
            }

            // We should have a buffer here.
            if (_latestFrameDataRaw == null)
            {
                Log.Error("VideoLockCallback: Raw Frame buffer is null after allocation check.");
                return nint.Zero;
            }

            // Pin the buffer and provide pointer to VLC
            var handle = GCHandle.Alloc(_latestFrameDataRaw, GCHandleType.Pinned);
            var bufferPtr = handle.AddrOfPinnedObject();

            if (planes == IntPtr.Zero)
            {
                Log.Error("VideoLockCallback: Received null planes pointer.");
                handle.Free();
                return nint.Zero;
            }
            // For packed formats (like RV32, RV24), VLC expects a single plane pointer.
            // For planar formats (like I420), it expects pointers for Y, U, V planes.
            // We assume planes[0] is the target for packed formats.
            // TODO: Handle planar formats correctly if needed (write multiple pointers).
            Marshal.WriteIntPtr(planes, 0, bufferPtr); // Write pointer to planes[0]

            return GCHandle.ToIntPtr(handle); // Return handle to be freed in Unlock
        }
    }

    private void VideoUnlockCallback(nint opaque, nint picture, nint planes)
    {
        lock (_frameLock)
        {
            if (picture == IntPtr.Zero)
            {
                Log.Warning("VideoUnlockCallback: Received null picture handle.");
                return;
            }

            _newFrameAvailable = true; // Signal that a raw frame is ready

            try
            {
                var handle = GCHandle.FromIntPtr(picture);
                if (handle.IsAllocated) handle.Free();
                else Log.Warning("VideoUnlockCallback: GCHandle was not allocated?");
            }
            catch (Exception ex)
            {
                Log.Error($"VideoUnlockCallback: Exception freeing GCHandle {picture}. {ex.Message}");
            }
        }
    }

    private void VideoDisplayCallback(nint opaque, nint picture)
    {
        // Not strictly needed for our rendering logic which polls _newFrameAvailable.
    }

    private void LoadMedia()
    {
        if (_libVLC == null || _mediaPlayer == null || string.IsNullOrEmpty(FilePath))
        {
            Log.Warning($"Cannot load media: LibVLC/MediaPlayer not ready or FilePath is empty for node '{Name}'.");
            return;
        }

        if (_mediaPlayer.IsPlaying) _mediaPlayer.Stop();

        lock (_frameLock)
        {
            _media?.Dispose(); _media = null;
            _videoBitmap?.Dispose(); _videoBitmap = null;
            _latestFrameDataRaw = null;
            _conversionBufferBGRA32 = null;
            _videoWidth = 0; _videoHeight = 0;
            _receivedChroma = 0; _receivedPitch = 0; _bufferSize = 0;
            _newFrameAvailable = false;
            Log.Info($"Cleared previous media state for node '{Name}'.");
            _formatConfigured = false;
        }


        string absolutePath;
        try { absolutePath = Path.GetFullPath(FilePath); }
        catch (Exception ex) { Log.Error($"Error getting full path '{FilePath}': {ex.Message}"); PlaybackError?.Invoke(this, $"Invalid path: {ex.Message}"); return; }

        if (!File.Exists(absolutePath)) { Log.Error($"Video file not found: {absolutePath}"); PlaybackError?.Invoke(this, $"Video file not found: {absolutePath}"); return; }

        // No specific options needed here now regarding chroma
        List<string> mediaOptions = new List<string> { ":no-video-title-show" };

        try
        {
            _media = new Media(_libVLC, new Uri(absolutePath), mediaOptions.ToArray());
            _mediaPlayer.Media = _media;
            Log.Info($"Loaded media: {absolutePath} for node '{Name}'.");

            // Apply the current playback speed to the new media
            if (_mediaPlayer != null)
            {
                _mediaPlayer.SetRate(PlaybackSpeed);
            }
        }
        catch (Exception ex)
        {
            Log.Error($"Error loading media '{absolutePath}': {ex.Message}");
            PlaybackError?.Invoke(this, $"Error loading media: {ex.Message}");
            _media?.Dispose(); _media = null;
        }
        // Reset format flag on new media load
        lock (_frameLock) { _formatConfigured = false; }
    }

    // - - - - - - - - - - - - - - - Usage - - - - - - - - - - - - - - - 

    public void Play()
    {
        if (_mediaPlayer != null && _media != null)
        {
            if (_mediaPlayer.State == VLCState.Error) { Log.Warning($"Cannot play node '{Name}', player state is Error."); PlaybackError?.Invoke(this, $"Player state is Error"); return; }

            // Ensure playback speed is set before playing, in case it was changed while stopped/paused.
            _mediaPlayer.SetRate(PlaybackSpeed);

            if (!_mediaPlayer.IsPlaying)
            {
                Log.Info($"Playing media: {FilePath} for node '{Name}' at speed: {PlaybackSpeed}x.");
                if (!_mediaPlayer.Play())
                {
                    Log.Error($"MediaPlayer.Play() returned false for node '{Name}'. State: {_mediaPlayer.State}");
                    PlaybackError?.Invoke(this, "Play() failed.");
                }
            }
        }
        else { Log.Warning($"Cannot play: MediaPlayer or Media not ready for node '{Name}'."); }
    }

    public void Pause()
    {
        if (_mediaPlayer?.CanPause ?? false) { _mediaPlayer.Pause(); }
        else { Log.Warning($"Cannot pause node '{Name}'."); }
    }

    public void Stop()
    {
        if (_mediaPlayer != null) { _mediaPlayer.Stop(); }
        else { Log.Warning($"Cannot stop node '{Name}'."); }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    // - - - - - - - - - - - - - - - Static - - - - - - - - - - - - - - - 

    private static void ConvertBGR24ToBGRA32(byte[] bgr24Data, byte[] bgra32Data, uint width, uint height, uint bgrPitch)
    {
        uint bgraPitch = width * 4;
        int numPixelsWidth = (int)width;

        ulong requiredBgraSize = (ulong)height * bgraPitch;
        ulong requiredBgrSize = (ulong)height * bgrPitch;

        if ((ulong)bgra32Data.LongLength < requiredBgraSize || (ulong)bgr24Data.LongLength < requiredBgrSize)
        {
            Log.Error($"Buffer size mismatch in ConvertBGR24ToBGRA32 (Pitched). BGR:{bgr24Data.Length}, BGRA:{bgra32Data.Length}, Expected BGR:{requiredBgrSize}, Expected BGRA:{requiredBgraSize}");
            return;
        }

        for (int y = 0; y < height; y++)
        {
            int bgrRowStart = (int)(y * bgrPitch);
            int bgraRowStart = (int)(y * bgraPitch);

            for (int x = 0; x < numPixelsWidth; x++)
            {
                int bgrIndex = bgrRowStart + x * 3;
                int bgraIndex = bgraRowStart + x * 4;

                if (bgrIndex + 2 >= bgr24Data.Length || bgraIndex + 3 >= bgra32Data.Length)
                {
                    Log.Error($"Index out of bounds during BGR->BGRA conversion at x={x}, y={y}.");
                    return;
                }

                byte b = bgr24Data[bgrIndex + 0];
                byte g = bgr24Data[bgrIndex + 1];
                byte r = bgr24Data[bgrIndex + 2];

                bgra32Data[bgraIndex + 0] = b;
                bgra32Data[bgraIndex + 1] = g;
                bgra32Data[bgraIndex + 2] = r;
                bgra32Data[bgraIndex + 3] = 255;
            }
        }
    }

    private static unsafe void CopyMemoryWithPitch(byte[] source, uint sourcePitch, byte[] destination, uint destPitch, uint bytesPerRow, uint rowCount)
    {
        if (source is null || destination is null || bytesPerRow == 0 || rowCount == 0)
        {
            return;
        }

        var requiredSourceSize = (ulong)(rowCount - 1) * sourcePitch + bytesPerRow;
        var requiredDestSize = (ulong)(rowCount - 1) * destPitch + bytesPerRow;

        if (bytesPerRow > sourcePitch || bytesPerRow > destPitch)
        {
            Log.Error("CopyMemoryWithPitch: bytesPerRow exceeds pitch.");
            return;
        }

        if (requiredSourceSize > (ulong)source.LongLength || requiredDestSize > (ulong)destination.LongLength)
        {
            Log.Error($"CopyMemoryWithPitch: Calculated size exceeds buffer length. Source Required: " +
                $"{requiredSourceSize}" +
                $"vs Actual: {source.LongLength}." +
                $"Dest Required: {requiredDestSize}" +
                $"vs Actual: {destination.LongLength}");

            return;
        }

        fixed (byte* pSource = source, pDest = destination)
        {
            byte* pSrcRow = pSource;
            byte* pDstRow = pDest;

            for (uint i = 0; i < rowCount; i++)
            {
                Buffer.MemoryCopy(pSrcRow, pDstRow, bytesPerRow, bytesPerRow);

                pSrcRow += sourcePitch;
                pDstRow += destPitch;
            }
        }
    }

    private static void DrawPlaceholder(DrawingContext context, Vector2 position, Vector2 size)
    {
        Rect placeholderRect = new(position.X, position.Y, size.X, size.Y);
        ID2D1SolidColorBrush? brush = context.OwnerWindow?.GetOrCreateBrush(Colors.DarkGray);

        if (brush == null || context.RenderTarget == null)
        {
            return;
        }

        context.RenderTarget.FillRectangle(placeholderRect, brush);
    }

    // - - - - - - - - - - - - - - - Event handlers - - - - - - - - - - - - - - - 

    private void OnPlaying(object? sender, EventArgs e)
    {
        PlaybackStarted?.Invoke(this, EventArgs.Empty);
    }

    private void OnPaused(object? sender, EventArgs e)
    {
        PlaybackPaused?.Invoke(this, EventArgs.Empty);
    }

    private void OnStopped(object? sender, EventArgs e)
    {
        PlaybackStopped?.Invoke(this, EventArgs.Empty);

        lock (_frameLock)
        {
            _newFrameAvailable = false;
        }
    }

    private void OnEndReached(object? sender, EventArgs e)
    {
        PlaybackEnded?.Invoke(this, EventArgs.Empty); lock (_frameLock) { _newFrameAvailable = false; }
        if (Loop && _mediaPlayer != null && _media != null && !_isDisposed) { _mediaPlayer.Stop(); _mediaPlayer.Play(); }
    }

    private void OnEncounteredError(object? sender, EventArgs e)
    {
        Log.Error($"LibVLCSharp error for node '{Name}'. State: {_mediaPlayer?.State}");
        PlaybackError?.Invoke(this, "LibVLCSharp error. Check logs.");

        lock (_frameLock)
        {
            _newFrameAvailable = false;
        }
    }

    // Handler for MediaPlayer.PositionChanged
    private void OnPositionChanged(object? sender, MediaPlayerPositionChangedEventArgs e)
    {
        if (SuppressPositionRatioChangedEvent) // Check the flag
        {
            return;
        }

        PositionRatioChanged?.Invoke(e.Position);
    }

    private void ResetFormatState_Locked()
    {
        _videoBitmap?.Dispose(); _videoBitmap = null;
        _latestFrameDataRaw = null; _conversionBufferBGRA32 = null;
        _newFrameAvailable = false; _videoWidth = 0; _videoHeight = 0;
        _receivedChroma = 0; _receivedPitch = 0; _bufferSize = 0;
        _formatConfigured = false; // Mark as unconfigured
    }

    // - - - - - - - - - - - - - - - Diospose - - - - - - - - - - - - - - - 

    protected virtual void Dispose(bool disposing)
    {
        if (_isDisposed)
        {
            return;
        }

        _isDisposed = true;

        Log.Info($"Disposing VideoPlayer '{Name}' (disposing={disposing})...");

        try
        {
            if (_mediaPlayer != null && _mediaPlayer.IsPlaying)
            {
                _mediaPlayer.Stop();
            }
        }
        catch (Exception ex)
        {
            Log.Warning($"Exception stopping MediaPlayer during dispose: {ex.Message}");
        }

        if (disposing)
        {
            if (_mediaPlayer != null)
            {
                _mediaPlayer.Playing -= OnPlaying;
                _mediaPlayer.Paused -= OnPaused;
                _mediaPlayer.Stopped -= OnStopped;
                _mediaPlayer.EndReached -= OnEndReached;
                _mediaPlayer.EncounteredError -= OnEncounteredError;
                _mediaPlayer.PositionChanged -= OnPositionChanged;

                try
                {
                    _mediaPlayer.SetVideoFormatCallbacks(null, null);
                    _mediaPlayer.SetVideoCallbacks(null, null, null);
                }
                catch (Exception ex)
                {
                    Log.Warning($"Exception detaching callbacks: {ex.Message}");
                }
            }

            try
            {
                _media?.Dispose();
            }
            catch (Exception ex)
            {
                Log.Warning($"Exception disposing Media: {ex.Message}");
            }
            finally
            {
                _media = null;
            }

            try
            {
                _mediaPlayer?.Dispose();
            }
            catch (Exception ex)
            {
                Log.Warning($"Exception disposing MediaPlayer: {ex.Message}");
            }
            finally
            {
                _mediaPlayer = null;
            }

            try
            {
                _libVLC?.Dispose();
            }
            catch (Exception ex)
            {
                Log.Warning($"Exception disposing LibVLC: {ex.Message}");
            }
            finally
            {
                _libVLC = null;
            }

            _videoFormatCallbackDelegate = null;
            _videoCleanupCallbackDelegate = null;
            _videoLockCallbackDelegate = null;
            _videoUnlockCallbackDelegate = null;
            _videoDisplayCallbackDelegate = null;
        }

        ID2D1Bitmap? bitmapToDispose = null;

        lock (_frameLock)
        {
            bitmapToDispose = _videoBitmap; _videoBitmap = null;
            _latestFrameDataRaw = null; // Release raw buffer
            _conversionBufferBGRA32 = null; // Release conversion buffer
            _newFrameAvailable = false;
            _videoWidth = 0;
            _videoHeight = 0;
            _receivedChroma = 0;
            _receivedPitch = 0;
            _bufferSize = 0;
        }

        _formatConfigured = false; // Ensure flag is reset
        bitmapToDispose?.Dispose();

        Log.Info($"VideoPlayer '{Name}' disposed.");
    }

    private void DisposeVlcResources()
    {
        Log.Warning($"DisposeVlcResources called directly for '{Name}'. Use Dispose().");
        Dispose(true);
    }

    ~VideoPlayer()
    {
        Dispose(false);
    }
}
</file>

<file path="Source\Nodes\WindowNode.cs">
namespace Cherris;

public class WindowNode : Node2D
{
    protected SecondaryWindow? secondaryWindow;
    private string windowTitle = "Cherris Window";
    private int windowWidth = 640;
    private int windowHeight = 480;
    private SystemBackdropType backdropType = SystemBackdropType.None;

    protected bool isQueuedForFree = false;

    public string Title
    {
        get => windowTitle;
        set
        {
            if (windowTitle == value) return;
            windowTitle = value;
        }
    }

    public int Width
    {
        get => windowWidth;
        set
        {
            if (windowWidth == value) return;
            windowWidth = value;
        }
    }

    public int Height
    {
        get => windowHeight;
        set
        {
            if (windowHeight == value) return;
            windowHeight = value;
        }
    }

    public SystemBackdropType BackdropType
    {
        get => backdropType;
        set
        {
            if (backdropType == value) return;
            backdropType = value;
            secondaryWindow?.ApplySystemBackdrop();
        }
    }

    public override void Make()
    {
        base.Make();
        InitializeWindow();
    }

    public override void Process()
    {
        base.Process();

        if (isQueuedForFree)
        {
            FreeInternal();
        }
    }

    private void InitializeWindow()
    {
        if (secondaryWindow is not null)
        {
            Log.Warning($"WindowNode '{Name}' already has an associated window. Skipping creation.");
            return;
        }

        try
        {
            secondaryWindow = new SecondaryWindow(Title, this.Width, this.Height, this);

            if (!secondaryWindow.TryCreateWindow())
            {
                Log.Error($"WindowNode '{Name}' failed to create its window.");
                secondaryWindow = null;
                return;
            }

            secondaryWindow.BackdropType = this.BackdropType;

            if (!secondaryWindow.InitializeWindowAndGraphics())
            {
                Log.Error($"WindowNode '{Name}' failed to initialize window graphics.");
                secondaryWindow.Dispose();
                secondaryWindow = null;
                return;
            }

            secondaryWindow.ShowWindow();
            Log.Info($"WindowNode '{Name}' successfully created and initialized its window.");
        }
        catch (Exception ex)
        {
            Log.Error($"Error during WindowNode '{Name}' initialization: {ex.Message}");
            secondaryWindow?.Dispose();
            secondaryWindow = null;
        }
    }

    public void QueueFree()
    {
        isQueuedForFree = true;
    }

    protected virtual void FreeInternal()
    {
        Log.Info($"Freeing WindowNode '{Name}' and its associated window.");
        secondaryWindow?.Close();
        secondaryWindow = null;
        base.Free();
    }

    public override void Free()
    {
        if (!isQueuedForFree)
        {
            Log.Warning($"Direct call to Free() on WindowNode '{Name}' detected. Use QueueFree() instead.");
            QueueFree();
        }
    }

    internal void RenderChildren(DrawingContext context)
    {
        foreach (Node child in Children)
        {
            RenderNodeRecursive(child, context);
        }
    }

    private static void RenderNodeRecursive(Node node, DrawingContext context)
    {
        if (node is WindowNode)
        {
            return;
        }

        if (node is VisualItem { Visible: true } visualItem)
        {
            visualItem.Draw(context);
        }

        var childrenToRender = new List<Node>(node.Children);
        foreach (Node child in childrenToRender)
        {
            RenderNodeRecursive(child, context);
        }
    }

    public SecondaryWindow? GetWindowHandle() => secondaryWindow;

    public Vector2 LocalMousePosition => secondaryWindow?.GetLocalMousePosition() ?? Input.MousePosition;
}
</file>

<file path="Source\Resources\Animation.cs">
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Cherris;

public class Animation
{
    public List<Keyframe> Keyframes { get; set; } = new();

    public class Keyframe
    {
        [YamlMember(Alias = "T")]
        public float Time { get; set; }

        public Dictionary<string, Dictionary<string, float>> Nodes { get; set; } = [];
    }

    public Animation() { }

    public Animation(string filePath)
    {
        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(PascalCaseNamingConvention.Instance)
            .Build();

        Keyframes = deserializer.Deserialize<List<Keyframe>>(File.ReadAllText(filePath));
    }
}
</file>

<file path="Source\Resources\AudioStream.cs">
namespace Cherris;

public class AudioStream
{
    //public float Length { get; private set; } = 0.1f;
    //public string Path { get; private set; }
    //
    //private Music raylibMusic;
    //
    //public static implicit operator Music(AudioStream audio) => audio.raylibMusic;
    //
    //private AudioStream(Music music, float length, string path)
    //{
    //    raylibMusic = music;
    //    Length = length;
    //    Path = path;
    //}
    //
    public static AudioStream? Load(string filePath)
    {
        return null;
    }
}
</file>

<file path="Source\Resources\Font.cs">
using Raylib_cs;

namespace Cherris;

public class Font
{
    public string Name = "";
    public int Size = 0;

    private Raylib_cs.Font raylibFont;

    public Vector2 Dimensions
    {
        get
        {
            return Raylib.MeasureTextEx(raylibFont, " ", Size, 0);
        }
    }

    public Font(string filePath, int size)
    {
        Size = size;
        Name = Path.GetFileNameWithoutExtension(filePath);

        int[] codepoints = new int[255 - 32 + 1];
        for (int i = 0; i < codepoints.Length; i++)
        {
            codepoints[i] = 32 + i;
        }

        raylibFont = Raylib.LoadFontEx(filePath, size, codepoints, codepoints.Length);
        Raylib.SetTextureFilter(raylibFont.Texture, TextureFilter.Bilinear);
    }

    public static implicit operator Raylib_cs.Font(Font textFont) => textFont.raylibFont;

    public static Vector2 MeasureText(Font font, string text, int size, float spacing)
    {
        Vector2 measurements = Raylib.MeasureTextEx(
            font,
            text,
            size,
            spacing);

        return measurements;
    }
}
</file>

<file path="Source\Resources\Shader.cs">
namespace Cherris;

public class Shader
{
    private Raylib_cs.Shader raylibShader;

    private Shader(Raylib_cs.Shader shader)
    {
        raylibShader = shader;
    }

    public static Shader? Load(string? vertexShaderPath, string? fragmentShaderPath)
    {
        Raylib_cs.Shader shader = Raylib_cs.Raylib.LoadShader(vertexShaderPath, fragmentShaderPath);

        if (!Raylib_cs.Raylib.IsShaderValid(shader))
        {
            Log.Error($"Failed to load shader: {vertexShaderPath},{fragmentShaderPath}");
            return null;
        }

        return new(shader);
    }

    public static implicit operator Raylib_cs.Shader(Shader shader)
    {
        return shader.raylibShader;
    }

    public void SetValue(int loc, float[] values, ShaderUniformDataType uniformType)
    {
        Raylib_cs.Raylib.SetShaderValue(
            this,
            loc,
            values,
            (Raylib_cs.ShaderUniformDataType)uniformType);
    }

    public int GetLocation(string uniformName)
    {
        return Raylib_cs.Raylib.GetShaderLocation(this, uniformName);
    }
}
</file>

<file path="Source\Resources\ShaderUniformDataType.cs">
namespace Cherris;

public enum ShaderUniformDataType
{
    Float = 0,
    Vec2,
    Vec3,
    Vec4,
    Int,
    IVec2,
    IVec3,
    IVec4,
    Sampler2D
}
</file>

<file path="Source\Resources\Sound.cs">
namespace Cherris;

public class Sound
{
    public string Path { get; private set; } = "";

    private Raylib_cs.Sound raylibSound;

    public static implicit operator Raylib_cs.Sound(Sound sound) => sound.raylibSound;

    private Sound(Raylib_cs.Sound sound, string filePath)
    {
        raylibSound = sound;
        Path = filePath;
    }

    public static Sound? Load(string filePath)
    {
        Raylib_cs.Sound sound = Raylib_cs.Raylib.LoadSound(filePath);

        if (sound.FrameCount == 0)
        {
            return null;
        }

        return new(sound, filePath);
    }

    public void Play(string bus = "Master")
    {
        //AudioServer.Instance.PlaySound(this, bus);
    }
}
</file>

<file path="Source\Resources\Texture.cs">
using Raylib_cs;

namespace Cherris;

public class Texture
{
    public Vector2 Size { get; private set; } = Vector2.Zero;
    private Texture2D raylibTexture;

    public Texture(string filePath)
    {
        string pngPath =
            Path.GetExtension(filePath).ToLower() == ".png" ?
            filePath :
            GetPngPath(filePath);

        raylibTexture = Raylib.LoadTexture(pngPath);
        Size = new(raylibTexture.Width, raylibTexture.Height);

        if (pngPath != filePath)
        {
            File.Delete(pngPath);
        }
    }

    public Texture()
    {
    }

    public static implicit operator Texture2D(Texture texture) => texture.raylibTexture;

    private static string GetPngPath(string imagePath)
    {
        if (!Directory.Exists("Res/Cherris/Temporary"))
        {
            Directory.CreateDirectory("Res/Temporary");
        }

        string pngPath = $"Res/Cherris/Temporary/{Path.GetFileNameWithoutExtension(imagePath)}.png";

        if (!File.Exists(pngPath))
        {
            //using var image = SixLabors.ImageSharp.Image.Load(imagePath);
            //image.SaveAsPng(pngPath);
        }

        return pngPath;
    }
}
</file>

<file path="Source\Scene\NodePropertySetter.cs">
using System.Reflection;

namespace Cherris;

public static class NodePropertySetter
{
    private static readonly string[] SpecialProperties = { "type", "name", "path", "children", "Node" };

    public static void SetProperties(Node node, Dictionary<string, object> element, List<(Node, string, object)>? deferredNodeAssignments = null)
    {
        foreach ((string key, object value) in element)
        {
            if (SpecialProperties.Contains(key, StringComparer.OrdinalIgnoreCase))
            {
                continue;
            }

            SetNestedMember(node, key, value, deferredNodeAssignments);
        }
    }

    public static void SetNestedMember(object rootInstance, string fullMemberPath, object value, List<(Node, string, object)>? deferredNodeAssignments = null)
    {
        string[] pathParts = fullMemberPath.Split('/');
        object currentObject = rootInstance; // Start from the root instance

        for (var i = 0; i < pathParts.Length; i++)
        {
            var memberName = pathParts[i];
            var memberInfo = ReflectionUtils.GetMemberInfo(currentObject.GetType(), memberName);
            bool isFinalSegment = i == pathParts.Length - 1;

            if (isFinalSegment)
            {
                // We are at the final part of the path. 'currentObject' is the direct parent of the member to be set.
                // 'memberInfo' is the member itself. 'value' is the value from YAML.

                Type memberType = ReflectionUtils.GetMemberType(memberInfo);

                // If the YAML value is a dictionary, and the target member is a complex object type
                if (value is Dictionary<object, object> dictValue && IsComplexObjectType(memberType))
                {
                    // Get the existing instance of this member from its parent ('currentObject').
                    object? existingMemberInstance = ReflectionUtils.GetMemberValue(currentObject, memberInfo);
                    if (existingMemberInstance == null)
                    {
                        // If the property was null (e.g., not initialized in constructor), create and assign it.
                        existingMemberInstance = Activator.CreateInstance(memberType) ?? throw new InvalidOperationException($"Failed to create instance of {memberType.Name}");
                        ReflectionUtils.SetMemberValue(currentObject, memberInfo, existingMemberInstance);
                    }

                    // Now, iterate through the YAML dictionary ('dictValue') and set properties on 'existingMemberInstance'.
                    // For each key-value pair in 'dictValue', make a recursive call to SetNestedMember.
                    // The 'rootInstance' remains the same (for potential deeper deferrals).
                    // The 'fullMemberPath' for the recursive call is extended with the current sub-key.
                    foreach (KeyValuePair<object, object> entry in dictValue)
                    {
                        string subKey = entry.Key.ToString()!;
                        object subValue = entry.Value;
                        // Construct the full path for this sub-property relative to the rootInstance
                        string subPropertyFullPath = fullMemberPath + "/" + subKey;

                        // Recursive call to set the sub-property.
                        SetNestedMember(rootInstance, subPropertyFullPath, subValue, deferredNodeAssignments);
                    }
                }
                else if (ShouldDeferAssignment(memberType, value))
                {
                    if (rootInstance is Node nodeForDeferral)
                    {
                        deferredNodeAssignments?.Add((nodeForDeferral, fullMemberPath, value));
                    }
                    else
                    {
                        // This case means rootInstance was not a Node, but we are trying to defer.
                        // This can happen if SetNestedMember is called for something like Configuration loading.
                        // Deferral is only relevant for Nodes.
                        if (deferredNodeAssignments != null) // Only log if deferral was expected
                        {
                            Log.Warning($"Cannot defer assignment for non-Node root target: {rootInstance.GetType().Name} for path {fullMemberPath}. This may be normal if loading non-Node configurations.");
                        }
                        // Fallback to direct setting if not a Node context for deferral
                        var convertedNonDeferredValue = ValueConversionUtils.ConvertValue(memberType, value);
                        ReflectionUtils.SetMemberValue(currentObject, memberInfo, convertedNonDeferredValue);
                    }
                }
                else
                {
                    // Primitive, list, enum, or Node path (string) to be converted directly
                    var convertedValue = ValueConversionUtils.ConvertValue(memberType, value);
                    ReflectionUtils.SetMemberValue(currentObject, memberInfo, convertedValue);
                }
                return; // Handled the final segment
            }
            else // Not the final segment, navigate deeper
            {
                object? nextObject = ReflectionUtils.GetMemberValue(currentObject, memberInfo);
                if (nextObject == null)
                {
                    nextObject = ReflectionUtils.CreateMemberInstance(memberInfo);
                    ReflectionUtils.SetMemberValue(currentObject, memberInfo, nextObject);
                }
                currentObject = nextObject;
            }
        }
    }

    private static bool ShouldDeferAssignment(Type memberType, object value)
    {
        return memberType.IsSubclassOf(typeof(Node)) && value is string;
    }

    private static bool IsComplexObjectType(Type type)
    {
        // Types that ValueConversionUtils.ConvertValue handles from non-dictionary sources (string, list, primitive)
        if (type.IsEnum || type == typeof(string) || type.IsPrimitive || type == typeof(decimal))
            return false;

        // Node paths are handled by ShouldDeferAssignment or direct string conversion if not deferred
        if (type.IsSubclassOf(typeof(Node)))
            return false;

        // Resource types loaded from string paths
        if (type == typeof(AudioStream) || type == typeof(Sound) || type == typeof(Animation) || type == typeof(Texture) || type == typeof(Font))
            return false;

        // Types like Vector2, Color, List<T> are converted from YAML lists by ValueConversionUtils
        // If YAML provides a dictionary for these, this method will return true, and they will be populated recursively.
        // This is generally fine, e.g. MyVector: { X:1, Y:2 }
        if (type == typeof(Vector2) || type == typeof(Color)) return false; // if YAML is a list
        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>)) return false; // if YAML is a list

        // If it's a class (and not Node/Resource) or a non-primitive, non-enum struct,
        // and the YAML provides a dictionary, we want to populate it recursively.
        if (type.IsClass) return true;

        // For structs (ValueType) that are not primitive, enum, decimal, Vector2, Color
        if (type.IsValueType && !type.IsEnum && !type.IsPrimitive && type != typeof(decimal) && type != typeof(Vector2) && type != typeof(Color))
            return true;

        return false; // Default to not complex if not explicitly class or user-defined struct
    }
}
</file>

<file path="Source\Scene\PackedScene.cs">
using System.Reflection;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;
using System.Linq; // Added for LINQ methods like FirstOrDefault

namespace Cherris;

public sealed class PackedScene(string path)
{
    private readonly string _path = path;
    private static readonly IDeserializer _deserializer = new DeserializerBuilder()
        .WithNamingConvention(PascalCaseNamingConvention.Instance) // Changed from CamelCase
        .Build();

    public T Instantiate<T>() where T : Node
    {
        var deferredNodeAssignments = new List<(Node, string, object)>();
        var namedNodes = new Dictionary<string, Node>();

        string yamlContent = File.ReadAllText(_path);
        var rootElement = _deserializer.Deserialize<Dictionary<string, object>>(yamlContent);
        Node rootNode = (T)ParseNode(rootElement, null, deferredNodeAssignments, namedNodes);
        AssignDeferredNodes(deferredNodeAssignments, namedNodes);
        return (T)rootNode;
    }

    private Node ParseNode(Dictionary<string, object> element, Node? parent, List<(Node, string, object)> deferredNodeAssignments, Dictionary<string, Node> namedNodes)
    {
        var node = CreateNodeInstance(element);
        ProcessNestedScene(element, ref node);
        SetNodeProperties(element, node, deferredNodeAssignments);
        AddToParent(parent, node);
        RegisterNode(node, namedNodes);
        ProcessChildNodes(element, node, deferredNodeAssignments, namedNodes);
        return node;
    }

    private static Node CreateNodeInstance(Dictionary<string, object> element)
    {
        if (!element.TryGetValue("Node", out var nodeDescriptorObj))
            throw new KeyNotFoundException("Element is missing the 'Node' key.");
        var nodeDescriptor = (string)nodeDescriptorObj;
        var parts = nodeDescriptor.Split(["::"], StringSplitOptions.None);
        if (parts.Length != 2)
            throw new FormatException($"Invalid Node descriptor '{nodeDescriptor}'. Expected 'Type::Name'.");

        var typeNameToResolve = parts[0]; // e.g., "MainScene"
        var nodeInstanceName = parts[1];

        // Use our enhanced type resolution.
        Type? nodeType = FindTypeByNameInRelevantAssemblies(typeNameToResolve);

        if (nodeType == null)
        {
            // If our method fails, give TypeResolverUtils a chance, as it might have other logic (e.g. aliases)
            // However, the error implies TypeResolverUtils is already failing for this case.
            try
            {
                nodeType = TypeResolverUtils.ResolveType(typeNameToResolve);
            }
            catch (Exception ex)
            {
                // Assuming Log class is available as used in ReflectionUtils
                // Log.Warning($"[PackedScene] TypeResolverUtils also failed to find type '{typeNameToResolve}': {ex.Message}");
            }
        }

        if (nodeType == null)
        {
            throw new InvalidOperationException($"Type '{typeNameToResolve}' not found. Searched entry assembly, core assembly, all loaded assemblies, and via TypeResolverUtils.");
        }

        var node = (Node)Activator.CreateInstance(nodeType)!;
        node.Name = nodeInstanceName;
        return node;
    }

    private static Type? FindTypeByNameInRelevantAssemblies(string simpleOrFullName)
    {
        // Strategy:
        // 1. Try direct resolution (for fully qualified names or well-known types that Type.GetType can handle)
        Type? foundType = Type.GetType(simpleOrFullName, throwOnError: false, ignoreCase: true);
        if (foundType != null) return foundType;

        // 2. Search Entry Assembly (typically user's game/app assembly)
        Assembly? entryAssembly = Assembly.GetEntryAssembly();
        if (entryAssembly != null)
        {
            try
            {
                foundType = entryAssembly.GetTypes().FirstOrDefault(t => t.Name.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase) || (t.FullName != null && t.FullName.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase)));
                if (foundType != null) return foundType;
            }
            catch (ReflectionTypeLoadException) { /* Ignore assembly if types cannot be loaded */ }
        }

        // 3. Search Core Cherris Assembly (where Node is defined)
        Assembly coreAssembly = typeof(Node).Assembly;
        if (coreAssembly != entryAssembly) // Avoid re-scanning if entry assembly is the core assembly
        {
            try
            {
                foundType = coreAssembly.GetTypes().FirstOrDefault(t => t.Name.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase) || (t.FullName != null && t.FullName.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase)));
                if (foundType != null) return foundType;
            }
            catch (ReflectionTypeLoadException) { /* Ignore assembly if types cannot be loaded */ }
        }

        // 4. Search all other loaded assemblies (as a broader fallback)
        foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
        {
            if (assembly == entryAssembly || assembly == coreAssembly) continue; // Already checked

            try
            {
                foundType = assembly.GetTypes().FirstOrDefault(t => t.Name.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase) || (t.FullName != null && t.FullName.Equals(simpleOrFullName, StringComparison.OrdinalIgnoreCase)));
                if (foundType != null) return foundType;
            }
            catch (ReflectionTypeLoadException)
            {
                // Some assemblies might fail to load types, ignore them and continue.
            }
        }
        return null; // Type not found through these prioritized searches
    }


    private static void ProcessNestedScene(Dictionary<string, object> element, ref Node node)
    {
        if (element.TryGetValue("path", out var pathValue))
        {
            if (!element.TryGetValue("Node", out var nodeDescriptorObj))
                throw new KeyNotFoundException("Element with 'path' is missing the 'Node' key.");
            var nodeDescriptor = (string)nodeDescriptorObj;
            var parts = nodeDescriptor.Split(new[] { "::" }, StringSplitOptions.None);
            if (parts.Length != 2)
                throw new FormatException($"Invalid Node descriptor '{nodeDescriptor}'. Expected 'Type::Name'.");
            var nodeName = parts[1];

            var scenePath = (string)pathValue;
            var nestedScene = new PackedScene(scenePath);
            node = nestedScene.Instantiate<Node>();
            node.Name = nodeName;
        }
    }

    private static void SetNodeProperties(Dictionary<string, object> element, Node node, List<(Node, string, object)> deferredNodeAssignments)
    {
        Dictionary<string, object> properties = element
            .Where(kvp => !IsReservedKey(kvp.Key))
            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

        NodePropertySetter.SetProperties(node, properties, deferredNodeAssignments);
    }

    private static bool IsReservedKey(string key)
    {
        return key is "children" or "Node" or "path";
    }

    private static void AddToParent(Node? parent, Node node)
    {
        parent?.AddChild(node, node.Name);
    }

    private static void RegisterNode(Node node, Dictionary<string, Node> namedNodes)
    {
        namedNodes[node.Name] = node;
    }

    private void ProcessChildNodes(Dictionary<string, object> element, Node parentNode, List<(Node, string, object)> deferredNodeAssignments, Dictionary<string, Node> namedNodes)
    {
        if (!element.TryGetValue("children", out var childrenObj)) return;
        var children = ConvertChildrenToList(childrenObj);
        foreach (var child in children)
        {
            if (child is Dictionary<object, object> childDict)
            {
                var convertedChild = ConvertChildDictionary(childDict);
                ParseNode(convertedChild, parentNode, deferredNodeAssignments, namedNodes);
            }
        }
    }

    private static List<object> ConvertChildrenToList(object childrenObj)
    {
        return childrenObj is List<object> list ? list : [];
    }

    private static Dictionary<string, object> ConvertChildDictionary(Dictionary<object, object> childDict)
    {
        return childDict.ToDictionary(kvp => kvp.Key.ToString()!, kvp => kvp.Value);
    }

    private void AssignDeferredNodes(List<(Node, string, object)> deferredNodeAssignments, Dictionary<string, Node> namedNodes)
    {
        foreach (var (targetNode, memberPath, nodePath) in deferredNodeAssignments)
        {
            AssignDeferredNode(targetNode, memberPath, nodePath, namedNodes);
        }
    }

    private void AssignDeferredNode(Node targetNode, string memberPath, object nodePath, Dictionary<string, Node> namedNodes)
    {
        string[] pathParts = memberPath.Split('/');
        object currentObject = targetNode;

        for (int i = 0; i < pathParts.Length; i++)
        {
            string part = pathParts[i];
            Type currentType = currentObject.GetType();
            (MemberInfo? memberInfo, object? nextObject) = GetMemberAndNextObject(currentType, part, currentObject);
            if (i == pathParts.Length - 1)
            {
                AssignNodeToMember(memberInfo, currentObject, nodePath, targetNode, namedNodes);
            }
            else
            {
                currentObject = nextObject!;
            }
        }
    }

    private static (MemberInfo?, object?) GetMemberAndNextObject(Type type, string memberName, object currentObject)
    {
        PropertyInfo? propertyInfo = type.GetProperty(memberName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        if (propertyInfo != null)
        {
            object? nextObject = propertyInfo.GetValue(currentObject) ?? Activator.CreateInstance(propertyInfo.PropertyType);
            propertyInfo.SetValue(currentObject, nextObject);
            return (propertyInfo, nextObject);
        }

        FieldInfo? fieldInfo = type.GetField(memberName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        if (fieldInfo != null)
        {
            object? nextObject = fieldInfo.GetValue(currentObject) ?? Activator.CreateInstance(fieldInfo.FieldType);
            fieldInfo.SetValue(currentObject, nextObject);
            return (fieldInfo, nextObject);
        }

        throw new Exception($"Member '{memberName}' not found on type '{type.Name}'.");
    }

    private static void AssignNodeToMember(MemberInfo? memberInfo, object targetObject, object nodePath, Node targetNode, Dictionary<string, Node> namedNodes)
    {
        if (memberInfo is PropertyInfo propertyInfo && propertyInfo.PropertyType.IsSubclassOf(typeof(Node)))
        {
            Node referencedNode = ResolveNodePath(nodePath, namedNodes, targetNode);
            propertyInfo.SetValue(targetObject, referencedNode);
        }
        else if (memberInfo is FieldInfo fieldInfo && fieldInfo.FieldType.IsSubclassOf(typeof(Node)))
        {
            Node referencedNode = ResolveNodePath(nodePath, namedNodes, targetNode);
            fieldInfo.SetValue(targetObject, referencedNode);
        }
        else
        {
            throw new Exception($"Member '{memberInfo?.Name}' is not a Node-derived type.");
        }
    }

    private static Node ResolveNodePath(object nodePath, Dictionary<string, Node> namedNodes, Node targetNode)
    {
        if (nodePath is string pathString)
        {
            return namedNodes.TryGetValue(pathString, out Node? node)
                ? node
                : targetNode.GetNode<Node>(pathString);
        }

        throw new Exception($"Unsupported node path type: {nodePath.GetType()}");
    }
}
</file>

<file path="Source\Scene\PackedSceneXml.cs">
using System.Xml.Linq;
using System.Reflection;
using System.Globalization;

namespace Cherris;

public sealed class PackedSceneXml(string path)
{
    private readonly string _path = path;

    public T Instantiate<T>() where T : Node
    {
        var doc = XDocument.Load(_path);
        var rootElement = doc.Root;

        if (rootElement == null || rootElement.Name != "Node")
            throw new Exception($"Invalid root element in scene file '{_path}'");

        var rootNode = (T)LoadNode(rootElement);
        return rootNode;
    }

    private Node LoadNode(XElement element)
    {
        // Get the node name attribute (required)
        string nodeName = element.Attribute("name")?.Value
            ?? throw new Exception($"Missing 'name' attribute on element <{element.Name}>");

        // Use the element's tag name as the type name
        string nodeType = element.Name.LocalName;

        var node = CreateNodeInstance(nodeType);
        node.Name = nodeName;

        // Load child nodes:
        // Children are all elements which are NOT recognized as properties (like Position, Scale, etc.)
        foreach (var childElement in element.Elements())
        {
            // Check if the child element is a property or a node:
            if (IsPropertyElement(childElement.Name.LocalName))
            {
                // This is a property element, set property on this node
                SetNodeProperty(node, childElement);
            }
            else
            {
                // Otherwise, treat it as a child node
                var childNode = LoadNode(childElement);
                node.AddChild(childNode, childNode.Name);
            }
        }

        return node;
    }

    private static bool IsPropertyElement(string elementName)
    {
        // List your known property names here; you can add more as needed
        return elementName == "Position" ||
               elementName == "Scale" ||
               elementName == "Size" ||
               elementName == "FilePath" ||
               elementName == "AutoPlay" ||
               elementName == "Text";
    }

    private void SetNodeProperty(Node node, XElement element)
    {
        string propertyName = element.Name.LocalName;
        var propertyInfo = node.GetType().GetProperty(propertyName, BindingFlags.Public | BindingFlags.Instance);

        if (propertyInfo == null)
            return; // Property not found on node, silently skip or log if you want

        if (propertyInfo.PropertyType == typeof(Vector2))
        {
            float x = float.Parse(element.Attribute("x")?.Value ?? "0", CultureInfo.InvariantCulture);
            float y = float.Parse(element.Attribute("y")?.Value ?? "0", CultureInfo.InvariantCulture);
            propertyInfo.SetValue(node, new Vector2(x, y));
        }
        else if (propertyInfo.PropertyType == typeof(bool))
        {
            propertyInfo.SetValue(node, bool.Parse(element.Value));
        }
        else if (propertyInfo.PropertyType == typeof(string))
        {
            propertyInfo.SetValue(node, element.Value);
        }
        else
        {
            object converted = Convert.ChangeType(element.Value, propertyInfo.PropertyType, CultureInfo.InvariantCulture);
            propertyInfo.SetValue(node, converted);
        }
    }

    private static Node CreateNodeInstance(string typeName)
    {
        // You may need to fully qualify the type name if it's in a namespace:
        // For example: "Cherris.HSlider"
        // So you might want to prepend your namespace if missing:
        if (!typeName.Contains('.'))
        {
            typeName = "Cherris." + typeName;
        }

        var type = Type.GetType(typeName)
                   ?? throw new Exception($"Unknown node type: '{typeName}'");

        return Activator.CreateInstance(type) as Node
               ?? throw new Exception($"Could not create instance of type '{typeName}'");
    }
}
</file>

<file path="Source\Scene\ReflectionUtils.cs">
using System.Reflection;

namespace Cherris;

public static class ReflectionUtils
{
    private const BindingFlags MemberBindingFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;

    public static MemberInfo GetMemberInfo(Type type, string memberName)
    {
        MemberInfo[] allMembers = type.GetMember(memberName, MemberBindingFlags | BindingFlags.IgnoreCase);

        if (allMembers.Length == 0)
        {
            throw new InvalidOperationException($"Member '{memberName}' not found on type '{type.Name}'");
        }

        if (allMembers.Length > 1)
        {
            var property = allMembers.OfType<PropertyInfo>().FirstOrDefault();
            if (property is not null)
            {
                return property;
            }

            var field = allMembers.OfType<FieldInfo>().FirstOrDefault();
            if (field != null)
            {
                return field;
            }

            Log.Error($"[GetMemberInfo] Ambiguity detected for member '{memberName}' on type '{type.Name}'. Found {allMembers.Length} members:");
            foreach (MemberInfo m in allMembers)
            {
                string memberTypeName = m switch { PropertyInfo p => p.PropertyType.Name, FieldInfo f => f.FieldType.Name, _ => m.MemberType.ToString() };
                Log.Error($"  - Name: {m.Name}, Kind: {m.MemberType}, Type: {memberTypeName}, Declared by: {m.DeclaringType?.FullName}");
            }

            throw new AmbiguousMatchException($"Ambiguous match found for member '{memberName}' on type '{type.Name}'.");
        }

        return allMembers[0];
    }

    public static Type GetMemberType(MemberInfo memberInfo)
    {
        return memberInfo switch
        {
            PropertyInfo p => p.PropertyType,
            FieldInfo f => f.FieldType,
            _ => throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'")
        };
    }

    public static object? GetMemberValue(object target, MemberInfo memberInfo)
    {
        return memberInfo switch
        {
            PropertyInfo p => p.GetValue(target),
            FieldInfo f => f.GetValue(target),
            _ => throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'")
        };
    }

    public static void SetMemberValue(object target, MemberInfo memberInfo, object value)
    {
        switch (memberInfo)
        {
            case PropertyInfo p:
                try
                {
                    p.SetValue(target, value);
                }
                catch (Exception ex)
                {
                    Log.Error($"Failed setting property '{p.Name}' on '{target.GetType().Name}': {ex.Message}");
                    throw;
                }
                break;

            case FieldInfo f:
                try
                {
                    f.SetValue(target, value);
                }
                catch (Exception ex)
                {
                    Log.Error($"Failed setting field '{f.Name}' on '{target.GetType().Name}': {ex.Message}");
                    throw;
                }
                break;

            default:
                throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'");
        }
    }

    public static object CreateMemberInstance(MemberInfo memberInfo)
    {
        Type typeToCreate = memberInfo switch
        {
            PropertyInfo p => p.PropertyType,
            FieldInfo f => f.FieldType,
            _ => throw new InvalidOperationException($"Unsupported member type '{memberInfo?.GetType().Name}' for member '{memberInfo?.Name}'")
        };

        return Activator.CreateInstance(typeToCreate) ?? throw new InvalidOperationException($"Failed to create instance of {typeToCreate.Name}");
    }
}
</file>

<file path="Source\Scene\SceneTree.cs">
using System.Runtime.CompilerServices;

namespace Cherris;

public sealed class SceneTree
{
    public static SceneTree Instance { get; } = new();

    public Node? RootNode { get; set; }
    public bool Paused { get; set; }

    private readonly ConditionalWeakTable<Node, object> readyNodes = [];
    private readonly List<SceneTreeTimer> timers = [];
    private readonly List<Tween> activeTweens = [];

    private SceneTree() { }

    public void Process()
    {
        if (RootNode is null)
        {
            return;
        }

        ProcessNode(RootNode);

        ProcessTweens();

        if (!Paused)
        {
            ProcessTimers();
        }
    }

    public void RenderScene(DrawingContext context)
    {
        if (RootNode is null)
        {
            return;
        }

        RenderNode(RootNode, context);
    }

    private void ProcessNode(Node node)
    {
        if (node is null || !node.Active)
        {
            return;
        }

        Node.ProcessMode effectiveMode = ComputeEffectiveProcessMode(node);
        bool shouldProcess = ShouldProcess(effectiveMode);

        if (shouldProcess)
        {
            EnsureNodeReady(node);
            node.ProcessBegin();
            node.Process();
        }


        var childrenToProcess = new List<Node>(node.Children);
        foreach (Node child in childrenToProcess)
        {
            ProcessNode(child);
        }

        if (shouldProcess)
        {
            node.ProcessEnd();
        }
    }

    private void EnsureNodeReady(Node node)
    {
        if (!readyNodes.TryGetValue(node, out _))
        {
            node.Ready();
            readyNodes.Add(node, null);
        }
    }

    private static Node.ProcessMode ComputeEffectiveProcessMode(Node node)
    {
        if (node.ProcessingMode != Node.ProcessMode.Inherit)
        {
            return node.ProcessingMode;
        }

        Node? current = node.Parent;

        while (current != null)
        {
            if (current.ProcessingMode != Node.ProcessMode.Inherit)
            {
                return current.ProcessingMode;
            }

            current = current.Parent;
        }

        return Node.ProcessMode.Pausable;
    }

    private bool ShouldProcess(Node.ProcessMode mode) => mode switch
    {
        Node.ProcessMode.Disabled => false,
        Node.ProcessMode.Always => true,
        Node.ProcessMode.Pausable => !Paused,
        Node.ProcessMode.WhenPaused => Paused,
        _ => false
    };

    private static void RenderNode(Node node, DrawingContext context)
    {

        if (node is WindowNode)
        {

            return;
        }

        if (node is VisualItem { Visible: true } visualItem)
        {
            visualItem.Draw(context);
        }


        var childrenToRender = new List<Node>(node.Children);
        foreach (Node child in childrenToRender)
        {
            RenderNode(child, context);
        }
    }

    public SceneTreeTimer CreateTimer(float time)
    {
        SceneTreeTimer timer = new(time);
        timers.Add(timer);
        return timer;
    }

    public void RemoveTimer(SceneTreeTimer timer)
    {
        timers.Remove(timer);
    }

    private void ProcessTimers()
    {
        var timersToProcess = new List<SceneTreeTimer>(timers);
        foreach (SceneTreeTimer timer in timersToProcess)
        {
            timer.Process();
        }
    }

    public void ChangeScene(Node node)
    {
        RootNode?.Free();
        RootNode = node;
        readyNodes.Clear();
    }

    public Tween CreateTween(Node creatorNode, Node.ProcessMode processMode = Node.ProcessMode.Inherit)
    {
        Tween tween = new(creatorNode, processMode);
        activeTweens.Add(tween);
        return tween;
    }

    private void ProcessTweens()
    {
        var tweensToProcess = new List<Tween>(activeTweens);
        foreach (Tween tween in tweensToProcess)
        {
            if (!tween.Active)
            {
                activeTweens.Remove(tween);
                continue;
            }

            if (tween.ShouldProcess(Paused))
            {
                // TODO: Properly integrate Time.Delta or pass it
                tween.Update(Time.Delta);
            }

            if (!tween.Active)
            {
                activeTweens.Remove(tween);
            }
        }
    }
}
</file>

<file path="Source\Scene\SceneTreeTimer.cs">
namespace Cherris;

public class SceneTreeTimer(float waitTime)
{
    public float WaitTime { get; set; } = waitTime;
    private float timePassed = 0;

    public delegate void TimerEventHandler();
    public event TimerEventHandler? Timeout;

    public void Process()
    {
        //timePassed += Time.Delta;

        if (timePassed >= WaitTime)
        {
            Timeout?.Invoke();
            SceneTree.Instance.RemoveTimer(this);
        }
    }
}
</file>

<file path="Source\Scene\StringExtensions.cs">
namespace Cherris;

public static class StringExtensions
{
    public static string TrimQuotes(this string input)
    {
        if (input is null || input.Length < 2)
        {
            return input ?? "";
        }

        if ((input[0] == '"' && input[^1] == '"') || (input[0] == '\'' && input[^1] == '\''))
        {
            return input[1..^1];
        }

        return input;
    }
}
</file>

<file path="Source\Scene\TypeResolverUtils.cs">
using System.Reflection;

namespace Cherris;

public static class TypeResolverUtils
{
    public static Type ResolveType(string typeName)
    {
        Type? foundType = null;

        foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
        {
            foundType = assembly.GetType(typeName, false, true);

            if (foundType is not null)
            {
                break;
            }

            if (typeName.Contains('.'))
            {
                continue;
            }

            foundType = assembly.GetType($"Cherris.{typeName}", false, true);

            if (foundType != null)
            {
                break;
            }
        }

        return foundType ?? throw new TypeLoadException($"Type '{typeName}' not found in any loaded assembly.");
    }
}
</file>

<file path="Source\Scene\ValueConversionUtils.cs">
using System.Collections;
using System.Globalization;

namespace Cherris;

public static class ValueConversionUtils
{
    public static object ConvertValue(Type targetType, object value)
    {
        return value switch
        {
            Dictionary<object, object> dict => ConvertNestedObject(targetType, dict),
            IList list => ConvertList(targetType, list),
            _ => ConvertPrimitive(targetType, value)
        };
    }

    private static object ConvertNestedObject(Type targetType, Dictionary<object, object> dict)
    {
        object instance = Activator.CreateInstance(targetType)
            ?? throw new InvalidOperationException($"Failed to create {targetType.Name} instance");

        foreach (var (key, val) in dict)
        {
            string memberName = key.ToString() ?? throw new InvalidDataException("Dictionary key cannot be null");
            var memberInfo = ReflectionUtils.GetMemberInfo(targetType, memberName);
            var memberActualType = ReflectionUtils.GetMemberType(memberInfo);
            var convertedValue = ConvertValue(memberActualType, val);
            ReflectionUtils.SetMemberValue(instance, memberInfo, convertedValue);
        }

        return instance;
    }

    private static object ConvertList(Type targetType, IList list)
    {
        if (targetType == typeof(List<int>))
        {
            return list.Cast<object>().Select(Convert.ToInt32).ToList();
        }

        if (targetType == typeof(Vector2))
        {
            return ParseVector2(list);
        }

        if (targetType == typeof(Color))
        {
            return ParseColor(list);
        }

        if (targetType.IsGenericType && targetType.GetGenericTypeDefinition() == typeof(List<>))
        {
            Type itemType = targetType.GetGenericArguments()[0];
            var genericList = (IList)Activator.CreateInstance(targetType)!;

            foreach (object? item in list)
            {
                genericList.Add(Convert.ChangeType(item, itemType, CultureInfo.InvariantCulture));
            }

            return genericList;
        }

        throw new NotSupportedException($"Unsupported list conversion to type {targetType}");
    }

    private static object ConvertPrimitive(Type targetType, object value)
    {
        string stringValue = value?.ToString()?.TrimQuotes().Trim() ?? ""; // Added .Trim() here

        if (targetType.IsEnum)
        {
            // Pre-parse diagnostic logging specifically for AnchorPreset
            if (targetType.Name == "AnchorPreset") // Check against simple name first
            {
                string currentValidNames = string.Join(", ", Enum.GetNames(targetType));
                Log.Info($"[ValueConversionUtils] Attempting to parse for enum '{targetType.FullName}' (from Assembly: '{targetType.Assembly.FullName}'): Value='{stringValue}', Available Enum Names: [{currentValidNames}]");
            }

            try
            {
                return Enum.Parse(targetType, stringValue, true);
            }
            catch (ArgumentException ex) // Specifically catch ArgumentException from Enum.Parse
            {
                string validNames = string.Join(", ", Enum.GetNames(targetType));
                string assemblyName = targetType.Assembly.FullName ?? "Unknown Assembly";
                Log.Error($"[ValueConversionUtils] ArgumentException during Enum.Parse. Target Enum: '{targetType.FullName}' (from Assembly: '{assemblyName}'), Value: '{stringValue}', Message: '{ex.Message}'. Valid names for this enum: [{validNames}]");
                throw new InvalidOperationException($"Failed to parse enum '{targetType.FullName}' (from Assembly: '{assemblyName}') from value '{stringValue}'. Valid values are: [{validNames}]. Ensure no extra whitespace and correct casing (ignored).", ex);
            }
            catch (Exception ex) // Catch any other unexpected exceptions during enum parsing
            {
                string validNames = string.Join(", ", Enum.GetNames(targetType));
                string assemblyName = targetType.Assembly.FullName ?? "Unknown Assembly";
                Log.Error($"[ValueConversionUtils] Generic Exception during Enum.Parse. Target Enum: '{targetType.FullName}' (from Assembly: '{assemblyName}'), Value: '{stringValue}', Message: '{ex.Message}'. Valid names for this enum: [{validNames}]");
                throw new InvalidOperationException($"An unexpected error occurred while parsing enum '{targetType.FullName}' (from Assembly: '{assemblyName}') from value '{stringValue}'. Valid values are: [{validNames}].", ex);
            }
        }

        TypeCode typeCode = Type.GetTypeCode(targetType);

        try
        {
            switch (typeCode)
            {
                case TypeCode.Int32:
                    return int.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.UInt32:
                    return uint.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.Single:
                    return float.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.Double:
                    return double.Parse(stringValue, CultureInfo.InvariantCulture);

                case TypeCode.Boolean:
                    return bool.Parse(stringValue);

                case TypeCode.String:
                    return stringValue; // Already trimmed and quotes handled
            }
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Failed to convert primitive value '{stringValue}' to type {targetType.Name}.", ex);
        }

        if (targetType == typeof(AudioStream))
        {
            return ResourceLoader.Load<AudioStream>(stringValue)!;
        }

        if (targetType == typeof(Sound))
        {
            return ResourceLoader.Load<Sound>(stringValue)!;
        }

        if (targetType == typeof(Animation))
        {
            return ResourceLoader.Load<Animation>(stringValue)!;
        }

        if (targetType == typeof(Texture))
        {
            return ResourceLoader.Load<Texture>(stringValue)!;
        }

        if (targetType == typeof(Font))
        {
            return ResourceLoader.Load<Font>(stringValue)!;
        }

        try
        {
            return Convert.ChangeType(stringValue, targetType, CultureInfo.InvariantCulture);
        }
        catch (Exception ex)
        {
            throw new NotSupportedException($"Unsupported primitive/resource type conversion from '{value?.GetType().Name ?? "null"}' to '{targetType.Name}' for value '{stringValue}'.", ex);
        }
    }

    private static Vector2 ParseVector2(IList list)
    {
        if (list.Count != 2)
        {
            throw new ArgumentException($"Vector2 requires exactly 2 elements, got {list.Count}");
        }

        try
        {
            var x = Convert.ToSingle(list[0], CultureInfo.InvariantCulture);
            var y = Convert.ToSingle(list[1], CultureInfo.InvariantCulture);
            return new Vector2(x, y);
        }
        catch (Exception ex)
        {
            throw new ArgumentException($"Failed to parse Vector2 elements: {ex.Message}", ex);
        }
    }

    private static Color ParseColor(IList list)
    {
        if (list.Count < 3 || list.Count > 4)
        {
            throw new ArgumentException($"Color requires 3 or 4 elements (R, G, B, [A]), got {list.Count}");
        }

        try
        {
            float r = ConvertToFloatColor(list[0]);
            float g = ConvertToFloatColor(list[1]);
            float b = ConvertToFloatColor(list[2]);
            float a = list.Count > 3 ? ConvertToFloatColor(list[3]) : 1.0f;

            return new Color(r, g, b, a);
        }
        catch (Exception ex)
        {
            throw new ArgumentException($"Failed to parse Color elements: {ex.Message}", ex);
        }
    }

    private static float ConvertToFloatColor(object component)
    {
        float value = Convert.ToSingle(component, CultureInfo.InvariantCulture);

        return value > 1.0f && value <= 255.0f
            ? value / 255.0f
            : float.Clamp(value, 0.0f, 1.0f);
    }
}
</file>

<file path="Source\Servers\ApplicationServer.cs">
using System.Diagnostics;
using System.Reflection;
using YamlDotNet.Serialization;

namespace Cherris;

public sealed class ApplicationServer
{
    private static readonly Lazy<ApplicationServer> lazyInstance = new(() => new ApplicationServer());
    private MainAppWindow? mainWindow;
    private Configuration? applicationConfig;
    private readonly List<SecondaryWindow> secondaryWindows = new();

    private const string ConfigFilePath = "Res/Cherris/Config.yaml";
    private const string LogFilePath = "Res/Cherris/Log.txt";

    public static ApplicationServer Instance => lazyInstance.Value;

    private readonly Stopwatch deltaTimeStopwatch = new();
    private long lastDeltaTimeTicks = 0;
    private const float MAX_DELTA_TIME = 1f / 30f; // approx 30 FPS, or 0.0333... seconds

    private ApplicationServer()
    {

    }

    public IntPtr GetMainWindowHandle()
    {
        return mainWindow?.Handle ?? IntPtr.Zero;
    }

    public MainAppWindow? GetMainAppWindow()
    {
        return mainWindow;
    }

    public void Run()
    {
        if (!Start())
        {
            Log.Error("ApplicationCore failed to start.");
            return;
        }

        if (mainWindow is null)
        {
            Log.Error("Main window was not initialized.");
            return;
        }

        deltaTimeStopwatch.Start();
        lastDeltaTimeTicks = deltaTimeStopwatch.ElapsedTicks;

        MainLoop();

        Log.Info("Main loop exited. Application exiting.");
        Cleanup();
    }

    private bool Start()
    {
        CreateLogFile();
        SetCurrentDirectory();

        applicationConfig = LoadConfig();
        if (applicationConfig is null)
        {
            Log.Error("Failed to load configuration.");
            return false;
        }

        try
        {
            mainWindow = new MainAppWindow(
                applicationConfig.Title,
                applicationConfig.Width,
                applicationConfig.Height);

            if (!mainWindow.TryCreateWindow())
            {
                Log.Error("Failed to create main window.");
                return false;
            }

            mainWindow.Closed += OnMainWindowClosed;

            if (mainWindow != null && applicationConfig != null)
            {
                mainWindow.VSyncEnabled = applicationConfig.VSync;
                mainWindow.BackdropType = applicationConfig.BackdropType;
            }

            if (!mainWindow.InitializeWindowAndGraphics())
            {
                Log.Error("Failed to initialize main window graphics.");
                return false;
            }

            ApplyConfig();

            mainWindow.ShowWindow();
        }
        catch (Exception ex)
        {
            Log.Error($"Error during window initialization: {ex.Message}");
            return false;
        }

        return true;
    }

    private void MainLoop()
    {
        while (mainWindow != null && mainWindow.IsOpen)
        {
            long currentTicks = deltaTimeStopwatch.ElapsedTicks;
            long elapsedFrameTicks = currentTicks - lastDeltaTimeTicks;

            float rawDeltaTime = (float)elapsedFrameTicks / TimeSpan.TicksPerSecond;

            // Ensure delta is not negative and clamp to a maximum value.
            // No minimum clamp, allowing it to be very small for high FPS.
            Time.Delta = Math.Max(0.0f, rawDeltaTime);
            Time.Delta = Math.Min(Time.Delta, MAX_DELTA_TIME);

            lastDeltaTimeTicks = currentTicks;

            ProcessSystemMessages();

            ClickServer.Instance.Process();
            SceneTree.Instance.Process();

            mainWindow.RenderFrame();
            RenderSecondaryWindows();

            Input.Update();
        }
    }

    private void ProcessSystemMessages()
    {
        while (NativeMethods.PeekMessage(out NativeMethods.MSG msg, IntPtr.Zero, 0, 0, NativeMethods.PM_REMOVE))
        {
            if (msg.message == NativeMethods.WM_QUIT)
            {
                Log.Info("WM_QUIT received, signaling application close.");
                mainWindow?.Close();
                break;
            }

            NativeMethods.TranslateMessage(ref msg);
            NativeMethods.DispatchMessage(ref msg);
        }
    }

    private void RenderSecondaryWindows()
    {
        List<SecondaryWindow> windowsToRender = new(secondaryWindows);

        foreach (SecondaryWindow window in windowsToRender)
        {
            if (window.IsOpen)
            {
                window.RenderFrame();
            }
            else
            {
                secondaryWindows.Remove(window);
            }
        }
    }

    private void OnMainWindowClosed()
    {
        Log.Info("Main window closed signal received. Closing secondary windows.");
        CloseAllSecondaryWindows();
    }

    private void Cleanup()
    {
        Log.Info("ApplicationCore Cleanup starting.");
        CloseAllSecondaryWindows();
        mainWindow?.Dispose();
        mainWindow = null;
        deltaTimeStopwatch.Stop();
        Log.Info("ApplicationCore Cleanup finished.");
    }

    private void CloseAllSecondaryWindows()
    {
        var windowsToClose = new List<SecondaryWindow>(secondaryWindows);
        foreach (var window in windowsToClose)
        {
            window.Close();
        }
    }

    internal void RegisterSecondaryWindow(SecondaryWindow window)
    {
        if (!secondaryWindows.Contains(window))
        {
            secondaryWindows.Add(window);
            Log.Info($"Registered secondary window: {window.Title}");
        }
    }

    internal void UnregisterSecondaryWindow(SecondaryWindow window)
    {
        if (secondaryWindows.Remove(window))
        {
            Log.Info($"Unregistered secondary window: {window.Title}");
        }
    }

    private static void SetRootNodeFromConfig(string scenePath)
    {
        if (string.IsNullOrEmpty(scenePath))
        {
            Log.Warning("MainScenePath is not defined in the configuration.");
            return;
        }

        try
        {
            var packedScene = new PackedScene(scenePath);
            SceneTree.Instance.RootNode = packedScene.Instantiate<Node>();
            Log.Info($"Loaded main scene: {scenePath}");
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to load main scene '{scenePath}': {ex.Message}");
            SceneTree.Instance.RootNode = new Node { Name = "ErrorRoot" };
        }
    }

    private static void CreateLogFile()
    {
        try
        {
            string? logDirectory = Path.GetDirectoryName(LogFilePath);
            if (!string.IsNullOrEmpty(logDirectory) && !Directory.Exists(logDirectory))
            {
                Directory.CreateDirectory(logDirectory);
            }

            if (File.Exists(LogFilePath))
            {
                File.Delete(LogFilePath);
            }

            using (File.Create(LogFilePath)) { }
            Log.Info($"Log file created at {Path.GetFullPath(LogFilePath)}");
        }
        catch (Exception ex)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"[FATAL] Failed to create log file: {ex.Message}");
            Console.ResetColor();
        }
    }

    private static void SetCurrentDirectory()
    {
        try
        {
            string? assemblyLocation = Assembly.GetEntryAssembly()?.Location;
            if (string.IsNullOrEmpty(assemblyLocation))
            {
                Log.Warning("Could not get assembly location.");
                return;
            }

            string? directoryName = Path.GetDirectoryName(assemblyLocation);
            if (string.IsNullOrEmpty(directoryName))
            {
                Log.Warning($"Could not get directory name from assembly location: {assemblyLocation}");
                return;
            }

            Environment.CurrentDirectory = directoryName;
            Log.Info($"Current directory set to: {directoryName}");
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to set current directory: {ex.Message}");
        }
    }

    private Configuration? LoadConfig()
    {
        if (!File.Exists(ConfigFilePath))
        {
            Log.Error($"Configuration file not found: {ConfigFilePath}");
            return null;
        }

        try
        {
            var deserializer = new DeserializerBuilder().Build();
            string yaml = File.ReadAllText(ConfigFilePath);
            var config = deserializer.Deserialize<Configuration>(yaml);
            Log.Info("Configuration loaded successfully.");
            return config;
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to load or parse configuration file '{ConfigFilePath}': {ex.Message}");
            return null;
        }
    }

    private void ApplyConfig()
    {
        if (applicationConfig is null)
        {
            Log.Error("Cannot apply configuration because it was not loaded.");
            return;
        }
        SetRootNodeFromConfig(applicationConfig.MainScenePath);
    }
}
</file>

<file path="Source\Nodes\Ui\Button.cs">
using Vortice.Mathematics;

namespace Cherris;

public class Button : Control
{
    public enum ActionMode { Release, Press }
    public enum ClickBehavior { Left, Right, Both }

    private bool pressedLeft = false;
    private bool pressedRight = false;
    private bool wasHovered = false;
    private string displayedText = "";

    public Vector2 TextOffset { get; set; } = Vector2.Zero;
    public HAlignment TextHAlignment { get; set; } = HAlignment.Center;
    public VAlignment TextVAlignment { get; set; } = VAlignment.Center;
    public ButtonStylePack Styles { get; set; } = new();
    public ActionMode LeftClickActionMode { get; set; } = ActionMode.Release;
    public ActionMode RightClickActionMode { get; set; } = ActionMode.Release;
    public ClickBehavior Behavior { get; set; } = ClickBehavior.Left;
    public float AvailableWidth { get; set; } = 0;
    public bool StayPressed { get; set; } = false;
    public bool ClipText { get; set; } = false;
    public bool AutoWidth { get; set; } = false;
    public Vector2 TextMargin { get; set; } = new(2, 2);
    public string Ellipsis { get; set; } = "...";
    public Texture? Icon { get; set; } = null;
    public float IconMargin { get; set; } = 12;
    public Sound? ClickSound { get; set; }
    public Sound? HoverSound { get; set; }

    public string Text
    {
        get => displayedText; // Return displayedText which is updated by setter

        set
        {
            if (displayedText == value) // Use displayedText for comparison
            {
                return;
            }

            displayedText = value; // Update displayedText
            // The original 'field' is no longer needed if displayedText is used directly.
        }
    }

    public event Action? LeftClicked;
    public event Action? RightClicked;
    public event Action? MouseEntered;
    public event Action? MouseExited;

    public Button()
    {
        Size = new(100, 26);
        Offset = Vector2.Zero;
        OriginPreset = OriginPreset.None;

        WasDisabled += (button) =>
        {
            Styles.Current = Disabled
            ? Styles.Disabled
            : Styles.Normal;
        };
    }

    public override void Process()
    {
        base.Process();

        if (Disabled)
        {
            return;
        }

        HandleClicks();
        HandleKeyboardInput();
    }

    protected virtual void OnEnterPressed() { }

    private void HandleKeyboardInput()
    {
        bool enterPressed = Input.IsKeyPressed(KeyCode.Enter);

        if (!Focused || !enterPressed)
        {
            return;
        }

        bool invoked = false;
        if (Behavior == ClickBehavior.Left || Behavior == ClickBehavior.Both)
        {
            LeftClicked?.Invoke();
            invoked = true;
        }

        if (Behavior == ClickBehavior.Right || Behavior == ClickBehavior.Both)
        {
            RightClicked?.Invoke();
            invoked = true;
        }

        if (invoked)
        {
            ClickSound?.Play(AudioBus);
            OnEnterPressed();
        }
    }

    private void HandleClicks()
    {
        bool isMouseOver = IsMouseOver();
        bool leftClickInvoked = false;
        bool rightClickInvoked = false;

        if (Behavior == ClickBehavior.Left || Behavior == ClickBehavior.Both)
        {
            leftClickInvoked = HandleSingleClick(
                ref pressedLeft,
                MouseButtonCode.Left,
                LeftClickActionMode,
                LeftClicked);
        }

        if (Behavior == ClickBehavior.Right || Behavior == ClickBehavior.Both)
        {
            rightClickInvoked = HandleSingleClick(
                ref pressedRight,
                MouseButtonCode.Right,
                RightClickActionMode,
                RightClicked);
        }

        HandleHover(isMouseOver);
        UpdateTheme(isMouseOver, pressedLeft || pressedRight);
    }

    private bool HandleSingleClick(ref bool pressedState, MouseButtonCode button, ActionMode mode, Action? handler)
    {
        bool invoked = false;
        bool mouseOver = IsMouseOver();
        bool buttonPressedThisFrame = Input.IsMouseButtonPressed(button);
        bool buttonReleasedThisFrame = Input.IsMouseButtonReleased(button);

        if (mouseOver && buttonPressedThisFrame && !Disabled)
        {
            pressedState = true;
            HandleClickFocus();

            if (mode == ActionMode.Press)
            {
                handler?.Invoke();
                ClickSound?.Play(AudioBus);
                invoked = true;
            }
        }

        if (!buttonReleasedThisFrame || !pressedState)
        {
            return invoked;
        }

        if (!Disabled && mouseOver && mode == ActionMode.Release)
        {
            handler?.Invoke();
            ClickSound?.Play(AudioBus);
            invoked = true;
        }

        if (!StayPressed)
        {
            pressedState = false;
        }
        else if (!mouseOver && mode == ActionMode.Release)
        {
            pressedState = false;
        }
        else if (mode == ActionMode.Press && !mouseOver)
        {
            pressedState = false;
        }

        return invoked;
    }

    private void HandleHover(bool isMouseOver)
    {
        if (Disabled)
        {
            if (wasHovered)
            {
                wasHovered = false;
                MouseExited?.Invoke();
            }

            return;
        }

        if (isMouseOver && !wasHovered)
        {
            MouseEntered?.Invoke();
            HoverSound?.Play(AudioBus);
            wasHovered = true;
        }
        else if (wasHovered && !isMouseOver) // check !isMouseOver here
        {
            wasHovered = false;
            MouseExited?.Invoke();
        }
    }

    private void UpdateTheme(bool isMouseOver, bool isPressedForStayPressed)
    {
        if (Disabled)
        {
            Styles.Current = Styles.Disabled;
            return;
        }

        bool isLeftDown = (Behavior == ClickBehavior.Left || Behavior == ClickBehavior.Both) && Input.IsMouseButtonDown(MouseButtonCode.Left);
        bool isRightDown = (Behavior == ClickBehavior.Right || Behavior == ClickBehavior.Both) && Input.IsMouseButtonDown(MouseButtonCode.Right);

        bool isPhysicallyHeldDown = isMouseOver && (isLeftDown || isRightDown);

        if (isPressedForStayPressed && StayPressed)
        {
            Styles.Current = Styles.Pressed;
        }
        else if (isPhysicallyHeldDown)
        {
            Styles.Current = Styles.Pressed;
        }
        else if (Focused)
        {
            Styles.Current = isMouseOver ? Styles.Hover : Styles.Focused;
        }
        else if (isMouseOver)
        {
            Styles.Current = Styles.Hover;
        }
        else
        {
            Styles.Current = Styles.Normal;
        }
    }

    protected override void OnThemeFileChanged(string themeFile)
    {
        Log.Warning($"OnThemeFileChanged not fully implemented for Button: {themeFile}");
    }

    public override void Draw(DrawingContext context)
    {
        if (!Visible)
        {
            return;
        }

        DrawButtonBackground(context);
        DrawIcon(context); // Icon drawing logic moved here from DrawText for better layering
        DrawButtonText(context);
    }

    protected virtual void DrawButtonBackground(DrawingContext context)
    {
        Vector2 position = GlobalPosition - Origin;
        Vector2 size = ScaledSize;
        Rect bounds = new(position.X, position.Y, size.X, size.Y);

        DrawStyledRectangle(context, bounds, Styles.Current);
    }

    private void DrawIcon(DrawingContext context) // Kept private as it's Button-specific for now
    {
        if (Icon is null || context.RenderTarget is null)
        {
            return;
        }

        Log.Warning("DrawIcon is not implemented.");
        // Placeholder for icon drawing logic
        // Example:
        // Vector2 iconPosition = CalculateIconPosition(); // Based on text, alignment, IconMargin
        // context.RenderTarget.DrawBitmap(....);
    }

    protected virtual void DrawButtonText(DrawingContext context)
    {
        if (Styles.Current is null || string.IsNullOrEmpty(displayedText)) // Check if displayedText is empty
        {
            return;
        }

        Vector2 position = GlobalPosition - Origin;
        Vector2 size = ScaledSize;

        // Adjust text layout rect if icon is present
        float textStartX = position.X + TextMargin.X + TextOffset.X;
        float textAvailableWidth = Math.Max(0, size.X - TextMargin.X * 2);

        if (Icon != null)
        {
            // This is a simplified adjustment. Real layout needs icon size.
            // Assuming icon is on the left.
            // float iconTotalWidth = Icon.Size.X + IconMargin;
            // textStartX += iconTotalWidth;
            // textAvailableWidth -= iconTotalWidth;
            Log.Warning("Button.DrawButtonText icon adjustment not fully implemented.");
        }


        var textLayoutRect = new Rect(
            textStartX,
            position.Y + TextMargin.Y + TextOffset.Y,
            textAvailableWidth,
            Math.Max(0, size.Y - TextMargin.Y * 2)
        );

        // ClipDisplayedText(); // Call this before drawing if AutoWidth is not fitting text

        DrawFormattedText(
            context,
            displayedText, // Use the Button's own displayedText
            textLayoutRect,
            Styles.Current,
            TextHAlignment,
            TextVAlignment
        );
    }

    private void ResizeToFitText()
    {
        if (!AutoWidth || Styles?.Current is null)
        {
            return;
        }

        Log.Warning("ResizeToFitText requires DirectWrite implementation.");
    }

    private void ClipDisplayedText()
    {
        if (!ClipText || string.IsNullOrEmpty(Text) || Styles?.Current is null)
        {
            // If not clipping, displayedText should be the full Text.
            // This assignment might be redundant if Text setter already updates displayedText.
            // displayedText = Text; // This was 'this.Text', ensure it refers to Button's Text
            return;
        }

        Log.Warning("ClipDisplayedText requires DirectWrite implementation.");

        // Fallback: ensure displayedText is based on Button's Text property.
        // displayedText = Text; // Ensure this refers to Button's Text.
    }

    private string GetTextClippedWithEllipsis(string input)
    {
        if (input.Length > Ellipsis.Length)
        {
            return input.Substring(0, input.Length - Ellipsis.Length) + Ellipsis;
        }
        return input;
    }
}
</file>

<file path="Source\Nodes\Ui\HBoxContainer.cs">
using System.Linq;
using System.Numerics;

namespace Cherris;

public class HBoxContainer : Node2D
{
    public float Separation { get; set; } = 4f;
    public HAlignment ContentHAlignment { get; set; } = HAlignment.Center;

    public override void Process()
    {
        base.Process();
        UpdateLayout();
    }

    protected override Vector2 ComputeAutoSize()
    {
        var visibleNode2DChildren = Children.OfType<Node2D>().Where(c => c.Visible).ToList();
        float requiredWidth = 0;
        float maxHeight = 0;

        if (visibleNode2DChildren.Any())
        {
            foreach (Node2D child in visibleNode2DChildren)
            {
                requiredWidth += child.Size.X;
                maxHeight = Math.Max(maxHeight, child.Size.Y);
            }
            requiredWidth += (visibleNode2DChildren.Count - 1) * Separation;
        }
        return new Vector2(requiredWidth, maxHeight);
    }

    private void UpdateLayout()
    {
        var visibleNode2DChildren = Children.OfType<Node2D>().Where(c => c.Visible).ToList();

        float containerWidth = this.Size.X;
        float containerHeight = this.Size.Y;

        float totalRequiredContentWidth = 0;
        if (visibleNode2DChildren.Any())
        {
            foreach (Node2D child in visibleNode2DChildren)
            {
                totalRequiredContentWidth += child.Size.X;
            }
            totalRequiredContentWidth += (visibleNode2DChildren.Count - 1) * Separation;
        }

        float visualLeftLocalX = 0f;
        if (this.HAlignment == HAlignment.Center)
        {
            visualLeftLocalX = -containerWidth / 2f;
        }
        else if (this.HAlignment == HAlignment.Right)
        {
            visualLeftLocalX = -containerWidth;
        }

        float childVisualStartX_local;
        switch (this.ContentHAlignment)
        {
            case HAlignment.Left:
                childVisualStartX_local = visualLeftLocalX;
                break;
            case HAlignment.Center:
                childVisualStartX_local = visualLeftLocalX + (containerWidth - totalRequiredContentWidth) / 2f;
                break;
            case HAlignment.Right:
                childVisualStartX_local = visualLeftLocalX + containerWidth - totalRequiredContentWidth;
                break;
            case HAlignment.None:
            default:
                childVisualStartX_local = visualLeftLocalX;
                break;
        }

        float currentVisualX = childVisualStartX_local; // This tracks the target visual left for the next child, relative to parent's origin

        foreach (Node2D child in visibleNode2DChildren)
        {
            float visualTopLocalY = 0f;
            if (this.VAlignment == VAlignment.Center) visualTopLocalY = -containerHeight / 2f;
            else if (this.VAlignment == VAlignment.Bottom) visualTopLocalY = -containerHeight;

            float childVisualTargetY_local; // Target visual top for the child, relative to parent's origin
            switch (child.VAlignment)
            {
                case VAlignment.Top:
                    childVisualTargetY_local = visualTopLocalY;
                    break;
                case VAlignment.Center:
                    childVisualTargetY_local = visualTopLocalY + (containerHeight - child.Size.Y) / 2f;
                    break;
                case VAlignment.Bottom:
                    childVisualTargetY_local = visualTopLocalY + containerHeight - child.Size.Y;
                    break;
                case VAlignment.None:
                default:
                    childVisualTargetY_local = visualTopLocalY;
                    break;
            }

            // Child's Position is its Origin's location relative to parent's Origin.
            // To place child's visual top-left at (currentVisualX, childVisualTargetY_local) [relative to parent's origin],
            // we set child.Position to (target_visual_left + child.Origin.X, target_visual_top + child.Origin.Y)
            child.Position = new Vector2(currentVisualX + child.Origin.X, childVisualTargetY_local + child.Origin.Y);

            currentVisualX += child.Size.X;
            if (visibleNode2DChildren.IndexOf(child) < visibleNode2DChildren.Count - 1)
            {
                currentVisualX += Separation;
            }
        }
    }
}
</file>

<file path="Source\Resources\Cache\AnimationCache.cs">
namespace Cherris;

public class AnimationCache
{
    private static AnimationCache? _instance;
    public static AnimationCache Instance => _instance ??= new AnimationCache();

    private readonly Dictionary<string, Animation> animations = [];

    private AnimationCache() { }

    public Animation Get(string animationPath)
    {
        if (animations.TryGetValue(animationPath, out Animation? animation))
        {
            return animation;
        }

        Animation newAnimation = new(animationPath);
        return newAnimation;
    }

    public void Dispose()
    {
        animations.Clear();
    }
}
</file>

<file path="Source\Resources\Cache\AudioStreamCache.cs">
namespace Cherris;

public class AudioStreamCache
{
    public static AudioStreamCache? Instance => field ??= new();

    private readonly Dictionary<string, AudioStream?> audioStreams = [];

    private AudioStreamCache() { }

    public AudioStream? Get(string filePath)
    {
        if (audioStreams.TryGetValue(filePath, out AudioStream? audio))
        {
            return audio;
        }

        AudioStream? newAudio = AudioStream.Load(filePath);

        if (newAudio is null)
        {
            Log.Error($"Could not load audio stream: {filePath}");
            return null;
        }

        audioStreams[filePath] = newAudio;
        return newAudio;
    }
}
</file>

<file path="Source\Resources\Cache\FontCache.cs">
namespace Cherris;

public sealed class FontCache
{
    public static FontCache? Instance => field ??= new();

    private readonly Dictionary<string, Font> fonts = [];

    private FontCache() { }

    public Font Get(string fontKey)
    {
        if (fonts.TryGetValue(fontKey, out Font? font))
        {
            return font;
        }

        (string fontPath, int fontSize) = ParseFontKey(fontKey);

        // Load the font and store it
        Font newFont = new(fontPath, fontSize);
        fonts.Add(fontKey, newFont);

        return newFont;
    }

    private static (string fontPath, int fontSize) ParseFontKey(string fontKey)
    {
        int colonIndex = fontKey.LastIndexOf(':');

        if (colonIndex == -1)
        {
            throw new ArgumentException($"Invalid font key format: {fontKey}. Expected format: 'FontPath:WindowSize'.");
        }

        string fontPath = fontKey[..colonIndex];
        string sizeString = fontKey[(colonIndex + 1)..];

        if (!int.TryParse(sizeString, out int fontSize))
        {
            throw new ArgumentException($"Invalid font size in: {fontKey}. WindowSize must be a valid integer.");
        }

        return (fontPath, fontSize);
    }
}
</file>

<file path="Source\Resources\Cache\ShaderCache.cs">
/*
namespace Cherris;

public class ShaderCache
{
    public static ShaderCache Instance { get; } = new();

    private readonly Dictionary<string, Shader?> shaders = [];

    private ShaderCache() { }

    public Shader? Get(string key)
    {
        if (shaders.TryGetValue(key, out Shader? shader))
        {
            return shader;
        }

        var newSound = Shad.Load(key);

        if (newSound is null)
        {
            Log.Error($"[SoundCache] Could not load sound: {key}");
        }

        shaders[key] = newSound;
        return newSound;
    }
}
*/
</file>

<file path="Source\Resources\Cache\SoundCache.cs">
namespace Cherris;

public class SoundCache
{
    public static SoundCache? Instance => field ??= new();

    private readonly Dictionary<string, Sound?> soundEffects = [];

    private SoundCache() { }

    public Sound? Get(string soundKey)
    {
        if (soundEffects.TryGetValue(soundKey, out Sound? soundEffect))
        {
            return soundEffect;
        }

        Sound? newSound = Sound.Load(soundKey);

        if (newSound is null)
        {
            Log.Error($"Could not load sound: {soundKey}");
        }

        soundEffects[soundKey] = newSound;
        return newSound;
    }
}
</file>

<file path="Source\Resources\Cache\TextureCache.cs">
namespace Cherris;

public sealed class TextureCache
{
    public static TextureCache? Instance => field ??= new();

    private readonly Dictionary<string, Texture> textures = [];

    private TextureCache() { }

    public Texture Get(string path)
    {
        if (textures.TryGetValue(path, out Texture? value))
        {
            return value;
        }

        Texture textureWrapper = new(path);
        textures[path] = textureWrapper;

        return textureWrapper;
    }

    public void Remove(string path)
    {
        if (textures.TryGetValue(path, out Texture? value))
        {
            //Raylib.UnloadTexture(value);
            textures.Remove(path);

            string pngPath = GetPngPath(path);

            if (pngPath != path && File.Exists(pngPath))
            {
                File.Delete(pngPath);
            }
        }
    }

    private string GetPngPath(string path)
    {
        string pngPath =
            Path.GetExtension(path).ToLower() == ".png" ?
            path :
            $"Res/Temporary/{Path.GetFileNameWithoutExtension(path)}.png";

        return pngPath;
    }
}
</file>

<file path="Source\Nodes\Ui\LineEdit\CharacterSet.cs">
namespace Cherris;

public static class CharacterSet
{
    public static readonly List<char> Numbers = new(new[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' });
    public static readonly List<char> Mathematics = new(new[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-', '*', '/', '(', ')', '.' });
    // Note: original had 'x' and ''. Standard multiply is '*' and divide is '/'. Adjusted for common keyboard input.
}
</file>

<file path="Source\Nodes\Ui\LineEdit\Class1.cs">
namespace Cherris;

public partial class LineEdit
{
    //protected record LineEditState(string Text, int CaretPosition, int TextStartIndex);
}
</file>

<file path="Source\Nodes\Ui\LineEdit\LineEdit.BaseText.cs">
using Vortice.Mathematics;

namespace Cherris;

public partial class LineEdit
{
    private abstract class BaseText : VisualItem
    {
        protected LineEdit parentLineEdit;
        private Vector2 _textOffset = Vector2.Zero; // Local offset within LineEdit

        public BaseText(LineEdit parent)
        {
            parentLineEdit = parent;
            // Ensure these components are not processed by SceneTree independently for drawing
            // unless explicitly added as children and made visible.
            // LineEdit will call their Draw methods.
            Visible = false;
        }

        public Vector2 TextOffset
        {
            get => _textOffset;
            set => _textOffset = value;
        }

        public override void Draw(DrawingContext context)
        {
            if (!parentLineEdit.Visible || ShouldSkipDrawing() || string.IsNullOrEmpty(GetTextToDisplay()))
            {
                return;
            }

            Rect layoutRect = GetLayoutRect();

            parentLineEdit.DrawFormattedText(
                context,
                GetTextToDisplay(),
                layoutRect,
                parentLineEdit.Styles.Current, // Text color and font from ButtonStyle
                HAlignment.Left,    // Text within LineEdit is typically left-aligned
                VAlignment.Center); // And vertically centered
        }

        protected Rect GetLayoutRect()
        {
            // This is the visual top-left of the LineEdit box itself
            Vector2 lineEditVisualTopLeft = parentLineEdit.GlobalPosition - parentLineEdit.Origin;
            Vector2 lineEditSize = parentLineEdit.Size;

            // Text area starts after TextOrigin.X from the *visual left* of LineEdit,
            // and TextOrigin.Y from the *visual top* of LineEdit.
            float textRenderAreaX = lineEditVisualTopLeft.X + parentLineEdit.TextOrigin.X + TextOffset.X;
            // Corrected Y to be relative to the visual top of the LineEdit
            float textRenderAreaY = lineEditVisualTopLeft.Y + parentLineEdit.TextOrigin.Y + TextOffset.Y;

            // Width available for text
            float textRenderAreaWidth = lineEditSize.X - parentLineEdit.TextOrigin.X * 2; // Horizontal padding on both sides
            // Height available for text (full height of LineEdit minus vertical padding)
            // Since TextOrigin.Y is 0 for LineEdit, this is currently lineEditSize.Y
            float textRenderAreaHeight = lineEditSize.Y - parentLineEdit.TextOrigin.Y * 2;

            return new Rect(textRenderAreaX, textRenderAreaY, Math.Max(0, textRenderAreaWidth), Math.Max(0, textRenderAreaHeight));
        }

        protected abstract string GetTextToDisplay();
        protected abstract bool ShouldSkipDrawing();
    }
}
</file>

<file path="Source\Nodes\Ui\LineEdit\LineEdit.Caret.cs">
using System.Globalization; // For CultureInfo if needed for measurements
using Vortice.DirectWrite;
using Vortice.Mathematics;

namespace Cherris;

public partial class LineEdit
{
    protected class Caret : VisualItem
    {
        public float MaxTime { get; set; } = 0.5f;
        private const byte MinAlphaByte = 0;
        private const byte MaxAlphaByte = 255;
        private float _timer = 0;
        private float _alpha = 1.0f; // Use float for Color4 alpha
        private LineEdit _parentLineEdit;

        private float _arrowKeyTimer = 0f;
        private const float ArrowKeyDelay = 0.4f;
        private const float ArrowKeySpeed = 0.04f;
        private bool _movingRight = false; // To track continuous movement direction

        private int _caretDisplayPositionX; // Position relative to the start of visible text
        public int CaretDisplayPositionX
        {
            get => _caretDisplayPositionX;
            set
            {
                var maxVisibleChars = Math.Max(0, Math.Min(_parentLineEdit.GetDisplayableCharactersCount(), _parentLineEdit.Text.Length - _parentLineEdit.TextStartIndex));
                _caretDisplayPositionX = Math.Clamp(value, 0, maxVisibleChars);
                _alpha = 1.0f; // Reset blink
                _timer = 0f;   // Reset blink timer
            }
        }

        public Caret(LineEdit parent)
        {
            _parentLineEdit = parent;
            Visible = false; // Drawn by LineEdit explicitly
        }

        public void UpdateLogic() // Renamed from Update to avoid confusion with Node.Process
        {
            if (!_parentLineEdit.Selected || !_parentLineEdit.Editable) return;

            HandleKeyboardInput();
            HandleMouseInput();
            UpdateAlpha();
        }

        public override void Draw(DrawingContext context)
        {
            if (!_parentLineEdit.Selected || !_parentLineEdit.Editable || !Visible || _alpha <= 0.01f)
            {
                return;
            }

            Rect layoutRect = GetCaretLayoutRect(context);
            if (layoutRect.Width <= 0 || layoutRect.Height <= 0) return;

            ButtonStyle caretStyle = new ButtonStyle
            {
                FontName = _parentLineEdit.Styles.Current.FontName,
                FontSize = _parentLineEdit.Styles.Current.FontSize,
                FontWeight = _parentLineEdit.Styles.Current.FontWeight,
                FontStyle = _parentLineEdit.Styles.Current.FontStyle,
                FontStretch = _parentLineEdit.Styles.Current.FontStretch,
                FontColor = new Color4(_parentLineEdit.Styles.Current.FontColor.R, _parentLineEdit.Styles.Current.FontColor.G, _parentLineEdit.Styles.Current.FontColor.B, _alpha),
                WordWrapping = WordWrapping.NoWrap
            };

            _parentLineEdit.DrawFormattedText(
                context,
                "|",
                layoutRect,
                caretStyle,
                HAlignment.Left,
                VAlignment.Center);
        }

        private void HandleKeyboardInput()
        {
            bool rightPressed = Input.IsKeyPressed(KeyCode.RightArrow);
            bool leftPressed = Input.IsKeyPressed(KeyCode.LeftArrow);

            if (rightPressed || leftPressed)
            {
                _movingRight = rightPressed;
                _arrowKeyTimer = 0f;
                MoveCaret(_movingRight ? 1 : -1);
            }
            else if (Input.IsKeyDown(KeyCode.RightArrow) || Input.IsKeyDown(KeyCode.LeftArrow))
            {
                // Update direction if key state changes during hold
                if (Input.IsKeyDown(KeyCode.RightArrow)) _movingRight = true;
                else if (Input.IsKeyDown(KeyCode.LeftArrow)) _movingRight = false;

                _arrowKeyTimer += Time.Delta;
                if (_arrowKeyTimer >= ArrowKeyDelay)
                {
                    // Check if it's time for a repeat based on ArrowKeySpeed
                    // This is a simplified way to handle repeat interval
                    if ((_arrowKeyTimer - ArrowKeyDelay) % ArrowKeySpeed < Time.Delta) // Ensures one move per interval window
                    {
                        MoveCaret(_movingRight ? 1 : -1);
                    }
                }
            }
            else // No arrow keys down
            {
                _arrowKeyTimer = 0f;
            }
        }

        private void HandleMouseInput()
        {
            if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
            {
                Vector2 localMousePos = _parentLineEdit.GetLocalMousePosition(); // Mouse pos relative to LineEdit's window

                // Check if click is within LineEdit's bounds
                // Using visual top-left for hit testing
                Vector2 lineEditVisualTopLeft = _parentLineEdit.GlobalPosition - _parentLineEdit.Origin;
                Rect lineEditBounds = new Rect(
                    lineEditVisualTopLeft.X, lineEditVisualTopLeft.Y,
                    _parentLineEdit.Size.X, _parentLineEdit.Size.Y);

                if (lineEditBounds.Contains(localMousePos.X, localMousePos.Y))
                {
                    MoveCaretToMousePosition(localMousePos);
                }
            }
        }


        private void MoveCaret(int direction)
        {
            // This moves the logical caret position (_parentLineEdit.CaretLogicalPosition)
            // And then updates display position and start index.

            int newLogicalPos = _parentLineEdit.CaretLogicalPosition + direction;
            _parentLineEdit.CaretLogicalPosition = Math.Clamp(newLogicalPos, 0, _parentLineEdit.Text.Length);
            _parentLineEdit.UpdateCaretDisplayPositionAndStartIndex();
        }

        public void MoveCaretToMousePosition(Vector2 localMousePos) // localMousePos is relative to owning window
        {
            if (_parentLineEdit.Text.Length == 0)
            {
                _parentLineEdit.CaretLogicalPosition = 0;
                _parentLineEdit.UpdateCaretDisplayPositionAndStartIndex();
                return;
            }

            var owningWindow = _parentLineEdit.GetOwningWindow() as Direct2DAppWindow;
            if (owningWindow == null || owningWindow.DWriteFactory == null) return; // Cannot measure text
            IDWriteFactory dwriteFactory = owningWindow.DWriteFactory;

            // Calculate the visual top-left of the LineEdit's actual rendering box
            Vector2 lineEditVisualTopLeft = _parentLineEdit.GlobalPosition - _parentLineEdit.Origin;
            // Calculate the top-left of the text rendering area (inside padding/TextOrigin)
            Vector2 textRenderAreaVisualTopLeft = lineEditVisualTopLeft + _parentLineEdit.TextOrigin;

            // Mouse X relative to the start of the text rendering area within LineEdit
            float mouseXInTextRenderArea = localMousePos.X - textRenderAreaVisualTopLeft.X;


            string visibleText = _parentLineEdit.Text.Substring(
                _parentLineEdit.TextStartIndex,
                Math.Min(_parentLineEdit.GetDisplayableCharactersCount(), _parentLineEdit.Text.Length - _parentLineEdit.TextStartIndex)
            );

            if (string.IsNullOrEmpty(visibleText))
            {
                _parentLineEdit.CaretLogicalPosition = (mouseXInTextRenderArea < 0 && _parentLineEdit.TextStartIndex > 0) ? _parentLineEdit.TextStartIndex : _parentLineEdit.TextStartIndex;
                _parentLineEdit.UpdateCaretDisplayPositionAndStartIndex();
                return;
            }

            IDWriteTextFormat? textFormat = owningWindow.GetOrCreateTextFormat(_parentLineEdit.Styles.Current);
            if (textFormat == null) return;

            using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(
                visibleText,
                textFormat,
                _parentLineEdit.Size.X,
                _parentLineEdit.Size.Y
            );

            textLayout.WordWrapping = WordWrapping.NoWrap;

            textLayout.HitTestPoint(mouseXInTextRenderArea, 0, out var isTrailingHit, out var isInside, out var metrics);

            int newCaretIndexInVisibleText = (int)metrics.TextPosition;
            if (isTrailingHit) newCaretIndexInVisibleText = (int)metrics.TextPosition + (int)metrics.Length;


            _parentLineEdit.CaretLogicalPosition = _parentLineEdit.TextStartIndex + Math.Clamp(newCaretIndexInVisibleText, 0, visibleText.Length);
            _parentLineEdit.UpdateCaretDisplayPositionAndStartIndex();
        }


        private Rect GetCaretLayoutRect(DrawingContext context)
        {
            // Determine the visual top-left of the LineEdit's box
            Vector2 lineEditVisualTopLeft = _parentLineEdit.GlobalPosition - _parentLineEdit.Origin;
            // Determine the visual top-left of the text rendering area (inside TextOrigin padding)
            Vector2 textRenderAreaVisualTopLeft = lineEditVisualTopLeft + _parentLineEdit.TextOrigin;

            float caretXOffset = 0;

            if (CaretDisplayPositionX > 0 && _parentLineEdit.Text.Length > 0)
            {
                // Ensure that the substring length does not exceed available characters from TextStartIndex
                int lengthOfTextBeforeCaretInVisiblePortion = Math.Min(CaretDisplayPositionX, _parentLineEdit.Text.Length - _parentLineEdit.TextStartIndex);

                if (lengthOfTextBeforeCaretInVisiblePortion > 0) // Only measure if there's actual text
                {
                    string textBeforeCaret = _parentLineEdit.Text.Substring(
                        _parentLineEdit.TextStartIndex,
                        lengthOfTextBeforeCaretInVisiblePortion
                    );

                    if (!string.IsNullOrEmpty(textBeforeCaret)) // Double check, though lengthOfTextBeforeCaretInVisiblePortion > 0 should mean it's not empty
                    {
                        var dwriteFactory = context.DWriteFactory;
                        var owningWindow = context.OwnerWindow;
                        IDWriteTextFormat? textFormat = owningWindow?.GetOrCreateTextFormat(_parentLineEdit.Styles.Current);

                        if (textFormat != null)
                        {
                            textFormat.WordWrapping = WordWrapping.NoWrap;
                            using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(
                                textBeforeCaret,
                                textFormat,
                                float.MaxValue,
                                _parentLineEdit.Size.Y);
                            caretXOffset = textLayout.Metrics.WidthIncludingTrailingWhitespace; // Use WidthIncludingTrailingWhitespace
                        }
                    }
                }
            }

            float caretWidth = _parentLineEdit.MeasureSingleCharWidth(context, "|", _parentLineEdit.Styles.Current);
            if (caretWidth <= 0) caretWidth = 2;

            float caretRectX = textRenderAreaVisualTopLeft.X + caretXOffset - caretWidth / 2f;
            float caretRectY = textRenderAreaVisualTopLeft.Y;
            // Caret height should be consistent with the text layout height
            float caretRectHeight = _parentLineEdit.Size.Y - _parentLineEdit.TextOrigin.Y * 2;


            return new Rect(
                caretRectX,
                caretRectY,
                caretWidth,
                Math.Max(0, caretRectHeight)
            );
        }


        private void UpdateAlpha()
        {
            _timer += Time.Delta;
            if (_timer > MaxTime)
            {
                _alpha = (_alpha == 1.0f) ? 0.0f : 1.0f;
                _timer = 0;
            }
        }
    }
}
</file>

<file path="Source\Nodes\Ui\LineEdit\LineEdit.cs">
using System.Globalization;
using SharpGen.Runtime;
using Vortice.DirectWrite;

namespace Cherris;

public partial class LineEdit : Button
{
    public static readonly Vector2 DefaultLineEditSize = new(200, 28);

    public new string Text
    {
        get;
        set
        {
            if (field == value) return;

            string oldText = field;
            field = value ?? "";

            if (field.Length > MaxCharacters)
            {
                field = field.Substring(0, MaxCharacters);
            }

            UpdateCaretDisplayPositionAndStartIndex();
            TextChanged?.Invoke(this, field);

            if (oldText.Length == 0 && field.Length > 0)
            {
                FirstCharacterEntered?.Invoke(this, EventArgs.Empty);
            }

            if (oldText.Length > 0 && field.Length == 0)
            {
                Cleared?.Invoke(this, EventArgs.Empty);
            }
        }
    } = "";

    public string PlaceholderText { get; set; } = "";
    public Vector2 TextOrigin { get; set; } = new(6, 0);
    public int MaxCharacters { get; set; } = int.MaxValue;
    public List<char> ValidCharacters { get; set; } = [];

    public bool Selected
    {
        get;
        set
        {
            if (field == value)
            {
                return;
            }

            field = value;
            _caret.Visible = field && Editable;
            
            if (!field)
            {
                _caret.CaretDisplayPositionX = 0;
            }
        }
    } = false;

    public bool Editable { get; set; } = true;
    public bool ExpandWidthToText { get; set; } = false;
    public bool Secret { get; set; } = false;
    public char SecretCharacter { get; set; } = '*';
    public bool AutoScrollToShowFullText { get; set; } = true;

    public int TextStartIndex { get; internal set; } = 0;

    internal int CaretLogicalPosition { get; set; } = 0;

    public event EventHandler? FirstCharacterEntered;
    public event EventHandler? Cleared;
    public event EventHandler<string>? TextChanged;
    public event EventHandler<string>? Confirmed;

    private readonly Caret _caret;
    private readonly TextDisplayer _textDisplayer;
    private readonly PlaceholderTextDisplayer _placeholderTextDisplayer;

    private const float BackspaceDelay = 0.5f;
    private const float BackspaceSpeed = 0.05f;
    private const float UndoDelay = 0.5f;
    private const float UndoSpeed = 0.05f;

    private float _backspaceTimer = 0f;
    private bool _backspaceHeld = false;
    private float _undoTimer = 0f;
    private bool _undoHeld = false;
    private bool _backspaceCtrlHeld = false;

    private readonly Stack<LineEditState> _undoStack = new();
    private readonly Stack<LineEditState> _redoStack = new();
    private const int HistoryLimit = 50;

    private char? _pendingCharInput = null;

    public LineEdit()
    {
        _caret = new Caret(this);
        _textDisplayer = new TextDisplayer(this);
        _placeholderTextDisplayer = new PlaceholderTextDisplayer(this);

        Visible = true;
        Size = DefaultLineEditSize;
        TextHAlignment = HAlignment.Left;
        TextVAlignment = VAlignment.Center;

        Text = "Type here...";

        Styles.Normal.BorderLength = 1;
        Styles.Focused.BorderLength = 1;
        Styles.Focused.BorderColor = DefaultTheme.FocusBorder;
        Styles.WordWrapping = WordWrapping.NoWrap; // Ensure NoWrap for LineEdit text handling

        FocusChanged += OnFocusChangedHandler;
        LeftClicked += OnLeftClickedHandler;
        ClickedOutside += OnClickedOutsideHandler;
        LayerChanged += OnLayerChangedHandler;
        SizeChanged += OnSizeChangedHandler;
    }

    public override void Process()
    {
        base.Process();
        CaptureCharInput();

        if (Editable && Selected)
        {
            HandleCharacterInput();
            HandleBackspace();
            HandleDelete();
            HandleHomeEndKeys();
            HandleClipboardPaste();
            HandleUndoRedo();
            ConfirmOnEnter();
        }
        _caret.UpdateLogic();
        UpdateSizeToFitTextIfEnabled();
    }

    public override void Draw(DrawingContext context)
    {
        base.Draw(context);
        _placeholderTextDisplayer.Draw(context);
        _textDisplayer.Draw(context);

        if (Selected && Editable)
        {
            _caret.Visible = true;
            _caret.Draw(context);
        }
        else
        {
            _caret.Visible = false;
        }
    }

    private void CaptureCharInput()
    {
        if (_pendingCharInput == null)
        {
            _pendingCharInput = Input.ConsumeNextTypedChar();
        }
    }

    protected override void OnEnterPressed()
    {
        if (Editable)
        {
            ConfirmAction();
        }
    }

    private void OnFocusChangedHandler(Control control)
    {
        Selected = control.Focused;
    }

    private void OnLeftClickedHandler()
    {
        if (Editable)
        {
            Selected = true;
        }
    }

    private void OnClickedOutsideHandler(Control control)
    {
        if (Selected)
        {
            Selected = false;
        }
    }

    private void OnLayerChangedHandler(VisualItem sender, int layer)
    {
    }

    private void OnSizeChangedHandler(object? sender, Vector2 newSize)
    {
        TextStartIndex = 0;
        UpdateCaretDisplayPositionAndStartIndex();
    }

    private void UpdateSizeToFitTextIfEnabled()
    {
        if (!ExpandWidthToText || !Visible) return;

        var owningWindow = GetOwningWindow() as Direct2DAppWindow;
        if (owningWindow == null || owningWindow.DWriteFactory == null) return;
        IDWriteFactory dwriteFactory = owningWindow.DWriteFactory;

        string textToMeasure = string.IsNullOrEmpty(Text) ? PlaceholderText : Text;
        if (string.IsNullOrEmpty(textToMeasure))
        {
            Size = new Vector2(TextOrigin.X * 2 + 20, Size.Y);
            return;
        }

        float measuredWidth = MeasureTextWidth(dwriteFactory, textToMeasure, Styles.Current);
        Size = new Vector2(measuredWidth + TextOrigin.X * 2, Size.Y);
    }

    internal float MeasureTextWidth(IDWriteFactory dwriteFactory, string text, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(text)) return 0f;

        using IDWriteTextFormat textFormat = dwriteFactory.CreateTextFormat(
            style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, CultureInfo.CurrentCulture.Name);
        textFormat.WordWrapping = WordWrapping.NoWrap;

        using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(text, textFormat, float.MaxValue, float.MaxValue);
        return textLayout.Metrics.WidthIncludingTrailingWhitespace;
    }

    internal float MeasureSingleCharWidth(DrawingContext context, string character, ButtonStyle style)
    {
        if (string.IsNullOrEmpty(character)) return 0f;
        IDWriteFactory dwriteFactory = context.DWriteFactory;
        if (dwriteFactory == null) return 0f;

        using IDWriteTextFormat textFormat = dwriteFactory.CreateTextFormat(
            style.FontName, null, style.FontWeight, style.FontStyle, style.FontStretch, style.FontSize, CultureInfo.CurrentCulture.Name);
        textFormat.WordWrapping = WordWrapping.NoWrap;

        using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(character, textFormat, float.MaxValue, float.MaxValue);
        return textLayout.Metrics.Width;
    }

    public void Insert(string textToInsert)
    {
        if (!Editable || string.IsNullOrEmpty(textToInsert)) return;

        PushStateForUndo();
        foreach (char c in textToInsert)
        {
            InsertCharacterLogic(c);
        }
    }

    private void HandleCharacterInput()
    {
        if (!_pendingCharInput.HasValue)
        {
            return;
        }

        char typedChar = _pendingCharInput.Value;
        _pendingCharInput = null;

        if (Text.Length >= MaxCharacters)
        {
            return;
        }

        if (ValidCharacters.Count != 0 && !ValidCharacters.Contains(typedChar))
        {
            return;
        }

        PushStateForUndo();
        InsertCharacterLogic(typedChar);
    }

    private void InsertCharacterLogic(char c)
    {
        if (Text.Length >= MaxCharacters) return;

        Text = Text.Insert(CaretLogicalPosition, c.ToString());
        CaretLogicalPosition++;
        UpdateCaretDisplayPositionAndStartIndex();
    }

    private void HandleBackspace()
    {
        bool ctrlHeld = Input.IsKeyDown(KeyCode.LeftControl) || Input.IsKeyDown(KeyCode.RightControl);

        if (Input.IsKeyPressed(KeyCode.Backspace))
        {
            _backspaceHeld = true;
            _backspaceTimer = 0f;
            _backspaceCtrlHeld = ctrlHeld;
            PerformBackspaceAction(_backspaceCtrlHeld);
        }
        else if (Input.IsKeyDown(KeyCode.Backspace) && _backspaceHeld)
        {
            _backspaceTimer += Time.Delta;
            if (_backspaceTimer >= BackspaceDelay)
            {
                if ((_backspaceTimer - BackspaceDelay) % BackspaceSpeed < Time.Delta)
                {
                    PerformBackspaceAction(_backspaceCtrlHeld);
                }
            }
        }
        else if (Input.IsKeyReleased(KeyCode.Backspace))
        {
            _backspaceHeld = false;
            _backspaceTimer = 0f;
        }
    }

    private void PerformBackspaceAction(bool isCtrlHeld)
    {
        if (Text.Length == 0 || CaretLogicalPosition == 0) return;

        PushStateForUndo();
        if (isCtrlHeld)
        {
            int originalCaretPos = CaretLogicalPosition;
            int wordStart = FindPreviousWordStart(Text, originalCaretPos);
            Text = Text.Remove(wordStart, originalCaretPos - wordStart);
            CaretLogicalPosition = wordStart;
        }
        else
        {
            Text = Text.Remove(CaretLogicalPosition - 1, 1);
            CaretLogicalPosition--;
        }
        UpdateCaretDisplayPositionAndStartIndex();
    }

    private int FindPreviousWordStart(string text, int currentPos)
    {
        if (currentPos == 0) return 0;
        int pos = currentPos - 1;
        while (pos > 0 && char.IsWhiteSpace(text[pos])) pos--;
        while (pos > 0 && !char.IsWhiteSpace(text[pos - 1])) pos--;
        return pos;
    }

    private void HandleDelete()
    {
        if (Input.IsKeyPressed(KeyCode.Delete))
        {
            if (CaretLogicalPosition < Text.Length)
            {
                PushStateForUndo();
                Text = Text.Remove(CaretLogicalPosition, 1);
                UpdateCaretDisplayPositionAndStartIndex();
            }
        }
    }

    private void HandleHomeEndKeys()
    {
        if (Input.IsKeyPressed(KeyCode.Home))
        {
            CaretLogicalPosition = 0;
            UpdateCaretDisplayPositionAndStartIndex();
        }
        else if (Input.IsKeyPressed(KeyCode.End))
        {
            CaretLogicalPosition = Text.Length;
            UpdateCaretDisplayPositionAndStartIndex();
        }
    }

    private void HandleClipboardPaste()
    {
        if ((Input.IsKeyDown(KeyCode.LeftControl) || Input.IsKeyDown(KeyCode.RightControl)) && Input.IsKeyPressed(KeyCode.V))
        {
            try
            {
                string clipboardText = "";
                Log.Warning("Clipboard.GetText() is currently disabled. Project setup required for System.Windows.Forms.");

                if (!string.IsNullOrEmpty(clipboardText))
                {
                    clipboardText = clipboardText.Replace("\r\n", " ").Replace("\n", " ").Replace("\r", " ");
                    Insert(clipboardText);
                }
            }
            catch (Exception ex)
            {
                Log.Error($"Error pasting from clipboard: {ex.Message}");
            }
        }
    }

    private void HandleUndoRedo()
    {
        bool ctrlHeld = Input.IsKeyDown(KeyCode.LeftControl) || Input.IsKeyDown(KeyCode.RightControl);

        if (ctrlHeld && Input.IsKeyPressed(KeyCode.Z))
        {
            _undoHeld = true;
            _undoTimer = 0f;
            Undo();
        }
        else if (ctrlHeld && Input.IsKeyDown(KeyCode.Z) && _undoHeld)
        {
            _undoTimer += Time.Delta;
            if (_undoTimer >= UndoDelay)
            {
                if ((_undoTimer - UndoDelay) % UndoSpeed < Time.Delta)
                {
                    Undo();
                }
            }
        }
        else if (Input.IsKeyReleased(KeyCode.Z))
        {
            _undoHeld = false;
            _undoTimer = 0f;
        }

        if (ctrlHeld && Input.IsKeyPressed(KeyCode.Y))
        {
            Redo();
        }
    }

    private void ConfirmOnEnter()
    {
        if (Input.IsKeyPressed(KeyCode.Enter))
        {
            ConfirmAction();
        }
    }

    private void ConfirmAction()
    {
        Selected = false;
        Confirmed?.Invoke(this, Text);
    }

    internal IDWriteFactory? GetDWriteFactory()
    {
        var owningWindow = GetOwningWindow() as Direct2DAppWindow;
        return owningWindow?.DWriteFactory;
    }

    internal int GetDisplayableCharactersCount()
    {
        if (Size.X <= TextOrigin.X * 2) return 0;

        float availableWidth = Size.X - TextOrigin.X * 2;
        if (availableWidth <= 0) return 0;

        IDWriteFactory? dwriteFactory = GetDWriteFactory();
        if (dwriteFactory == null)
        {
            Log.Warning("LineEdit.GetDisplayableCharactersCount: DWriteFactory not available. Falling back to rough estimate.");
            return (int)(availableWidth / 8);
        }

        if (TextStartIndex >= Text.Length && Text.Length > 0)
        {
            return 0;
        }
        if (Text.Length == 0) return 0;

        string textToMeasure = Text.Substring(TextStartIndex);
        if (string.IsNullOrEmpty(textToMeasure)) return 0;

        IDWriteTextFormat? textFormat = (GetOwningWindow() as Direct2DAppWindow)?.GetOrCreateTextFormat(Styles.Current);
        if (textFormat == null)
        {
            Log.Warning("LineEdit.GetDisplayableCharactersCount: Could not get TextFormat. Falling back to rough estimate.");
            return (int)(availableWidth / 8);
        }
        textFormat.WordWrapping = WordWrapping.NoWrap;

        using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(
            textToMeasure,
            textFormat,
            float.MaxValue,
            Size.Y
        );

        ClusterMetrics[] clusterMetricsBuffer = new ClusterMetrics[textToMeasure.Length];
        Result result = textLayout.GetClusterMetrics(clusterMetricsBuffer, out uint actualClusterCount);

        if (result.Failure)
        {
            Log.Error($"LineEdit.GetDisplayableCharactersCount: GetClusterMetrics failed with HRESULT {result.Code}");
            return (int)(availableWidth / 8);
        }

        if (actualClusterCount == 0) return 0;

        float currentCumulativeWidth = 0;
        int displayableCharacterLengthInSubstring = 0;

        for (int i = 0; i < actualClusterCount; i++)
        {
            ClusterMetrics cluster = clusterMetricsBuffer[i];
            if (currentCumulativeWidth + cluster.Width <= availableWidth)
            {
                currentCumulativeWidth += cluster.Width;
                displayableCharacterLengthInSubstring += (int)cluster.Length;
            }
            else
            {
                break;
            }
        }
        return displayableCharacterLengthInSubstring;
    }

    internal void UpdateCaretDisplayPositionAndStartIndex()
    {
        if (Text.Length == 0)
        {
            TextStartIndex = 0;
            _caret.CaretDisplayPositionX = 0;
            CaretLogicalPosition = 0;
            return;
        }

        float availableWidth = Size.X - TextOrigin.X * 2;
        if (availableWidth <= 0)
        {
            TextStartIndex = 0;
            _caret.CaretDisplayPositionX = 0;
            return;
        }

        if (AutoScrollToShowFullText)
        {
            IDWriteFactory? dwriteFactory = GetDWriteFactory();
            if (dwriteFactory != null)
            {
                float fullTextWidth = MeasureTextWidth(dwriteFactory, Text, Styles.Current);
                if (fullTextWidth <= availableWidth)
                {
                    TextStartIndex = 0;
                    _caret.CaretDisplayPositionX = CaretLogicalPosition;
                    return;
                }
            }
        }

        int displayableChars = GetDisplayableCharactersCount();
        if (displayableChars <= 0 && Text.Length > 0)
        {
            TextStartIndex = CaretLogicalPosition;
            _caret.CaretDisplayPositionX = 0;
            TextStartIndex = Math.Clamp(TextStartIndex, 0, Text.Length);
            return;
        }

        if (AutoScrollToShowFullText)
        {
            int maxVisibleChars = GetDisplayableCharactersCount(0);
            if (maxVisibleChars > displayableChars && TextStartIndex > 0)
            {
                int charactersToShow = maxVisibleChars - displayableChars;
                TextStartIndex = Math.Max(0, TextStartIndex - charactersToShow);
                displayableChars = GetDisplayableCharactersCount();
            }
        }

        if (CaretLogicalPosition < TextStartIndex)
        {
            TextStartIndex = CaretLogicalPosition;
        }
        else if (CaretLogicalPosition >= TextStartIndex + displayableChars)
        {
            TextStartIndex = CaretLogicalPosition - displayableChars + 1;
        }

        TextStartIndex = Math.Max(0, TextStartIndex);
        if (TextStartIndex + displayableChars > Text.Length && displayableChars > 0)
        {
            TextStartIndex = Math.Max(0, Text.Length - displayableChars);
        }
        TextStartIndex = Math.Clamp(TextStartIndex, 0, Math.Max(0, Text.Length - 1));

        _caret.CaretDisplayPositionX = CaretLogicalPosition - TextStartIndex;
        _caret.CaretDisplayPositionX = Math.Clamp(_caret.CaretDisplayPositionX, 0, displayableChars > 0 ? displayableChars : 0);
    }

    private int GetDisplayableCharactersCount(int startIndex)
    {
        if (Size.X <= TextOrigin.X * 2) return 0;

        float availableWidth = Size.X - TextOrigin.X * 2;
        if (availableWidth <= 0) return 0;

        IDWriteFactory? dwriteFactory = GetDWriteFactory();
        if (dwriteFactory == null)
        {
            Log.Warning("LineEdit.GetDisplayableCharactersCount: DWriteFactory not available. Falling back to rough estimate.");
            return (int)(availableWidth / 8);
        }

        if (startIndex >= Text.Length && Text.Length > 0) return 0;
        if (Text.Length == 0) return 0;

        string textToMeasure = Text.Substring(startIndex);
        if (string.IsNullOrEmpty(textToMeasure)) return 0;

        IDWriteTextFormat? textFormat = (GetOwningWindow() as Direct2DAppWindow)?.GetOrCreateTextFormat(Styles.Current);
        if (textFormat == null)
        {
            Log.Warning("LineEdit.GetDisplayableCharactersCount: Could not get TextFormat. Falling back to rough estimate.");
            return (int)(availableWidth / 8);
        }
        textFormat.WordWrapping = WordWrapping.NoWrap;

        using IDWriteTextLayout textLayout = dwriteFactory.CreateTextLayout(
            textToMeasure,
            textFormat,
            float.MaxValue,
            Size.Y
        );

        ClusterMetrics[] clusterMetricsBuffer = new ClusterMetrics[textToMeasure.Length];
        Result result = textLayout.GetClusterMetrics(clusterMetricsBuffer, out uint actualClusterCount);

        if (result.Failure)
        {
            Log.Error($"LineEdit.GetDisplayableCharactersCount: GetClusterMetrics failed with HRESULT {result.Code}");
            return (int)(availableWidth / 8);
        }

        if (actualClusterCount == 0) return 0;

        float currentCumulativeWidth = 0;
        int displayableCharacterLengthInSubstring = 0;

        for (int i = 0; i < actualClusterCount; i++)
        {
            ClusterMetrics cluster = clusterMetricsBuffer[i];
            if (currentCumulativeWidth + cluster.Width <= availableWidth)
            {
                currentCumulativeWidth += cluster.Width;
                displayableCharacterLengthInSubstring += (int)cluster.Length;
            }
            else
            {
                break;
            }
        }
        return displayableCharacterLengthInSubstring;
    }

    private void PushStateForUndo()
    {
        if (_undoStack.Count > 0 && _undoStack.Peek().Text == _text && _undoStack.Peek().CaretPosition == CaretLogicalPosition)
        {
            return;
        }
        if (_undoStack.Count >= HistoryLimit)
        {
            var tempList = _undoStack.ToList();
            tempList.RemoveAt(0);
            _undoStack.Clear();
            foreach (var state in tempList.AsEnumerable().Reverse())
            {
                _undoStack.Push(state);
            }
        }
        _undoStack.Push(new LineEditState(_text, CaretLogicalPosition, TextStartIndex));
        _redoStack.Clear();
    }

    public void Undo()
    {
        if (_undoStack.Count > 0)
        {
            LineEditState currentState = new LineEditState(_text, CaretLogicalPosition, TextStartIndex);
            _redoStack.Push(currentState);
            if (_redoStack.Count > HistoryLimit)
            {
                var tempList = _redoStack.ToList();
                tempList.RemoveAt(0);
                _redoStack.Clear();
                foreach (var state in tempList.AsEnumerable().Reverse())
                {
                    _redoStack.Push(state);
                }
            }

            LineEditState previousState = _undoStack.Pop();
            _text = previousState.Text;
            CaretLogicalPosition = previousState.CaretPosition;
            TextStartIndex = previousState.TextStartIndex;

            TextChanged?.Invoke(this, _text);
            UpdateCaretDisplayPositionAndStartIndex();
        }
    }

    public void Redo()
    {
        if (_redoStack.Count > 0)
        {
            LineEditState currentState = new LineEditState(_text, CaretLogicalPosition, TextStartIndex);
            _undoStack.Push(currentState);
            if (_undoStack.Count > HistoryLimit)
            {
                var tempList = _undoStack.ToList();
                tempList.RemoveAt(0);
                _undoStack.Clear();
                foreach (var state in tempList.AsEnumerable().Reverse())
                {
                    _undoStack.Push(state);
                }
            }

            LineEditState nextState = _redoStack.Pop();
            _text = nextState.Text;
            CaretLogicalPosition = nextState.CaretPosition;
            TextStartIndex = nextState.TextStartIndex;

            TextChanged?.Invoke(this, _text);
            UpdateCaretDisplayPositionAndStartIndex();
        }
    }

    protected record LineEditState(string Text, int CaretPosition, int TextStartIndex);

    protected Vector2 GetLocalMousePosition()
    {
        var owningWindowNode = GetOwningWindowNode();
        if (owningWindowNode != null)
        {
            return owningWindowNode.LocalMousePosition;
        }

        var mainAppWindow = ApplicationServer.Instance.GetMainAppWindow();
        if (mainAppWindow != null)
        {
            return mainAppWindow.GetLocalMousePosition();
        }

        Log.Warning($"LineEdit '{Name}': Could not determine owning window for local mouse position. Using global Input.MousePosition.");
        return Input.MousePosition;
    }
}
</file>

<file path="Source\Nodes\Ui\LineEdit\LineEdit.PlaceholderTextDisplayer.cs">
namespace Cherris;

public partial class LineEdit
{
    private class PlaceholderTextDisplayer : BaseText
    {
        public PlaceholderTextDisplayer(LineEdit parent) : base(parent)
        {
        }

        protected override string GetTextToDisplay()
        {
            return parentLineEdit.PlaceholderText;
        }

        protected override bool ShouldSkipDrawing()
        {
            // Don't draw placeholder if there's actual text
            return !string.IsNullOrEmpty(parentLineEdit.Text);
        }
    }
}
</file>

<file path="Source\Nodes\Ui\LineEdit\LineEdit.TextDisplayer.cs">
namespace Cherris;

public partial class LineEdit
{
    private class TextDisplayer : BaseText
    {
        public TextDisplayer(LineEdit parent) : base(parent)
        {
        }

        protected override string GetTextToDisplay()
        {
            if (string.IsNullOrEmpty(parentLineEdit.Text))
            {
                return "";
            }

            string textToDisplay = parentLineEdit.Text;

            if (parentLineEdit.Secret)
            {
                textToDisplay = new string(parentLineEdit.SecretCharacter, textToDisplay.Length);
            }

            // Ensure TextStartIndex is valid
            int startIndex = Math.Clamp(parentLineEdit.TextStartIndex, 0, textToDisplay.Length);

            // Calculate how many characters can actually be taken from startIndex
            int availableLengthFromStartIndex = textToDisplay.Length - startIndex;

            // Determine the number of characters to display (min of displayable count and available from start index)
            int count = Math.Min(parentLineEdit.GetDisplayableCharactersCount(), availableLengthFromStartIndex);

            if (count <= 0) return ""; // Nothing to display from this start index or no space

            return textToDisplay.Substring(startIndex, count);
        }

        protected override bool ShouldSkipDrawing()
        {
            // If placeholder is showing, actual text displayer should skip.
            // Placeholder skips if text has length. Actual text should draw if it has length.
            // This seems redundant with GetTextToDisplay returning "" if no text.
            return string.IsNullOrEmpty(parentLineEdit.Text);
        }
    }
}
</file>

<file path="Source\Nodes\Ui\Slider\HSlider.cs">
using Vortice.Mathematics; // For Rect

namespace Cherris;

public class HSlider : Slider
{
    public HSliderDirection Direction { get; set; } = HSliderDirection.LeftToRight;

    protected override void CalculateTrackBounds()
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        this.trackPosition = sliderVisualTopLeft; // Store the visual top-left
        trackMin = sliderVisualTopLeft.X;         // Min X for mouse interaction range, relative to window
        trackMax = sliderVisualTopLeft.X + Size.X;// Max X for mouse interaction range, relative to window
    }

    protected override void UpdateHoverStates()
    {
        Vector2 mousePos = GetLocalMousePosition(); // window-local mouse coordinates
        Vector2 visualSliderTopLeft = this.trackPosition; // This is (GlobalPosition - Origin)

        // Track hover: check if mousePos is within the visual bounds of the slider track
        trackHovered = mousePos.X >= visualSliderTopLeft.X &&
                       mousePos.X <= visualSliderTopLeft.X + Size.X &&
                       mousePos.Y >= visualSliderTopLeft.Y &&
                       mousePos.Y <= visualSliderTopLeft.Y + Size.Y;

        // Grabber hover: CalculateGrabberPosition returns global coords of grabber's top-left
        Vector2 grabberTopLeftPos = CalculateGrabberPosition();
        grabberHovered = mousePos.X >= grabberTopLeftPos.X &&
                         mousePos.X <= grabberTopLeftPos.X + GrabberSize.X &&
                         mousePos.Y >= grabberTopLeftPos.Y &&
                         mousePos.Y <= grabberTopLeftPos.Y + GrabberSize.Y;
    }

    protected override void HandleInput()
    {
        HandleMousePress();
        HandleMouseDrag();
        HandleMouseWheel();
    }

    private void HandleMousePress()
    {
        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            if (trackHovered) // trackHovered uses window-local mouse and this.trackPosition
            {
                float localMouseX = GetLocalMousePosition().X; // Window-local mouse X
                // Value calculation should be based on mouse position relative to the track's visual extent
                // this.trackPosition.X is the visual left edge of the track in window coordinates
                float clampedMouseXOnTrack = Math.Clamp(localMouseX, this.trackPosition.X, this.trackPosition.X + Size.X);
                Value = ConvertPositionToValue(clampedMouseXOnTrack);
                grabberPressed = true;
                PlaySound();
            }
        }
        else if (Input.IsMouseButtonReleased(MouseButtonCode.Left))
        {
            grabberPressed = false;
        }
    }

    private void HandleMouseDrag()
    {
        if (!grabberPressed) return;

        if (Input.IsMouseButtonReleased(MouseButtonCode.Left))
        {
            grabberPressed = false;
            return;
        }

        float localMouseX = GetLocalMousePosition().X;
        float clampedMouseXOnTrack = Math.Clamp(localMouseX, this.trackPosition.X, this.trackPosition.X + Size.X);
        Value = ConvertPositionToValue(clampedMouseXOnTrack);
    }

    private void HandleMouseWheel()
    {
        if (!trackHovered && !grabberHovered) return;

        float wheelDelta = Input.GetMouseWheelMovement();
        if (wheelDelta == 0) return;

        Value = ApplyStep(Value + (wheelDelta * Step * (Direction == HSliderDirection.LeftToRight ? 1 : -1)));
        PlaySound();
    }

    protected override float ConvertPositionToValue(float positionOnTrackInWindowSpace)
    {
        float visualTrackLeftEdge = this.trackPosition.X; // This is (GlobalPosition - Origin).X
        float effectiveTrackWidth = Size.X;

        if (effectiveTrackWidth <= 0) return MinValue;

        float normalized = (positionOnTrackInWindowSpace - visualTrackLeftEdge) / effectiveTrackWidth;
        normalized = Math.Clamp(normalized, 0f, 1f);

        if (Direction == HSliderDirection.RightToLeft)
        {
            normalized = 1f - normalized;
        }

        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return ApplyStep(rawValue);
    }

    protected override void DrawForeground(DrawingContext context)
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        float range = MaxValue - MinValue;
        float fillRatio = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        fillRatio = Math.Clamp(fillRatio, 0f, 1f);

        float foregroundWidth = Size.X * fillRatio;
        Rect foregroundRect;

        if (Direction == HSliderDirection.RightToLeft)
        {
            foregroundRect = new Rect(
                sliderVisualTopLeft.X + Size.X - foregroundWidth,
                sliderVisualTopLeft.Y,
                foregroundWidth,
                Size.Y
            );
        }
        else // LeftToRight
        {
            foregroundRect = new Rect(
                sliderVisualTopLeft.X,
                sliderVisualTopLeft.Y,
                foregroundWidth,
                Size.Y
            );
        }

        if (foregroundRect.Width > 0 && foregroundRect.Height > 0)
        {
            DrawStyledRectangle(context, foregroundRect, Style.Foreground);
        }
    }

    protected override Vector2 CalculateGrabberPosition()
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        float range = MaxValue - MinValue;
        float normalizedValue = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        normalizedValue = Math.Clamp(normalizedValue, 0f, 1f);

        if (Direction == HSliderDirection.RightToLeft)
        {
            normalizedValue = 1f - normalizedValue;
        }

        // Calculate grabber's center X relative to the slider's visual left edge
        float grabberCenterX_relativeToSliderLeft = normalizedValue * Size.X;
        // Calculate grabber's top-left X relative to the slider's visual left edge
        float grabberLeftX_relativeToSliderLeft = grabberCenterX_relativeToSliderLeft - GrabberSize.X / 2f;
        // Clamp this relative position so grabber stays within slider's bounds
        grabberLeftX_relativeToSliderLeft = Math.Clamp(grabberLeftX_relativeToSliderLeft, 0, Size.X - GrabberSize.X);

        // Convert to global coordinates
        float finalGrabberLeftX_global = sliderVisualTopLeft.X + grabberLeftX_relativeToSliderLeft;

        // Calculate grabber's top Y relative to slider's visual top edge (centered vertically)
        float grabberTopY_relativeToSliderTop = (Size.Y / 2f) - GrabberSize.Y / 2f;
        // Convert to global coordinates
        float finalGrabberTopY_global = sliderVisualTopLeft.Y + grabberTopY_relativeToSliderTop;

        return new Vector2(finalGrabberLeftX_global, finalGrabberTopY_global);
    }

    protected override void UpdateGrabberThemeVisuals()
    {
        if (Disabled)
        {
            Style.Grabber.Current = Style.Grabber.Disabled;
            return;
        }

        if (grabberPressed)
        {
            Style.Grabber.Current = Style.Grabber.Pressed;
        }
        else if (Focused)
        {
            Style.Grabber.Current = grabberHovered ? Style.Grabber.Hover : Style.Grabber.Focused;
        }
        else if (grabberHovered)
        {
            Style.Grabber.Current = Style.Grabber.Hover;
        }
        else
        {
            Style.Grabber.Current = Style.Grabber.Normal;
        }
    }

    protected override void HandleKeyboardNavigation()
    {
        if (Input.IsActionPressed("UiLeft"))
        {
            Value = ApplyStep(Value - Step * (Direction == HSliderDirection.LeftToRight ? 1 : -1));
            PlaySound();
        }
        else if (Input.IsActionPressed("UiRight"))
        {
            Value = ApplyStep(Value + Step * (Direction == HSliderDirection.LeftToRight ? 1 : -1));
            PlaySound();
        }
    }
}
</file>

<file path="Source\Nodes\Ui\Slider\HSliderDirection.cs">
namespace Cherris;

public enum HSliderDirection
{
    LeftToRight,
    RightToLeft
}
</file>

<file path="Source\Nodes\Ui\Slider\Slider.cs">
using Vortice.Mathematics; // For Rect

namespace Cherris;

public abstract class Slider : Control
{
    // Add this property
    public bool SuppressValueChangedEvent { get; set; } = false;

    private float _value = 0.5f;
    public float Value
    {
        get => _value;
        set
        {
            float newValue = ApplyStep(value); // ApplyStep also clamps

            if (_value == newValue)
            {
                return;
            }

            _value = newValue;

            if (SuppressValueChangedEvent) // Check the flag
            {
                return;
            }

            ValueChanged?.Invoke(_value); // Invoke the event
        }
    }

    public float MinValue { get; set; } = 0f;
    public float MaxValue { get; set; } = 1f;
    public Sound? MoveSound { get; set; }
    public SliderStyle Style { get; set; } = new();
    public Vector2 GrabberSize { get; set; } = new(12, 24);

    protected bool grabberPressed;
    protected bool grabberHovered;
    protected bool trackHovered;
    protected Vector2 trackPosition; // Used for input logic bounds, updated in Process()
                                     // This will store the visual top-left of the slider in window coordinates.
    protected float trackMin;        // Min bound for interaction (X for HSlider, Y for VSlider) in window coordinates.
    protected float trackMax;        // Max bound for interaction (X for HSlider, Y for VSlider) in window coordinates.

    private float _step = 0.01f;
    public float Step
    {
        get => _step;
        set => _step = Math.Max(value, 0f);
    }

    public event Action<float>? ValueChanged; // Added event

    public Slider()
    {
        Size = new(200, 16);
        Focusable = true;
        Navigable = true;

        Style.Foreground.FillColor = DefaultTheme.Accent;
        Style.Foreground.Roundness = 0.2f;
        Style.Background.Roundness = 0.2f;
        Style.Grabber.Roundness = 0.5f;
        Style.Grabber.BorderLength = 1f;
        Style.Grabber.Normal.FillColor = DefaultTheme.NormalFill;
        Style.Grabber.Hover.FillColor = DefaultTheme.HoverFill;
        Style.Grabber.Pressed.FillColor = DefaultTheme.Accent;
        Style.Grabber.Focused.BorderColor = DefaultTheme.FocusBorder;
    }

    public override void Process()
    {
        base.Process();

        if (Disabled)
        {
            grabberPressed = false;
            UpdateGrabberThemeVisuals();
            return;
        }

        CalculateTrackBounds();
        UpdateHoverStates();

        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            HandleClickFocus();
        }

        HandleInput();

        if (Focused)
        {
            HandleKeyboardNavigation();
            OnFocusLost();
        }

        UpdateGrabberThemeVisuals();
    }

    protected Vector2 GetLocalMousePosition()
    {
        var owningWindowNode = GetOwningWindowNode();
        return owningWindowNode?.LocalMousePosition ?? Input.MousePosition;
    }

    protected abstract void HandleKeyboardNavigation();

    protected virtual void OnFocusLost()
    {
        if (Input.IsActionPressed("UiAccept") ||
            (Input.IsMouseButtonPressed(MouseButtonCode.Left) && !IsMouseOver()))
        {
            Focused = false;
        }
    }

    protected override void OnThemeFileChanged(string themeFile)
    {
        try
        {
            Style = FileLoader.Load<SliderStyle>(themeFile);
        }
        catch (Exception ex)
        {
            Log.Error($"Failed to load SliderStyle from '{themeFile}': {ex.Message}");
        }
    }

    protected void PlaySound()
    {
        if (!Disabled)
        {
            MoveSound?.Play(AudioBus);
        }
    }

    protected abstract void CalculateTrackBounds();
    protected abstract void UpdateHoverStates();
    protected abstract void HandleInput();
    protected abstract void UpdateGrabberThemeVisuals();
    protected abstract float ConvertPositionToValue(float position);
    protected abstract void DrawForeground(DrawingContext context);
    protected abstract Vector2 CalculateGrabberPosition();

    protected float ApplyStep(float rawValue)
    {
        float clampedValue = Math.Clamp(rawValue, MinValue, MaxValue);

        if (Step <= 0 || MinValue >= MaxValue)
        {
            return clampedValue;
        }

        float steppedValue = MinValue + (float)Math.Round((clampedValue - MinValue) / Step) * Step;
        return Math.Clamp(steppedValue, MinValue, MaxValue);
    }

    public override void Draw(DrawingContext context)
    {
        if (!Visible) return;

        DrawBackground(context);
        DrawForeground(context);
        DrawGrabber(context);
    }

    private void DrawBackground(DrawingContext context)
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        var bounds = new Rect(sliderVisualTopLeft.X, sliderVisualTopLeft.Y, Size.X, Size.Y);
        DrawStyledRectangle(context, bounds, Style.Background);
    }

    private void DrawGrabber(DrawingContext context)
    {
        Vector2 grabberPos = CalculateGrabberPosition();
        ButtonStyle currentGrabberStyle = Style.Grabber.Current;

        var bounds = new Rect(grabberPos.X, grabberPos.Y, GrabberSize.X, GrabberSize.Y);
        DrawStyledRectangle(context, bounds, currentGrabberStyle);
    }

    protected override void HandleClickFocus()
    {
        if (Disabled || !Focusable) return;

        if (trackHovered || grabberHovered)
        {
            Focused = true;
        }
    }
}
</file>

<file path="Source\Nodes\Ui\Slider\SliderStyle.cs">
namespace Cherris;

public class SliderStyle
{
    public BoxStyle Background { get; set; } = new()
    {
        FillColor = DefaultTheme.DisabledFill, // Example default
        BorderColor = DefaultTheme.DisabledBorder
    };
    public BoxStyle Foreground { get; set; } = new()
    {
        FillColor = DefaultTheme.Accent, // Example default
        BorderColor = DefaultTheme.AccentBorder
    };
    public ButtonStylePack Grabber { get; set; } = new();
}
</file>

<file path="Source\Nodes\Ui\Slider\VSlider.cs">
using Vortice.Mathematics; // For Rect

namespace Cherris;

public class VSlider : Slider
{
    public VSliderDirection Direction { get; set; } = VSliderDirection.TopToBottom;

    public VSlider()
    {
        Size = new(16, 200);
        GrabberSize = new(24, 12);
    }
    protected override void CalculateTrackBounds()
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        this.trackPosition = sliderVisualTopLeft; // Store the visual top-left
        trackMin = sliderVisualTopLeft.Y;         // Min Y for mouse interaction range, relative to window
        trackMax = sliderVisualTopLeft.Y + Size.Y;// Max Y for mouse interaction range, relative to window
    }

    protected override void UpdateHoverStates()
    {
        Vector2 mousePos = GetLocalMousePosition(); // window-local mouse coordinates
        Vector2 visualSliderTopLeft = this.trackPosition; // This is (GlobalPosition - Origin)

        trackHovered = mousePos.X >= visualSliderTopLeft.X &&
                       mousePos.X <= visualSliderTopLeft.X + Size.X &&
                       mousePos.Y >= visualSliderTopLeft.Y &&
                       mousePos.Y <= visualSliderTopLeft.Y + Size.Y;

        Vector2 grabberTopLeftPos = CalculateGrabberPosition();
        grabberHovered = mousePos.X >= grabberTopLeftPos.X &&
                         mousePos.X <= grabberTopLeftPos.X + GrabberSize.X &&
                         mousePos.Y >= grabberTopLeftPos.Y &&
                         mousePos.Y <= grabberTopLeftPos.Y + GrabberSize.Y;
    }

    protected override void HandleInput()
    {
        HandleMousePress();
        HandleMouseDrag();
        HandleMouseWheel();
    }

    private void HandleMousePress()
    {
        if (Input.IsMouseButtonPressed(MouseButtonCode.Left))
        {
            if (trackHovered)
            {
                float localMouseY = GetLocalMousePosition().Y;
                float clampedMouseY = Math.Clamp(localMouseY, this.trackPosition.Y, this.trackPosition.Y + Size.Y);
                Value = ConvertPositionToValue(clampedMouseY);
                grabberPressed = true;
                PlaySound();
            }
        }
        else if (Input.IsMouseButtonReleased(MouseButtonCode.Left))
        {
            grabberPressed = false;
        }
    }

    private void HandleMouseDrag()
    {
        if (!grabberPressed) return;

        if (Input.IsMouseButtonReleased(MouseButtonCode.Left))
        {
            grabberPressed = false;
            return;
        }
        float localMouseY = GetLocalMousePosition().Y;
        float clampedMouseY = Math.Clamp(localMouseY, this.trackPosition.Y, this.trackPosition.Y + Size.Y);
        Value = ConvertPositionToValue(clampedMouseY);
    }

    private void HandleMouseWheel()
    {
        if (!trackHovered && !grabberHovered) return;

        float wheelDelta = Input.GetMouseWheelMovement();
        if (wheelDelta == 0) return;

        Value = ApplyStep(Value + (wheelDelta * Step * (Direction == VSliderDirection.TopToBottom ? 1 : -1)));
        PlaySound();
    }

    protected override float ConvertPositionToValue(float positionOnTrackInWindowSpace)
    {
        float visualTrackTopEdge = this.trackPosition.Y; // This is (GlobalPosition - Origin).Y
        float effectiveTrackHeight = Size.Y;

        if (effectiveTrackHeight <= 0) return MinValue;

        float normalized = (positionOnTrackInWindowSpace - visualTrackTopEdge) / effectiveTrackHeight;
        normalized = Math.Clamp(normalized, 0f, 1f);

        if (Direction == VSliderDirection.BottomToTop)
        {
            normalized = 1f - normalized;
        }

        float rawValue = MinValue + normalized * (MaxValue - MinValue);
        return ApplyStep(rawValue);
    }

    protected override void DrawForeground(DrawingContext context)
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        float range = MaxValue - MinValue;
        float fillRatio = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        fillRatio = Math.Clamp(fillRatio, 0f, 1f);

        float foregroundHeight = Size.Y * fillRatio;
        Rect foregroundRect;

        if (Direction == VSliderDirection.BottomToTop)
        {
            foregroundRect = new Rect(
                sliderVisualTopLeft.X,
                sliderVisualTopLeft.Y + Size.Y - foregroundHeight,
                Size.X,
                foregroundHeight
            );
        }
        else // TopToBottom
        {
            foregroundRect = new Rect(
                sliderVisualTopLeft.X,
                sliderVisualTopLeft.Y,
                Size.X,
                foregroundHeight
            );
        }

        if (foregroundRect.Width > 0 && foregroundRect.Height > 0)
        {
            DrawStyledRectangle(context, foregroundRect, Style.Foreground);
        }
    }

    protected override Vector2 CalculateGrabberPosition()
    {
        Vector2 sliderVisualTopLeft = GlobalPosition - Origin;
        float range = MaxValue - MinValue;
        float normalizedValue = (range == 0) ? 0.0f : (this.Value - MinValue) / range;
        normalizedValue = Math.Clamp(normalizedValue, 0f, 1f);

        if (Direction == VSliderDirection.BottomToTop)
        {
            normalizedValue = 1f - normalizedValue;
        }

        float grabberCenterY_relativeToSliderTop = normalizedValue * Size.Y;
        float grabberTopY_relativeToSliderTop = grabberCenterY_relativeToSliderTop - GrabberSize.Y / 2f;
        grabberTopY_relativeToSliderTop = Math.Clamp(grabberTopY_relativeToSliderTop, 0, Size.Y - GrabberSize.Y);
        float finalGrabberTopY_global = sliderVisualTopLeft.Y + grabberTopY_relativeToSliderTop;

        float grabberLeftX_relativeToSliderLeft = (Size.X / 2f) - GrabberSize.X / 2f;
        float finalGrabberLeftX_global = sliderVisualTopLeft.X + grabberLeftX_relativeToSliderLeft;

        return new Vector2(finalGrabberLeftX_global, finalGrabberTopY_global);
    }

    protected override void UpdateGrabberThemeVisuals()
    {
        if (Disabled)
        {
            Style.Grabber.Current = Style.Grabber.Disabled;
            return;
        }

        if (grabberPressed)
        {
            Style.Grabber.Current = Style.Grabber.Pressed;
        }
        else if (Focused)
        {
            Style.Grabber.Current = grabberHovered ? Style.Grabber.Hover : Style.Grabber.Focused;
        }
        else if (grabberHovered)
        {
            Style.Grabber.Current = Style.Grabber.Hover;
        }
        else
        {
            Style.Grabber.Current = Style.Grabber.Normal;
        }
    }

    protected override void HandleKeyboardNavigation()
    {
        if (Input.IsActionPressed("UiUp"))
        {
            Value = ApplyStep(Value + Step * (Direction == VSliderDirection.TopToBottom ? -1 : 1));
            PlaySound();
        }
        else if (Input.IsActionPressed("UiDown"))
        {
            Value = ApplyStep(Value - Step * (Direction == VSliderDirection.TopToBottom ? -1 : 1));
            PlaySound();
        }
    }
}
</file>

<file path="Source\Nodes\Ui\Slider\VSliderDirection.cs">
namespace Cherris;

public enum VSliderDirection
{
    TopToBottom,
    BottomToTop
}
</file>

